"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@apidevtools+json-schema-ref-parser@11.9.3";
exports.ids = ["vendor-chunks/@apidevtools+json-schema-ref-parser@11.9.3"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js ***!
  \*******************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst pointer_js_1 = __importDefault(__webpack_require__(/*! ./pointer.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\n/**\n * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that\n * only has *internal* references, not any *external* references.\n * This method mutates the JSON schema object, adding new references and re-mapping existing ones.\n *\n * @param parser\n * @param options\n */\nfunction bundle(parser, options) {\n    // console.log('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);\n    // Build an inventory of all $ref pointers in the JSON Schema\n    const inventory = [];\n    crawl(parser, \"schema\", parser.$refs._root$Ref.path + \"#\", \"#\", 0, inventory, parser.$refs, options);\n    // Remap all $ref pointers\n    remap(inventory);\n}\n/**\n * Recursively crawls the given value, and inventories all JSON references.\n *\n * @param parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.\n * @param key - The property key of `parent` to be crawled\n * @param path - The full path of the property being crawled, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of the property being crawled, from the schema root\n * @param indirections\n * @param inventory - An array of already-inventoried $ref pointers\n * @param $refs\n * @param options\n */\nfunction crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {\n    const obj = key === null ? parent : parent[key];\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj)) {\n        if (ref_js_1.default.isAllowed$Ref(obj)) {\n            inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);\n        }\n        else {\n            // Crawl the object in a specific order that's optimized for bundling.\n            // This is important because it determines how `pathFromRoot` gets built,\n            // which later determines which keys get dereferenced and which ones get remapped\n            const keys = Object.keys(obj).sort((a, b) => {\n                // Most people will expect references to be bundled into the the \"definitions\" property,\n                // so we always crawl that property first, if it exists.\n                if (a === \"definitions\") {\n                    return -1;\n                }\n                else if (b === \"definitions\") {\n                    return 1;\n                }\n                else {\n                    // Otherwise, crawl the keys based on their length.\n                    // This produces the shortest possible bundled references\n                    return a.length - b.length;\n                }\n            });\n            for (const key of keys) {\n                const keyPath = pointer_js_1.default.join(path, key);\n                const keyPathFromRoot = pointer_js_1.default.join(pathFromRoot, key);\n                const value = obj[key];\n                if (ref_js_1.default.isAllowed$Ref(value)) {\n                    inventory$Ref(obj, key, path, keyPathFromRoot, indirections, inventory, $refs, options);\n                }\n                else {\n                    crawl(obj, key, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);\n                }\n            }\n        }\n    }\n}\n/**\n * Inventories the given JSON Reference (i.e. records detailed information about it so we can\n * optimize all $refs in the schema), and then crawls the resolved value.\n *\n * @param $refParent - The object that contains a JSON Reference as one of its keys\n * @param $refKey - The key in `$refParent` that is a JSON Reference\n * @param path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash\n * @param indirections - unknown\n * @param pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root\n * @param inventory - An array of already-inventoried $ref pointers\n * @param $refs\n * @param options\n */\nfunction inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {\n    const $ref = $refKey === null ? $refParent : $refParent[$refKey];\n    const $refPath = url.resolve(path, $ref.$ref);\n    const pointer = $refs._resolve($refPath, pathFromRoot, options);\n    if (pointer === null) {\n        return;\n    }\n    const parsed = pointer_js_1.default.parse(pathFromRoot);\n    const depth = parsed.length;\n    const file = url.stripHash(pointer.path);\n    const hash = url.getHash(pointer.path);\n    const external = file !== $refs._root$Ref.path;\n    const extended = ref_js_1.default.isExtended$Ref($ref);\n    indirections += pointer.indirections;\n    const existingEntry = findInInventory(inventory, $refParent, $refKey);\n    if (existingEntry) {\n        // This $Ref has already been inventoried, so we don't need to process it again\n        if (depth < existingEntry.depth || indirections < existingEntry.indirections) {\n            removeFromInventory(inventory, existingEntry);\n        }\n        else {\n            return;\n        }\n    }\n    inventory.push({\n        $ref, // The JSON Reference (e.g. {$ref: string})\n        parent: $refParent, // The object that contains this $ref pointer\n        key: $refKey, // The key in `parent` that is the $ref pointer\n        pathFromRoot, // The path to the $ref pointer, from the JSON Schema root\n        depth, // How far from the JSON Schema root is this $ref pointer?\n        file, // The file that the $ref pointer resolves to\n        hash, // The hash within `file` that the $ref pointer resolves to\n        value: pointer.value, // The resolved value of the $ref pointer\n        circular: pointer.circular, // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)\n        extended, // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to \"$ref\")\n        external, // Does this $ref pointer point to a file other than the main JSON Schema file?\n        indirections, // The number of indirect references that were traversed to resolve the value\n    });\n    // Recursively crawl the resolved value\n    if (!existingEntry || external) {\n        crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);\n    }\n}\n/**\n * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.\n * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same\n * value are re-mapped to point to the first reference.\n *\n * @example: {\n *    first: { $ref: somefile.json#/some/part },\n *    second: { $ref: somefile.json#/another/part },\n *    third: { $ref: somefile.json },\n *    fourth: { $ref: somefile.json#/some/part/sub/part }\n *  }\n *\n * In this example, there are four references to the same file, but since the third reference points\n * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be\n * remapped to point inside the third one.\n *\n * On the other hand, if the third reference DIDN'T exist, then the first and second would both need\n * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT\n * need to be dereferenced, because it can be remapped to point inside the first one.\n *\n * @param inventory\n */\nfunction remap(inventory) {\n    // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them\n    inventory.sort((a, b) => {\n        if (a.file !== b.file) {\n            // Group all the $refs that point to the same file\n            return a.file < b.file ? -1 : +1;\n        }\n        else if (a.hash !== b.hash) {\n            // Group all the $refs that point to the same part of the file\n            return a.hash < b.hash ? -1 : +1;\n        }\n        else if (a.circular !== b.circular) {\n            // If the $ref points to itself, then sort it higher than other $refs that point to this $ref\n            return a.circular ? -1 : +1;\n        }\n        else if (a.extended !== b.extended) {\n            // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value\n            return a.extended ? +1 : -1;\n        }\n        else if (a.indirections !== b.indirections) {\n            // Sort direct references higher than indirect references\n            return a.indirections - b.indirections;\n        }\n        else if (a.depth !== b.depth) {\n            // Sort $refs by how close they are to the JSON Schema root\n            return a.depth - b.depth;\n        }\n        else {\n            // Determine how far each $ref is from the \"definitions\" property.\n            // Most people will expect references to be bundled into the the \"definitions\" property if possible.\n            const aDefinitionsIndex = a.pathFromRoot.lastIndexOf(\"/definitions\");\n            const bDefinitionsIndex = b.pathFromRoot.lastIndexOf(\"/definitions\");\n            if (aDefinitionsIndex !== bDefinitionsIndex) {\n                // Give higher priority to the $ref that's closer to the \"definitions\" property\n                return bDefinitionsIndex - aDefinitionsIndex;\n            }\n            else {\n                // All else is equal, so use the shorter path, which will produce the shortest possible reference\n                return a.pathFromRoot.length - b.pathFromRoot.length;\n            }\n        }\n    });\n    let file, hash, pathFromRoot;\n    for (const entry of inventory) {\n        // console.log('Re-mapping $ref pointer \"%s\" at %s', entry.$ref.$ref, entry.pathFromRoot);\n        if (!entry.external) {\n            // This $ref already resolves to the main JSON Schema file\n            entry.$ref.$ref = entry.hash;\n        }\n        else if (entry.file === file && entry.hash === hash) {\n            // This $ref points to the same value as the prevous $ref, so remap it to the same path\n            entry.$ref.$ref = pathFromRoot;\n        }\n        else if (entry.file === file && entry.hash.indexOf(hash + \"/\") === 0) {\n            // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path\n            entry.$ref.$ref = pointer_js_1.default.join(pathFromRoot, pointer_js_1.default.parse(entry.hash.replace(hash, \"#\")));\n        }\n        else {\n            // We've moved to a new file or new hash\n            file = entry.file;\n            hash = entry.hash;\n            pathFromRoot = entry.pathFromRoot;\n            // This is the first $ref to point to this value, so dereference the value.\n            // Any other $refs that point to the same value will point to this $ref instead\n            entry.$ref = entry.parent[entry.key] = ref_js_1.default.dereference(entry.$ref, entry.value);\n            if (entry.circular) {\n                // This $ref points to itself\n                entry.$ref.$ref = entry.pathFromRoot;\n            }\n        }\n    }\n    // we want to ensure that any $refs that point to another $ref are remapped to point to the final value\n    // let hadChange = true;\n    // while (hadChange) {\n    //   hadChange = false;\n    //   for (const entry of inventory) {\n    //     if (entry.$ref && typeof entry.$ref === \"object\" && \"$ref\" in entry.$ref) {\n    //       const resolved = inventory.find((e: InventoryEntry) => e.pathFromRoot === entry.$ref.$ref);\n    //       if (resolved) {\n    //         const resolvedPointsToAnotherRef =\n    //           resolved.$ref && typeof resolved.$ref === \"object\" && \"$ref\" in resolved.$ref;\n    //         if (resolvedPointsToAnotherRef && entry.$ref.$ref !== resolved.$ref.$ref) {\n    //           // console.log('Re-mapping $ref pointer \"%s\" at %s', entry.$ref.$ref, entry.pathFromRoot);\n    //           entry.$ref.$ref = resolved.$ref.$ref;\n    //           hadChange = true;\n    //         }\n    //       }\n    //     }\n    //   }\n    // }\n}\n/**\n * TODO\n */\nfunction findInInventory(inventory, $refParent, $refKey) {\n    for (const existingEntry of inventory) {\n        if (existingEntry && existingEntry.parent === $refParent && existingEntry.key === $refKey) {\n            return existingEntry;\n        }\n    }\n    return undefined;\n}\nfunction removeFromInventory(inventory, entry) {\n    const index = inventory.indexOf(entry);\n    inventory.splice(index, 1);\n}\nexports[\"default\"] = bundle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9idW5kbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsbUJBQU8sQ0FBQyx3SkFBVTtBQUNuRCxxQ0FBcUMsbUJBQU8sQ0FBQyxnS0FBYztBQUMzRCx5QkFBeUIsbUJBQU8sQ0FBQyxrS0FBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLGdCQUFnQixtQ0FBbUM7QUFDbkQsZUFBZSxxQkFBcUI7QUFDcEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlYS1vbGl2ZS13ZWIvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9idW5kbGUuanM/ZGIwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVmX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVmLmpzXCIpKTtcbmNvbnN0IHBvaW50ZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wb2ludGVyLmpzXCIpKTtcbmNvbnN0IHVybCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKSk7XG4vKipcbiAqIEJ1bmRsZXMgYWxsIGV4dGVybmFsIEpTT04gcmVmZXJlbmNlcyBpbnRvIHRoZSBtYWluIEpTT04gc2NoZW1hLCB0aHVzIHJlc3VsdGluZyBpbiBhIHNjaGVtYSB0aGF0XG4gKiBvbmx5IGhhcyAqaW50ZXJuYWwqIHJlZmVyZW5jZXMsIG5vdCBhbnkgKmV4dGVybmFsKiByZWZlcmVuY2VzLlxuICogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgSlNPTiBzY2hlbWEgb2JqZWN0LCBhZGRpbmcgbmV3IHJlZmVyZW5jZXMgYW5kIHJlLW1hcHBpbmcgZXhpc3Rpbmcgb25lcy5cbiAqXG4gKiBAcGFyYW0gcGFyc2VyXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBidW5kbGUocGFyc2VyLCBvcHRpb25zKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ0J1bmRsaW5nICRyZWYgcG9pbnRlcnMgaW4gJXMnLCBwYXJzZXIuJHJlZnMuX3Jvb3QkUmVmLnBhdGgpO1xuICAgIC8vIEJ1aWxkIGFuIGludmVudG9yeSBvZiBhbGwgJHJlZiBwb2ludGVycyBpbiB0aGUgSlNPTiBTY2hlbWFcbiAgICBjb25zdCBpbnZlbnRvcnkgPSBbXTtcbiAgICBjcmF3bChwYXJzZXIsIFwic2NoZW1hXCIsIHBhcnNlci4kcmVmcy5fcm9vdCRSZWYucGF0aCArIFwiI1wiLCBcIiNcIiwgMCwgaW52ZW50b3J5LCBwYXJzZXIuJHJlZnMsIG9wdGlvbnMpO1xuICAgIC8vIFJlbWFwIGFsbCAkcmVmIHBvaW50ZXJzXG4gICAgcmVtYXAoaW52ZW50b3J5KTtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgY3Jhd2xzIHRoZSBnaXZlbiB2YWx1ZSwgYW5kIGludmVudG9yaWVzIGFsbCBKU09OIHJlZmVyZW5jZXMuXG4gKlxuICogQHBhcmFtIHBhcmVudCAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgdmFsdWUgdG8gY3Jhd2wuIElmIHRoZSB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0IG9yIGFycmF5LCBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAcGFyYW0ga2V5IC0gVGhlIHByb3BlcnR5IGtleSBvZiBgcGFyZW50YCB0byBiZSBjcmF3bGVkXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBmdWxsIHBhdGggb2YgdGhlIHByb3BlcnR5IGJlaW5nIGNyYXdsZWQsIHBvc3NpYmx5IHdpdGggYSBKU09OIFBvaW50ZXIgaW4gdGhlIGhhc2hcbiAqIEBwYXJhbSBwYXRoRnJvbVJvb3QgLSBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgYmVpbmcgY3Jhd2xlZCwgZnJvbSB0aGUgc2NoZW1hIHJvb3RcbiAqIEBwYXJhbSBpbmRpcmVjdGlvbnNcbiAqIEBwYXJhbSBpbnZlbnRvcnkgLSBBbiBhcnJheSBvZiBhbHJlYWR5LWludmVudG9yaWVkICRyZWYgcG9pbnRlcnNcbiAqIEBwYXJhbSAkcmVmc1xuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3Jhd2wocGFyZW50LCBrZXksIHBhdGgsIHBhdGhGcm9tUm9vdCwgaW5kaXJlY3Rpb25zLCBpbnZlbnRvcnksICRyZWZzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb2JqID0ga2V5ID09PSBudWxsID8gcGFyZW50IDogcGFyZW50W2tleV07XG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSkge1xuICAgICAgICBpZiAocmVmX2pzXzEuZGVmYXVsdC5pc0FsbG93ZWQkUmVmKG9iaikpIHtcbiAgICAgICAgICAgIGludmVudG9yeSRSZWYocGFyZW50LCBrZXksIHBhdGgsIHBhdGhGcm9tUm9vdCwgaW5kaXJlY3Rpb25zLCBpbnZlbnRvcnksICRyZWZzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyYXdsIHRoZSBvYmplY3QgaW4gYSBzcGVjaWZpYyBvcmRlciB0aGF0J3Mgb3B0aW1pemVkIGZvciBidW5kbGluZy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgaXQgZGV0ZXJtaW5lcyBob3cgYHBhdGhGcm9tUm9vdGAgZ2V0cyBidWlsdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIGxhdGVyIGRldGVybWluZXMgd2hpY2gga2V5cyBnZXQgZGVyZWZlcmVuY2VkIGFuZCB3aGljaCBvbmVzIGdldCByZW1hcHBlZFxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaikuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE1vc3QgcGVvcGxlIHdpbGwgZXhwZWN0IHJlZmVyZW5jZXMgdG8gYmUgYnVuZGxlZCBpbnRvIHRoZSB0aGUgXCJkZWZpbml0aW9uc1wiIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGFsd2F5cyBjcmF3bCB0aGF0IHByb3BlcnR5IGZpcnN0LCBpZiBpdCBleGlzdHMuXG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IFwiZGVmaW5pdGlvbnNcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IFwiZGVmaW5pdGlvbnNcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY3Jhd2wgdGhlIGtleXMgYmFzZWQgb24gdGhlaXIgbGVuZ3RoLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHByb2R1Y2VzIHRoZSBzaG9ydGVzdCBwb3NzaWJsZSBidW5kbGVkIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5UGF0aCA9IHBvaW50ZXJfanNfMS5kZWZhdWx0LmpvaW4ocGF0aCwga2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlQYXRoRnJvbVJvb3QgPSBwb2ludGVyX2pzXzEuZGVmYXVsdC5qb2luKHBhdGhGcm9tUm9vdCwga2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChyZWZfanNfMS5kZWZhdWx0LmlzQWxsb3dlZCRSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVudG9yeSRSZWYob2JqLCBrZXksIHBhdGgsIGtleVBhdGhGcm9tUm9vdCwgaW5kaXJlY3Rpb25zLCBpbnZlbnRvcnksICRyZWZzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNyYXdsKG9iaiwga2V5LCBrZXlQYXRoLCBrZXlQYXRoRnJvbVJvb3QsIGluZGlyZWN0aW9ucywgaW52ZW50b3J5LCAkcmVmcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBJbnZlbnRvcmllcyB0aGUgZ2l2ZW4gSlNPTiBSZWZlcmVuY2UgKGkuZS4gcmVjb3JkcyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBpdCBzbyB3ZSBjYW5cbiAqIG9wdGltaXplIGFsbCAkcmVmcyBpbiB0aGUgc2NoZW1hKSwgYW5kIHRoZW4gY3Jhd2xzIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gJHJlZlBhcmVudCAtIFRoZSBvYmplY3QgdGhhdCBjb250YWlucyBhIEpTT04gUmVmZXJlbmNlIGFzIG9uZSBvZiBpdHMga2V5c1xuICogQHBhcmFtICRyZWZLZXkgLSBUaGUga2V5IGluIGAkcmVmUGFyZW50YCB0aGF0IGlzIGEgSlNPTiBSZWZlcmVuY2VcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiB0aGUgSlNPTiBSZWZlcmVuY2UgYXQgYCRyZWZLZXlgLCBwb3NzaWJseSB3aXRoIGEgSlNPTiBQb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0gaW5kaXJlY3Rpb25zIC0gdW5rbm93blxuICogQHBhcmFtIHBhdGhGcm9tUm9vdCAtIFRoZSBwYXRoIG9mIHRoZSBKU09OIFJlZmVyZW5jZSBhdCBgJHJlZktleWAsIGZyb20gdGhlIHNjaGVtYSByb290XG4gKiBAcGFyYW0gaW52ZW50b3J5IC0gQW4gYXJyYXkgb2YgYWxyZWFkeS1pbnZlbnRvcmllZCAkcmVmIHBvaW50ZXJzXG4gKiBAcGFyYW0gJHJlZnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGludmVudG9yeSRSZWYoJHJlZlBhcmVudCwgJHJlZktleSwgcGF0aCwgcGF0aEZyb21Sb290LCBpbmRpcmVjdGlvbnMsIGludmVudG9yeSwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCAkcmVmID0gJHJlZktleSA9PT0gbnVsbCA/ICRyZWZQYXJlbnQgOiAkcmVmUGFyZW50WyRyZWZLZXldO1xuICAgIGNvbnN0ICRyZWZQYXRoID0gdXJsLnJlc29sdmUocGF0aCwgJHJlZi4kcmVmKTtcbiAgICBjb25zdCBwb2ludGVyID0gJHJlZnMuX3Jlc29sdmUoJHJlZlBhdGgsIHBhdGhGcm9tUm9vdCwgb3B0aW9ucyk7XG4gICAgaWYgKHBvaW50ZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBwb2ludGVyX2pzXzEuZGVmYXVsdC5wYXJzZShwYXRoRnJvbVJvb3QpO1xuICAgIGNvbnN0IGRlcHRoID0gcGFyc2VkLmxlbmd0aDtcbiAgICBjb25zdCBmaWxlID0gdXJsLnN0cmlwSGFzaChwb2ludGVyLnBhdGgpO1xuICAgIGNvbnN0IGhhc2ggPSB1cmwuZ2V0SGFzaChwb2ludGVyLnBhdGgpO1xuICAgIGNvbnN0IGV4dGVybmFsID0gZmlsZSAhPT0gJHJlZnMuX3Jvb3QkUmVmLnBhdGg7XG4gICAgY29uc3QgZXh0ZW5kZWQgPSByZWZfanNfMS5kZWZhdWx0LmlzRXh0ZW5kZWQkUmVmKCRyZWYpO1xuICAgIGluZGlyZWN0aW9ucyArPSBwb2ludGVyLmluZGlyZWN0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gZmluZEluSW52ZW50b3J5KGludmVudG9yeSwgJHJlZlBhcmVudCwgJHJlZktleSk7XG4gICAgaWYgKGV4aXN0aW5nRW50cnkpIHtcbiAgICAgICAgLy8gVGhpcyAkUmVmIGhhcyBhbHJlYWR5IGJlZW4gaW52ZW50b3JpZWQsIHNvIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VzcyBpdCBhZ2FpblxuICAgICAgICBpZiAoZGVwdGggPCBleGlzdGluZ0VudHJ5LmRlcHRoIHx8IGluZGlyZWN0aW9ucyA8IGV4aXN0aW5nRW50cnkuaW5kaXJlY3Rpb25zKSB7XG4gICAgICAgICAgICByZW1vdmVGcm9tSW52ZW50b3J5KGludmVudG9yeSwgZXhpc3RpbmdFbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52ZW50b3J5LnB1c2goe1xuICAgICAgICAkcmVmLCAvLyBUaGUgSlNPTiBSZWZlcmVuY2UgKGUuZy4geyRyZWY6IHN0cmluZ30pXG4gICAgICAgIHBhcmVudDogJHJlZlBhcmVudCwgLy8gVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoaXMgJHJlZiBwb2ludGVyXG4gICAgICAgIGtleTogJHJlZktleSwgLy8gVGhlIGtleSBpbiBgcGFyZW50YCB0aGF0IGlzIHRoZSAkcmVmIHBvaW50ZXJcbiAgICAgICAgcGF0aEZyb21Sb290LCAvLyBUaGUgcGF0aCB0byB0aGUgJHJlZiBwb2ludGVyLCBmcm9tIHRoZSBKU09OIFNjaGVtYSByb290XG4gICAgICAgIGRlcHRoLCAvLyBIb3cgZmFyIGZyb20gdGhlIEpTT04gU2NoZW1hIHJvb3QgaXMgdGhpcyAkcmVmIHBvaW50ZXI/XG4gICAgICAgIGZpbGUsIC8vIFRoZSBmaWxlIHRoYXQgdGhlICRyZWYgcG9pbnRlciByZXNvbHZlcyB0b1xuICAgICAgICBoYXNoLCAvLyBUaGUgaGFzaCB3aXRoaW4gYGZpbGVgIHRoYXQgdGhlICRyZWYgcG9pbnRlciByZXNvbHZlcyB0b1xuICAgICAgICB2YWx1ZTogcG9pbnRlci52YWx1ZSwgLy8gVGhlIHJlc29sdmVkIHZhbHVlIG9mIHRoZSAkcmVmIHBvaW50ZXJcbiAgICAgICAgY2lyY3VsYXI6IHBvaW50ZXIuY2lyY3VsYXIsIC8vIElzIHRoaXMgJHJlZiBwb2ludGVyIERJUkVDVExZIGNpcmN1bGFyPyAoaS5lLiBpdCByZWZlcmVuY2VzIGl0c2VsZilcbiAgICAgICAgZXh0ZW5kZWQsIC8vIERvZXMgdGhpcyAkcmVmIGV4dGVuZCBpdHMgcmVzb2x2ZWQgdmFsdWU/IChpLmUuIGl0IGhhcyBleHRyYSBwcm9wZXJ0aWVzLCBpbiBhZGRpdGlvbiB0byBcIiRyZWZcIilcbiAgICAgICAgZXh0ZXJuYWwsIC8vIERvZXMgdGhpcyAkcmVmIHBvaW50ZXIgcG9pbnQgdG8gYSBmaWxlIG90aGVyIHRoYW4gdGhlIG1haW4gSlNPTiBTY2hlbWEgZmlsZT9cbiAgICAgICAgaW5kaXJlY3Rpb25zLCAvLyBUaGUgbnVtYmVyIG9mIGluZGlyZWN0IHJlZmVyZW5jZXMgdGhhdCB3ZXJlIHRyYXZlcnNlZCB0byByZXNvbHZlIHRoZSB2YWx1ZVxuICAgIH0pO1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNyYXdsIHRoZSByZXNvbHZlZCB2YWx1ZVxuICAgIGlmICghZXhpc3RpbmdFbnRyeSB8fCBleHRlcm5hbCkge1xuICAgICAgICBjcmF3bChwb2ludGVyLnZhbHVlLCBudWxsLCBwb2ludGVyLnBhdGgsIHBhdGhGcm9tUm9vdCwgaW5kaXJlY3Rpb25zICsgMSwgaW52ZW50b3J5LCAkcmVmcywgb3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBSZS1tYXBzIGV2ZXJ5ICRyZWYgcG9pbnRlciwgc28gdGhhdCB0aGV5J3JlIGFsbCByZWxhdGl2ZSB0byB0aGUgcm9vdCBvZiB0aGUgSlNPTiBTY2hlbWEuXG4gKiBFYWNoIHJlZmVyZW5jZWQgdmFsdWUgaXMgZGVyZWZlcmVuY2VkIEVYQUNUTFkgT05DRS4gIEFsbCBzdWJzZXF1ZW50IHJlZmVyZW5jZXMgdG8gdGhlIHNhbWVcbiAqIHZhbHVlIGFyZSByZS1tYXBwZWQgdG8gcG9pbnQgdG8gdGhlIGZpcnN0IHJlZmVyZW5jZS5cbiAqXG4gKiBAZXhhbXBsZToge1xuICogICAgZmlyc3Q6IHsgJHJlZjogc29tZWZpbGUuanNvbiMvc29tZS9wYXJ0IH0sXG4gKiAgICBzZWNvbmQ6IHsgJHJlZjogc29tZWZpbGUuanNvbiMvYW5vdGhlci9wYXJ0IH0sXG4gKiAgICB0aGlyZDogeyAkcmVmOiBzb21lZmlsZS5qc29uIH0sXG4gKiAgICBmb3VydGg6IHsgJHJlZjogc29tZWZpbGUuanNvbiMvc29tZS9wYXJ0L3N1Yi9wYXJ0IH1cbiAqICB9XG4gKlxuICogSW4gdGhpcyBleGFtcGxlLCB0aGVyZSBhcmUgZm91ciByZWZlcmVuY2VzIHRvIHRoZSBzYW1lIGZpbGUsIGJ1dCBzaW5jZSB0aGUgdGhpcmQgcmVmZXJlbmNlIHBvaW50c1xuICogdG8gdGhlIEVOVElSRSBmaWxlLCB0aGF0J3MgdGhlIG9ubHkgb25lIHdlIG5lZWQgdG8gZGVyZWZlcmVuY2UuICBUaGUgb3RoZXIgdGhyZWUgY2FuIGp1c3QgYmVcbiAqIHJlbWFwcGVkIHRvIHBvaW50IGluc2lkZSB0aGUgdGhpcmQgb25lLlxuICpcbiAqIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB0aGUgdGhpcmQgcmVmZXJlbmNlIERJRE4nVCBleGlzdCwgdGhlbiB0aGUgZmlyc3QgYW5kIHNlY29uZCB3b3VsZCBib3RoIG5lZWRcbiAqIHRvIGJlIGRlcmVmZXJlbmNlZCwgc2luY2UgdGhleSBwb2ludCB0byBkaWZmZXJlbnQgcGFydHMgb2YgdGhlIGZpbGUuIFRoZSBmb3VydGggcmVmZXJlbmNlIGRvZXMgTk9UXG4gKiBuZWVkIHRvIGJlIGRlcmVmZXJlbmNlZCwgYmVjYXVzZSBpdCBjYW4gYmUgcmVtYXBwZWQgdG8gcG9pbnQgaW5zaWRlIHRoZSBmaXJzdCBvbmUuXG4gKlxuICogQHBhcmFtIGludmVudG9yeVxuICovXG5mdW5jdGlvbiByZW1hcChpbnZlbnRvcnkpIHtcbiAgICAvLyBHcm91cCAmIHNvcnQgYWxsIHRoZSAkcmVmIHBvaW50ZXJzLCBzbyB0aGV5J3JlIGluIHRoZSBvcmRlciB0aGF0IHdlIG5lZWQgdG8gZGVyZWZlcmVuY2UvcmVtYXAgdGhlbVxuICAgIGludmVudG9yeS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLmZpbGUgIT09IGIuZmlsZSkge1xuICAgICAgICAgICAgLy8gR3JvdXAgYWxsIHRoZSAkcmVmcyB0aGF0IHBvaW50IHRvIHRoZSBzYW1lIGZpbGVcbiAgICAgICAgICAgIHJldHVybiBhLmZpbGUgPCBiLmZpbGUgPyAtMSA6ICsxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaGFzaCAhPT0gYi5oYXNoKSB7XG4gICAgICAgICAgICAvLyBHcm91cCBhbGwgdGhlICRyZWZzIHRoYXQgcG9pbnQgdG8gdGhlIHNhbWUgcGFydCBvZiB0aGUgZmlsZVxuICAgICAgICAgICAgcmV0dXJuIGEuaGFzaCA8IGIuaGFzaCA/IC0xIDogKzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5jaXJjdWxhciAhPT0gYi5jaXJjdWxhcikge1xuICAgICAgICAgICAgLy8gSWYgdGhlICRyZWYgcG9pbnRzIHRvIGl0c2VsZiwgdGhlbiBzb3J0IGl0IGhpZ2hlciB0aGFuIG90aGVyICRyZWZzIHRoYXQgcG9pbnQgdG8gdGhpcyAkcmVmXG4gICAgICAgICAgICByZXR1cm4gYS5jaXJjdWxhciA/IC0xIDogKzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5leHRlbmRlZCAhPT0gYi5leHRlbmRlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlICRyZWYgZXh0ZW5kcyB0aGUgcmVzb2x2ZWQgdmFsdWUsIHRoZW4gc29ydCBpdCBsb3dlciB0aGFuIG90aGVyICRyZWZzIHRoYXQgZG9uJ3QgZXh0ZW5kIHRoZSB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIGEuZXh0ZW5kZWQgPyArMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5kaXJlY3Rpb25zICE9PSBiLmluZGlyZWN0aW9ucykge1xuICAgICAgICAgICAgLy8gU29ydCBkaXJlY3QgcmVmZXJlbmNlcyBoaWdoZXIgdGhhbiBpbmRpcmVjdCByZWZlcmVuY2VzXG4gICAgICAgICAgICByZXR1cm4gYS5pbmRpcmVjdGlvbnMgLSBiLmluZGlyZWN0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmRlcHRoICE9PSBiLmRlcHRoKSB7XG4gICAgICAgICAgICAvLyBTb3J0ICRyZWZzIGJ5IGhvdyBjbG9zZSB0aGV5IGFyZSB0byB0aGUgSlNPTiBTY2hlbWEgcm9vdFxuICAgICAgICAgICAgcmV0dXJuIGEuZGVwdGggLSBiLmRlcHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBmYXIgZWFjaCAkcmVmIGlzIGZyb20gdGhlIFwiZGVmaW5pdGlvbnNcIiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIC8vIE1vc3QgcGVvcGxlIHdpbGwgZXhwZWN0IHJlZmVyZW5jZXMgdG8gYmUgYnVuZGxlZCBpbnRvIHRoZSB0aGUgXCJkZWZpbml0aW9uc1wiIHByb3BlcnR5IGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgY29uc3QgYURlZmluaXRpb25zSW5kZXggPSBhLnBhdGhGcm9tUm9vdC5sYXN0SW5kZXhPZihcIi9kZWZpbml0aW9uc1wiKTtcbiAgICAgICAgICAgIGNvbnN0IGJEZWZpbml0aW9uc0luZGV4ID0gYi5wYXRoRnJvbVJvb3QubGFzdEluZGV4T2YoXCIvZGVmaW5pdGlvbnNcIik7XG4gICAgICAgICAgICBpZiAoYURlZmluaXRpb25zSW5kZXggIT09IGJEZWZpbml0aW9uc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gR2l2ZSBoaWdoZXIgcHJpb3JpdHkgdG8gdGhlICRyZWYgdGhhdCdzIGNsb3NlciB0byB0aGUgXCJkZWZpbml0aW9uc1wiIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJEZWZpbml0aW9uc0luZGV4IC0gYURlZmluaXRpb25zSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBbGwgZWxzZSBpcyBlcXVhbCwgc28gdXNlIHRoZSBzaG9ydGVyIHBhdGgsIHdoaWNoIHdpbGwgcHJvZHVjZSB0aGUgc2hvcnRlc3QgcG9zc2libGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucGF0aEZyb21Sb290Lmxlbmd0aCAtIGIucGF0aEZyb21Sb290Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBmaWxlLCBoYXNoLCBwYXRoRnJvbVJvb3Q7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBpbnZlbnRvcnkpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1JlLW1hcHBpbmcgJHJlZiBwb2ludGVyIFwiJXNcIiBhdCAlcycsIGVudHJ5LiRyZWYuJHJlZiwgZW50cnkucGF0aEZyb21Sb290KTtcbiAgICAgICAgaWYgKCFlbnRyeS5leHRlcm5hbCkge1xuICAgICAgICAgICAgLy8gVGhpcyAkcmVmIGFscmVhZHkgcmVzb2x2ZXMgdG8gdGhlIG1haW4gSlNPTiBTY2hlbWEgZmlsZVxuICAgICAgICAgICAgZW50cnkuJHJlZi4kcmVmID0gZW50cnkuaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbnRyeS5maWxlID09PSBmaWxlICYmIGVudHJ5Lmhhc2ggPT09IGhhc2gpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgJHJlZiBwb2ludHMgdG8gdGhlIHNhbWUgdmFsdWUgYXMgdGhlIHByZXZvdXMgJHJlZiwgc28gcmVtYXAgaXQgdG8gdGhlIHNhbWUgcGF0aFxuICAgICAgICAgICAgZW50cnkuJHJlZi4kcmVmID0gcGF0aEZyb21Sb290O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVudHJ5LmZpbGUgPT09IGZpbGUgJiYgZW50cnkuaGFzaC5pbmRleE9mKGhhc2ggKyBcIi9cIikgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRoaXMgJHJlZiBwb2ludHMgdG8gYSBzdWItdmFsdWUgb2YgdGhlIHByZXZvdXMgJHJlZiwgc28gcmVtYXAgaXQgYmVuZWF0aCB0aGF0IHBhdGhcbiAgICAgICAgICAgIGVudHJ5LiRyZWYuJHJlZiA9IHBvaW50ZXJfanNfMS5kZWZhdWx0LmpvaW4ocGF0aEZyb21Sb290LCBwb2ludGVyX2pzXzEuZGVmYXVsdC5wYXJzZShlbnRyeS5oYXNoLnJlcGxhY2UoaGFzaCwgXCIjXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBtb3ZlZCB0byBhIG5ldyBmaWxlIG9yIG5ldyBoYXNoXG4gICAgICAgICAgICBmaWxlID0gZW50cnkuZmlsZTtcbiAgICAgICAgICAgIGhhc2ggPSBlbnRyeS5oYXNoO1xuICAgICAgICAgICAgcGF0aEZyb21Sb290ID0gZW50cnkucGF0aEZyb21Sb290O1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgJHJlZiB0byBwb2ludCB0byB0aGlzIHZhbHVlLCBzbyBkZXJlZmVyZW5jZSB0aGUgdmFsdWUuXG4gICAgICAgICAgICAvLyBBbnkgb3RoZXIgJHJlZnMgdGhhdCBwb2ludCB0byB0aGUgc2FtZSB2YWx1ZSB3aWxsIHBvaW50IHRvIHRoaXMgJHJlZiBpbnN0ZWFkXG4gICAgICAgICAgICBlbnRyeS4kcmVmID0gZW50cnkucGFyZW50W2VudHJ5LmtleV0gPSByZWZfanNfMS5kZWZhdWx0LmRlcmVmZXJlbmNlKGVudHJ5LiRyZWYsIGVudHJ5LnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5jaXJjdWxhcikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgJHJlZiBwb2ludHMgdG8gaXRzZWxmXG4gICAgICAgICAgICAgICAgZW50cnkuJHJlZi4kcmVmID0gZW50cnkucGF0aEZyb21Sb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYW55ICRyZWZzIHRoYXQgcG9pbnQgdG8gYW5vdGhlciAkcmVmIGFyZSByZW1hcHBlZCB0byBwb2ludCB0byB0aGUgZmluYWwgdmFsdWVcbiAgICAvLyBsZXQgaGFkQ2hhbmdlID0gdHJ1ZTtcbiAgICAvLyB3aGlsZSAoaGFkQ2hhbmdlKSB7XG4gICAgLy8gICBoYWRDaGFuZ2UgPSBmYWxzZTtcbiAgICAvLyAgIGZvciAoY29uc3QgZW50cnkgb2YgaW52ZW50b3J5KSB7XG4gICAgLy8gICAgIGlmIChlbnRyeS4kcmVmICYmIHR5cGVvZiBlbnRyeS4kcmVmID09PSBcIm9iamVjdFwiICYmIFwiJHJlZlwiIGluIGVudHJ5LiRyZWYpIHtcbiAgICAvLyAgICAgICBjb25zdCByZXNvbHZlZCA9IGludmVudG9yeS5maW5kKChlOiBJbnZlbnRvcnlFbnRyeSkgPT4gZS5wYXRoRnJvbVJvb3QgPT09IGVudHJ5LiRyZWYuJHJlZik7XG4gICAgLy8gICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgLy8gICAgICAgICBjb25zdCByZXNvbHZlZFBvaW50c1RvQW5vdGhlclJlZiA9XG4gICAgLy8gICAgICAgICAgIHJlc29sdmVkLiRyZWYgJiYgdHlwZW9mIHJlc29sdmVkLiRyZWYgPT09IFwib2JqZWN0XCIgJiYgXCIkcmVmXCIgaW4gcmVzb2x2ZWQuJHJlZjtcbiAgICAvLyAgICAgICAgIGlmIChyZXNvbHZlZFBvaW50c1RvQW5vdGhlclJlZiAmJiBlbnRyeS4kcmVmLiRyZWYgIT09IHJlc29sdmVkLiRyZWYuJHJlZikge1xuICAgIC8vICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUmUtbWFwcGluZyAkcmVmIHBvaW50ZXIgXCIlc1wiIGF0ICVzJywgZW50cnkuJHJlZi4kcmVmLCBlbnRyeS5wYXRoRnJvbVJvb3QpO1xuICAgIC8vICAgICAgICAgICBlbnRyeS4kcmVmLiRyZWYgPSByZXNvbHZlZC4kcmVmLiRyZWY7XG4gICAgLy8gICAgICAgICAgIGhhZENoYW5nZSA9IHRydWU7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG4gICAgLy8gfVxufVxuLyoqXG4gKiBUT0RPXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbkludmVudG9yeShpbnZlbnRvcnksICRyZWZQYXJlbnQsICRyZWZLZXkpIHtcbiAgICBmb3IgKGNvbnN0IGV4aXN0aW5nRW50cnkgb2YgaW52ZW50b3J5KSB7XG4gICAgICAgIGlmIChleGlzdGluZ0VudHJ5ICYmIGV4aXN0aW5nRW50cnkucGFyZW50ID09PSAkcmVmUGFyZW50ICYmIGV4aXN0aW5nRW50cnkua2V5ID09PSAkcmVmS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdFbnRyeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcmVtb3ZlRnJvbUludmVudG9yeShpbnZlbnRvcnksIGVudHJ5KSB7XG4gICAgY29uc3QgaW5kZXggPSBpbnZlbnRvcnkuaW5kZXhPZihlbnRyeSk7XG4gICAgaW52ZW50b3J5LnNwbGljZShpbmRleCwgMSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBidW5kbGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js ***!
  \************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst pointer_js_1 = __importDefault(__webpack_require__(/*! ./pointer.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_1 = __webpack_require__(/*! ./util/errors */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = dereference;\n/**\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\n *\n * @param parser\n * @param options\n */\nfunction dereference(parser, options) {\n    const start = Date.now();\n    // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\n    const dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, \"#\", new Set(), new Set(), new Map(), parser.$refs, options, start);\n    parser.$refs.circular = dereferenced.circular;\n    parser.schema = dereferenced.value;\n}\n/**\n * Recursively crawls the given value, and dereferences any JSON references.\n *\n * @param obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of `obj` from the schema root\n * @param parents - An array of the parent objects that have already been dereferenced\n * @param processedObjects - An array of all the objects that have already been processed\n * @param dereferencedCache - An map of all the dereferenced objects\n * @param $refs\n * @param options\n * @param startTime - The time when the dereferencing started\n * @returns\n */\nfunction crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime) {\n    let dereferenced;\n    const result = {\n        value: obj,\n        circular: false,\n    };\n    if (options && options.timeoutMs) {\n        if (Date.now() - startTime > options.timeoutMs) {\n            throw new errors_1.TimeoutError(options.timeoutMs);\n        }\n    }\n    const derefOptions = (options.dereference || {});\n    const isExcludedPath = derefOptions.excludedPathMatcher || (() => false);\n    if (derefOptions?.circular === \"ignore\" || !processedObjects.has(obj)) {\n        if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !isExcludedPath(pathFromRoot)) {\n            parents.add(obj);\n            processedObjects.add(obj);\n            if (ref_js_1.default.isAllowed$Ref(obj, options)) {\n                dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n                result.circular = dereferenced.circular;\n                result.value = dereferenced.value;\n            }\n            else {\n                for (const key of Object.keys(obj)) {\n                    const keyPath = pointer_js_1.default.join(path, key);\n                    const keyPathFromRoot = pointer_js_1.default.join(pathFromRoot, key);\n                    if (isExcludedPath(keyPathFromRoot)) {\n                        continue;\n                    }\n                    const value = obj[key];\n                    let circular = false;\n                    if (ref_js_1.default.isAllowed$Ref(value, options)) {\n                        dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n                        circular = dereferenced.circular;\n                        // Avoid pointless mutations; breaks frozen objects to no profit\n                        if (obj[key] !== dereferenced.value) {\n                            // If we have properties we want to preserve from our dereferenced schema then we need\n                            // to copy them over to our new object.\n                            const preserved = new Map();\n                            if (derefOptions?.preservedProperties) {\n                                if (typeof obj[key] === \"object\" && !Array.isArray(obj[key])) {\n                                    derefOptions?.preservedProperties.forEach((prop) => {\n                                        if (prop in obj[key]) {\n                                            preserved.set(prop, obj[key][prop]);\n                                        }\n                                    });\n                                }\n                            }\n                            obj[key] = dereferenced.value;\n                            // If we have data to preserve and our dereferenced object is still an object then\n                            // we need copy back our preserved data into our dereferenced schema.\n                            if (derefOptions?.preservedProperties) {\n                                if (preserved.size && typeof obj[key] === \"object\" && !Array.isArray(obj[key])) {\n                                    preserved.forEach((value, prop) => {\n                                        obj[key][prop] = value;\n                                    });\n                                }\n                            }\n                            derefOptions?.onDereference?.(value.$ref, obj[key], obj, key);\n                        }\n                    }\n                    else {\n                        if (!parents.has(value)) {\n                            dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n                            circular = dereferenced.circular;\n                            // Avoid pointless mutations; breaks frozen objects to no profit\n                            if (obj[key] !== dereferenced.value) {\n                                obj[key] = dereferenced.value;\n                            }\n                        }\n                        else {\n                            circular = foundCircularReference(keyPath, $refs, options);\n                        }\n                    }\n                    // Set the \"isCircular\" flag if this or any other property is circular\n                    result.circular = result.circular || circular;\n                }\n            }\n            parents.delete(obj);\n        }\n    }\n    return result;\n}\n/**\n * Dereferences the given JSON Reference, and then crawls the resulting value.\n *\n * @param $ref - The JSON Reference to resolve\n * @param path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of `$ref` from the schema root\n * @param parents - An array of the parent objects that have already been dereferenced\n * @param processedObjects - An array of all the objects that have already been dereferenced\n * @param dereferencedCache - An map of all the dereferenced objects\n * @param $refs\n * @param options\n * @returns\n */\nfunction dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime) {\n    const isExternalRef = ref_js_1.default.isExternal$Ref($ref);\n    const shouldResolveOnCwd = isExternalRef && options?.dereference?.externalReferenceResolution === \"root\";\n    const $refPath = url.resolve(shouldResolveOnCwd ? url.cwd() : path, $ref.$ref);\n    const cache = dereferencedCache.get($refPath);\n    if (cache && !cache.circular) {\n        const refKeys = Object.keys($ref);\n        if (refKeys.length > 1) {\n            const extraKeys = {};\n            for (const key of refKeys) {\n                if (key !== \"$ref\" && !(key in cache.value)) {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    extraKeys[key] = $ref[key];\n                }\n            }\n            return {\n                circular: cache.circular,\n                value: Object.assign({}, cache.value, extraKeys),\n            };\n        }\n        return cache;\n    }\n    const pointer = $refs._resolve($refPath, path, options);\n    if (pointer === null) {\n        return {\n            circular: false,\n            value: null,\n        };\n    }\n    // Check for circular references\n    const directCircular = pointer.circular;\n    let circular = directCircular || parents.has(pointer.value);\n    if (circular) {\n        foundCircularReference(path, $refs, options);\n    }\n    // Dereference the JSON reference\n    let dereferencedValue = ref_js_1.default.dereference($ref, pointer.value);\n    // Crawl the dereferenced value (unless it's circular)\n    if (!circular) {\n        // Determine if the dereferenced value is circular\n        const dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n        circular = dereferenced.circular;\n        dereferencedValue = dereferenced.value;\n    }\n    if (circular && !directCircular && options.dereference?.circular === \"ignore\") {\n        // The user has chosen to \"ignore\" circular references, so don't change the value\n        dereferencedValue = $ref;\n    }\n    if (directCircular) {\n        // The pointer is a DIRECT circular reference (i.e. it references itself).\n        // So replace the $ref path with the absolute path from the JSON Schema root\n        dereferencedValue.$ref = pathFromRoot;\n    }\n    const dereferencedObject = {\n        circular,\n        value: dereferencedValue,\n    };\n    // only cache if no extra properties than $ref\n    if (Object.keys($ref).length === 1) {\n        dereferencedCache.set($refPath, dereferencedObject);\n    }\n    return dereferencedObject;\n}\n/**\n * Called when a circular reference is found.\n * It sets the {@link $Refs#circular} flag, executes the options.dereference.onCircular callback,\n * and throws an error if options.dereference.circular is false.\n *\n * @param keyPath - The JSON Reference path of the circular reference\n * @param $refs\n * @param options\n * @returns - always returns true, to indicate that a circular reference was found\n */\nfunction foundCircularReference(keyPath, $refs, options) {\n    $refs.circular = true;\n    options?.dereference?.onCircular?.(keyPath);\n    if (!options.dereference.circular) {\n        throw ono_1.ono.reference(`Circular $ref pointer found at ${keyPath}`);\n    }\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9kZXJlZmVyZW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxtQkFBTyxDQUFDLHdKQUFVO0FBQ25ELHFDQUFxQyxtQkFBTyxDQUFDLGdLQUFjO0FBQzNELGNBQWMsbUJBQU8sQ0FBQyxtSEFBaUI7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsa0tBQWU7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMscUtBQWU7QUFDeEMsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsUUFBUTtBQUM1RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWEtb2xpdmUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhcGlkZXZ0b29scytqc29uLXNjaGVtYS1yZWYtcGFyc2VyQDExLjkuMy9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvZGVyZWZlcmVuY2UuanM/YjhmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVmX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVmLmpzXCIpKTtcbmNvbnN0IHBvaW50ZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wb2ludGVyLmpzXCIpKTtcbmNvbnN0IG9ub18xID0gcmVxdWlyZShcIkBqc2RldnRvb2xzL29ub1wiKTtcbmNvbnN0IHVybCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvZXJyb3JzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVyZWZlcmVuY2U7XG4vKipcbiAqIENyYXdscyB0aGUgSlNPTiBzY2hlbWEsIGZpbmRzIGFsbCBKU09OIHJlZmVyZW5jZXMsIGFuZCBkZXJlZmVyZW5jZXMgdGhlbS5cbiAqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIEpTT04gc2NoZW1hIG9iamVjdCwgcmVwbGFjaW5nIEpTT04gcmVmZXJlbmNlcyB3aXRoIHRoZWlyIHJlc29sdmVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBwYXJzZXJcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGRlcmVmZXJlbmNlKHBhcnNlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAvLyBjb25zb2xlLmxvZygnRGVyZWZlcmVuY2luZyAkcmVmIHBvaW50ZXJzIGluICVzJywgcGFyc2VyLiRyZWZzLl9yb290JFJlZi5wYXRoKTtcbiAgICBjb25zdCBkZXJlZmVyZW5jZWQgPSBjcmF3bChwYXJzZXIuc2NoZW1hLCBwYXJzZXIuJHJlZnMuX3Jvb3QkUmVmLnBhdGgsIFwiI1wiLCBuZXcgU2V0KCksIG5ldyBTZXQoKSwgbmV3IE1hcCgpLCBwYXJzZXIuJHJlZnMsIG9wdGlvbnMsIHN0YXJ0KTtcbiAgICBwYXJzZXIuJHJlZnMuY2lyY3VsYXIgPSBkZXJlZmVyZW5jZWQuY2lyY3VsYXI7XG4gICAgcGFyc2VyLnNjaGVtYSA9IGRlcmVmZXJlbmNlZC52YWx1ZTtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgY3Jhd2xzIHRoZSBnaXZlbiB2YWx1ZSwgYW5kIGRlcmVmZXJlbmNlcyBhbnkgSlNPTiByZWZlcmVuY2VzLlxuICpcbiAqIEBwYXJhbSBvYmogLSBUaGUgdmFsdWUgdG8gY3Jhd2wuIElmIGl0J3Mgbm90IGFuIG9iamVjdCBvciBhcnJheSwgaXQgd2lsbCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIG9mIGBvYmpgLCBwb3NzaWJseSB3aXRoIGEgSlNPTiBQb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0gcGF0aEZyb21Sb290IC0gVGhlIHBhdGggb2YgYG9iamAgZnJvbSB0aGUgc2NoZW1hIHJvb3RcbiAqIEBwYXJhbSBwYXJlbnRzIC0gQW4gYXJyYXkgb2YgdGhlIHBhcmVudCBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGVyZWZlcmVuY2VkXG4gKiBAcGFyYW0gcHJvY2Vzc2VkT2JqZWN0cyAtIEFuIGFycmF5IG9mIGFsbCB0aGUgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZFxuICogQHBhcmFtIGRlcmVmZXJlbmNlZENhY2hlIC0gQW4gbWFwIG9mIGFsbCB0aGUgZGVyZWZlcmVuY2VkIG9iamVjdHNcbiAqIEBwYXJhbSAkcmVmc1xuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgdGltZSB3aGVuIHRoZSBkZXJlZmVyZW5jaW5nIHN0YXJ0ZWRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGNyYXdsKG9iaiwgcGF0aCwgcGF0aEZyb21Sb290LCBwYXJlbnRzLCBwcm9jZXNzZWRPYmplY3RzLCBkZXJlZmVyZW5jZWRDYWNoZSwgJHJlZnMsIG9wdGlvbnMsIHN0YXJ0VGltZSkge1xuICAgIGxldCBkZXJlZmVyZW5jZWQ7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICB2YWx1ZTogb2JqLFxuICAgICAgICBjaXJjdWxhcjogZmFsc2UsXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnRpbWVvdXRNcykge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+IG9wdGlvbnMudGltZW91dE1zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKG9wdGlvbnMudGltZW91dE1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZXJlZk9wdGlvbnMgPSAob3B0aW9ucy5kZXJlZmVyZW5jZSB8fCB7fSk7XG4gICAgY29uc3QgaXNFeGNsdWRlZFBhdGggPSBkZXJlZk9wdGlvbnMuZXhjbHVkZWRQYXRoTWF0Y2hlciB8fCAoKCkgPT4gZmFsc2UpO1xuICAgIGlmIChkZXJlZk9wdGlvbnM/LmNpcmN1bGFyID09PSBcImlnbm9yZVwiIHx8ICFwcm9jZXNzZWRPYmplY3RzLmhhcyhvYmopKSB7XG4gICAgICAgIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgJiYgIWlzRXhjbHVkZWRQYXRoKHBhdGhGcm9tUm9vdCkpIHtcbiAgICAgICAgICAgIHBhcmVudHMuYWRkKG9iaik7XG4gICAgICAgICAgICBwcm9jZXNzZWRPYmplY3RzLmFkZChvYmopO1xuICAgICAgICAgICAgaWYgKHJlZl9qc18xLmRlZmF1bHQuaXNBbGxvd2VkJFJlZihvYmosIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgZGVyZWZlcmVuY2VkID0gZGVyZWZlcmVuY2UkUmVmKG9iaiwgcGF0aCwgcGF0aEZyb21Sb290LCBwYXJlbnRzLCBwcm9jZXNzZWRPYmplY3RzLCBkZXJlZmVyZW5jZWRDYWNoZSwgJHJlZnMsIG9wdGlvbnMsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNpcmN1bGFyID0gZGVyZWZlcmVuY2VkLmNpcmN1bGFyO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IGRlcmVmZXJlbmNlZC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5UGF0aCA9IHBvaW50ZXJfanNfMS5kZWZhdWx0LmpvaW4ocGF0aCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5UGF0aEZyb21Sb290ID0gcG9pbnRlcl9qc18xLmRlZmF1bHQuam9pbihwYXRoRnJvbVJvb3QsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0V4Y2x1ZGVkUGF0aChrZXlQYXRoRnJvbVJvb3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2lyY3VsYXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZl9qc18xLmRlZmF1bHQuaXNBbGxvd2VkJFJlZih2YWx1ZSwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcmVmZXJlbmNlZCA9IGRlcmVmZXJlbmNlJFJlZih2YWx1ZSwga2V5UGF0aCwga2V5UGF0aEZyb21Sb290LCBwYXJlbnRzLCBwcm9jZXNzZWRPYmplY3RzLCBkZXJlZmVyZW5jZWRDYWNoZSwgJHJlZnMsIG9wdGlvbnMsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaXJjdWxhciA9IGRlcmVmZXJlbmNlZC5jaXJjdWxhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIHBvaW50bGVzcyBtdXRhdGlvbnM7IGJyZWFrcyBmcm96ZW4gb2JqZWN0cyB0byBubyBwcm9maXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSAhPT0gZGVyZWZlcmVuY2VkLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBwcm9wZXJ0aWVzIHdlIHdhbnQgdG8gcHJlc2VydmUgZnJvbSBvdXIgZGVyZWZlcmVuY2VkIHNjaGVtYSB0aGVuIHdlIG5lZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBjb3B5IHRoZW0gb3ZlciB0byBvdXIgbmV3IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVzZXJ2ZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcmVmT3B0aW9ucz8ucHJlc2VydmVkUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVyZWZPcHRpb25zPy5wcmVzZXJ2ZWRQcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCBpbiBvYmpba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZWQuc2V0KHByb3AsIG9ialtrZXldW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGRlcmVmZXJlbmNlZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGRhdGEgdG8gcHJlc2VydmUgYW5kIG91ciBkZXJlZmVyZW5jZWQgb2JqZWN0IGlzIHN0aWxsIGFuIG9iamVjdCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCBjb3B5IGJhY2sgb3VyIHByZXNlcnZlZCBkYXRhIGludG8gb3VyIGRlcmVmZXJlbmNlZCBzY2hlbWEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcmVmT3B0aW9ucz8ucHJlc2VydmVkUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVkLnNpemUgJiYgdHlwZW9mIG9ialtrZXldID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVkLmZvckVhY2goKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV1bcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcmVmT3B0aW9ucz8ub25EZXJlZmVyZW5jZT8uKHZhbHVlLiRyZWYsIG9ialtrZXldLCBvYmosIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcmVmZXJlbmNlZCA9IGNyYXdsKHZhbHVlLCBrZXlQYXRoLCBrZXlQYXRoRnJvbVJvb3QsIHBhcmVudHMsIHByb2Nlc3NlZE9iamVjdHMsIGRlcmVmZXJlbmNlZENhY2hlLCAkcmVmcywgb3B0aW9ucywgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXJjdWxhciA9IGRlcmVmZXJlbmNlZC5jaXJjdWxhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBwb2ludGxlc3MgbXV0YXRpb25zOyBicmVha3MgZnJvemVuIG9iamVjdHMgdG8gbm8gcHJvZml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ialtrZXldICE9PSBkZXJlZmVyZW5jZWQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBkZXJlZmVyZW5jZWQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lyY3VsYXIgPSBmb3VuZENpcmN1bGFyUmVmZXJlbmNlKGtleVBhdGgsICRyZWZzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIFwiaXNDaXJjdWxhclwiIGZsYWcgaWYgdGhpcyBvciBhbnkgb3RoZXIgcHJvcGVydHkgaXMgY2lyY3VsYXJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNpcmN1bGFyID0gcmVzdWx0LmNpcmN1bGFyIHx8IGNpcmN1bGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudHMuZGVsZXRlKG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogRGVyZWZlcmVuY2VzIHRoZSBnaXZlbiBKU09OIFJlZmVyZW5jZSwgYW5kIHRoZW4gY3Jhd2xzIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKlxuICogQHBhcmFtICRyZWYgLSBUaGUgSlNPTiBSZWZlcmVuY2UgdG8gcmVzb2x2ZVxuICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIG9mIGAkcmVmYCwgcG9zc2libHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtIHBhdGhGcm9tUm9vdCAtIFRoZSBwYXRoIG9mIGAkcmVmYCBmcm9tIHRoZSBzY2hlbWEgcm9vdFxuICogQHBhcmFtIHBhcmVudHMgLSBBbiBhcnJheSBvZiB0aGUgcGFyZW50IG9iamVjdHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXJlZmVyZW5jZWRcbiAqIEBwYXJhbSBwcm9jZXNzZWRPYmplY3RzIC0gQW4gYXJyYXkgb2YgYWxsIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGVyZWZlcmVuY2VkXG4gKiBAcGFyYW0gZGVyZWZlcmVuY2VkQ2FjaGUgLSBBbiBtYXAgb2YgYWxsIHRoZSBkZXJlZmVyZW5jZWQgb2JqZWN0c1xuICogQHBhcmFtICRyZWZzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZGVyZWZlcmVuY2UkUmVmKCRyZWYsIHBhdGgsIHBhdGhGcm9tUm9vdCwgcGFyZW50cywgcHJvY2Vzc2VkT2JqZWN0cywgZGVyZWZlcmVuY2VkQ2FjaGUsICRyZWZzLCBvcHRpb25zLCBzdGFydFRpbWUpIHtcbiAgICBjb25zdCBpc0V4dGVybmFsUmVmID0gcmVmX2pzXzEuZGVmYXVsdC5pc0V4dGVybmFsJFJlZigkcmVmKTtcbiAgICBjb25zdCBzaG91bGRSZXNvbHZlT25Dd2QgPSBpc0V4dGVybmFsUmVmICYmIG9wdGlvbnM/LmRlcmVmZXJlbmNlPy5leHRlcm5hbFJlZmVyZW5jZVJlc29sdXRpb24gPT09IFwicm9vdFwiO1xuICAgIGNvbnN0ICRyZWZQYXRoID0gdXJsLnJlc29sdmUoc2hvdWxkUmVzb2x2ZU9uQ3dkID8gdXJsLmN3ZCgpIDogcGF0aCwgJHJlZi4kcmVmKTtcbiAgICBjb25zdCBjYWNoZSA9IGRlcmVmZXJlbmNlZENhY2hlLmdldCgkcmVmUGF0aCk7XG4gICAgaWYgKGNhY2hlICYmICFjYWNoZS5jaXJjdWxhcikge1xuICAgICAgICBjb25zdCByZWZLZXlzID0gT2JqZWN0LmtleXMoJHJlZik7XG4gICAgICAgIGlmIChyZWZLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhS2V5cyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmVmS2V5cykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IFwiJHJlZlwiICYmICEoa2V5IGluIGNhY2hlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTKDcwNTMpOiBFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGUgYmVjYXVzZSBleHByZS4uLiBSZW1vdmUgdGhpcyBjb21tZW50IHRvIHNlZSB0aGUgZnVsbCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhS2V5c1trZXldID0gJHJlZltrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2lyY3VsYXI6IGNhY2hlLmNpcmN1bGFyLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZS52YWx1ZSwgZXh0cmFLZXlzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgICBjb25zdCBwb2ludGVyID0gJHJlZnMuX3Jlc29sdmUoJHJlZlBhdGgsIHBhdGgsIG9wdGlvbnMpO1xuICAgIGlmIChwb2ludGVyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaXJjdWxhcjogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICBjb25zdCBkaXJlY3RDaXJjdWxhciA9IHBvaW50ZXIuY2lyY3VsYXI7XG4gICAgbGV0IGNpcmN1bGFyID0gZGlyZWN0Q2lyY3VsYXIgfHwgcGFyZW50cy5oYXMocG9pbnRlci52YWx1ZSk7XG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICAgIGZvdW5kQ2lyY3VsYXJSZWZlcmVuY2UocGF0aCwgJHJlZnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBEZXJlZmVyZW5jZSB0aGUgSlNPTiByZWZlcmVuY2VcbiAgICBsZXQgZGVyZWZlcmVuY2VkVmFsdWUgPSByZWZfanNfMS5kZWZhdWx0LmRlcmVmZXJlbmNlKCRyZWYsIHBvaW50ZXIudmFsdWUpO1xuICAgIC8vIENyYXdsIHRoZSBkZXJlZmVyZW5jZWQgdmFsdWUgKHVubGVzcyBpdCdzIGNpcmN1bGFyKVxuICAgIGlmICghY2lyY3VsYXIpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBkZXJlZmVyZW5jZWQgdmFsdWUgaXMgY2lyY3VsYXJcbiAgICAgICAgY29uc3QgZGVyZWZlcmVuY2VkID0gY3Jhd2woZGVyZWZlcmVuY2VkVmFsdWUsIHBvaW50ZXIucGF0aCwgcGF0aEZyb21Sb290LCBwYXJlbnRzLCBwcm9jZXNzZWRPYmplY3RzLCBkZXJlZmVyZW5jZWRDYWNoZSwgJHJlZnMsIG9wdGlvbnMsIHN0YXJ0VGltZSk7XG4gICAgICAgIGNpcmN1bGFyID0gZGVyZWZlcmVuY2VkLmNpcmN1bGFyO1xuICAgICAgICBkZXJlZmVyZW5jZWRWYWx1ZSA9IGRlcmVmZXJlbmNlZC52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGNpcmN1bGFyICYmICFkaXJlY3RDaXJjdWxhciAmJiBvcHRpb25zLmRlcmVmZXJlbmNlPy5jaXJjdWxhciA9PT0gXCJpZ25vcmVcIikge1xuICAgICAgICAvLyBUaGUgdXNlciBoYXMgY2hvc2VuIHRvIFwiaWdub3JlXCIgY2lyY3VsYXIgcmVmZXJlbmNlcywgc28gZG9uJ3QgY2hhbmdlIHRoZSB2YWx1ZVxuICAgICAgICBkZXJlZmVyZW5jZWRWYWx1ZSA9ICRyZWY7XG4gICAgfVxuICAgIGlmIChkaXJlY3RDaXJjdWxhcikge1xuICAgICAgICAvLyBUaGUgcG9pbnRlciBpcyBhIERJUkVDVCBjaXJjdWxhciByZWZlcmVuY2UgKGkuZS4gaXQgcmVmZXJlbmNlcyBpdHNlbGYpLlxuICAgICAgICAvLyBTbyByZXBsYWNlIHRoZSAkcmVmIHBhdGggd2l0aCB0aGUgYWJzb2x1dGUgcGF0aCBmcm9tIHRoZSBKU09OIFNjaGVtYSByb290XG4gICAgICAgIGRlcmVmZXJlbmNlZFZhbHVlLiRyZWYgPSBwYXRoRnJvbVJvb3Q7XG4gICAgfVxuICAgIGNvbnN0IGRlcmVmZXJlbmNlZE9iamVjdCA9IHtcbiAgICAgICAgY2lyY3VsYXIsXG4gICAgICAgIHZhbHVlOiBkZXJlZmVyZW5jZWRWYWx1ZSxcbiAgICB9O1xuICAgIC8vIG9ubHkgY2FjaGUgaWYgbm8gZXh0cmEgcHJvcGVydGllcyB0aGFuICRyZWZcbiAgICBpZiAoT2JqZWN0LmtleXMoJHJlZikubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGRlcmVmZXJlbmNlZENhY2hlLnNldCgkcmVmUGF0aCwgZGVyZWZlcmVuY2VkT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcmVmZXJlbmNlZE9iamVjdDtcbn1cbi8qKlxuICogQ2FsbGVkIHdoZW4gYSBjaXJjdWxhciByZWZlcmVuY2UgaXMgZm91bmQuXG4gKiBJdCBzZXRzIHRoZSB7QGxpbmsgJFJlZnMjY2lyY3VsYXJ9IGZsYWcsIGV4ZWN1dGVzIHRoZSBvcHRpb25zLmRlcmVmZXJlbmNlLm9uQ2lyY3VsYXIgY2FsbGJhY2ssXG4gKiBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIG9wdGlvbnMuZGVyZWZlcmVuY2UuY2lyY3VsYXIgaXMgZmFsc2UuXG4gKlxuICogQHBhcmFtIGtleVBhdGggLSBUaGUgSlNPTiBSZWZlcmVuY2UgcGF0aCBvZiB0aGUgY2lyY3VsYXIgcmVmZXJlbmNlXG4gKiBAcGFyYW0gJHJlZnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyAtIGFsd2F5cyByZXR1cm5zIHRydWUsIHRvIGluZGljYXRlIHRoYXQgYSBjaXJjdWxhciByZWZlcmVuY2Ugd2FzIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGZvdW5kQ2lyY3VsYXJSZWZlcmVuY2Uoa2V5UGF0aCwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgICAkcmVmcy5jaXJjdWxhciA9IHRydWU7XG4gICAgb3B0aW9ucz8uZGVyZWZlcmVuY2U/Lm9uQ2lyY3VsYXI/LihrZXlQYXRoKTtcbiAgICBpZiAoIW9wdGlvbnMuZGVyZWZlcmVuY2UuY2lyY3VsYXIpIHtcbiAgICAgICAgdGhyb3cgb25vXzEub25vLnJlZmVyZW5jZShgQ2lyY3VsYXIgJHJlZiBwb2ludGVyIGZvdW5kIGF0ICR7a2V5UGF0aH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/index.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/index.js ***!
  \******************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getJsonSchemaRefParserDefaultOptions = exports.jsonSchemaParserNormalizeArgs = exports.dereferenceInternal = exports.JSONParserErrorGroup = exports.isHandledError = exports.UnmatchedParserError = exports.ParserError = exports.ResolverError = exports.MissingPointerError = exports.InvalidPointerError = exports.JSONParserError = exports.UnmatchedResolverError = exports.dereference = exports.bundle = exports.resolve = exports.parse = exports.$RefParser = void 0;\nconst refs_js_1 = __importDefault(__webpack_require__(/*! ./refs.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js\"));\nconst parse_js_1 = __importDefault(__webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js\"));\nconst normalize_args_js_1 = __importDefault(__webpack_require__(/*! ./normalize-args.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js\"));\nexports.jsonSchemaParserNormalizeArgs = normalize_args_js_1.default;\nconst resolve_external_js_1 = __importDefault(__webpack_require__(/*! ./resolve-external.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js\"));\nconst bundle_js_1 = __importDefault(__webpack_require__(/*! ./bundle.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js\"));\nconst dereference_js_1 = __importDefault(__webpack_require__(/*! ./dereference.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js\"));\nexports.dereferenceInternal = dereference_js_1.default;\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nObject.defineProperty(exports, \"JSONParserError\", ({ enumerable: true, get: function () { return errors_js_1.JSONParserError; } }));\nObject.defineProperty(exports, \"InvalidPointerError\", ({ enumerable: true, get: function () { return errors_js_1.InvalidPointerError; } }));\nObject.defineProperty(exports, \"MissingPointerError\", ({ enumerable: true, get: function () { return errors_js_1.MissingPointerError; } }));\nObject.defineProperty(exports, \"ResolverError\", ({ enumerable: true, get: function () { return errors_js_1.ResolverError; } }));\nObject.defineProperty(exports, \"ParserError\", ({ enumerable: true, get: function () { return errors_js_1.ParserError; } }));\nObject.defineProperty(exports, \"UnmatchedParserError\", ({ enumerable: true, get: function () { return errors_js_1.UnmatchedParserError; } }));\nObject.defineProperty(exports, \"UnmatchedResolverError\", ({ enumerable: true, get: function () { return errors_js_1.UnmatchedResolverError; } }));\nObject.defineProperty(exports, \"isHandledError\", ({ enumerable: true, get: function () { return errors_js_1.isHandledError; } }));\nObject.defineProperty(exports, \"JSONParserErrorGroup\", ({ enumerable: true, get: function () { return errors_js_1.JSONParserErrorGroup; } }));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/index.js\");\nconst maybe_js_1 = __importDefault(__webpack_require__(/*! ./util/maybe.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js\"));\nconst options_js_1 = __webpack_require__(/*! ./options.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js\");\nObject.defineProperty(exports, \"getJsonSchemaRefParserDefaultOptions\", ({ enumerable: true, get: function () { return options_js_1.getJsonSchemaRefParserDefaultOptions; } }));\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @class\n */\nclass $RefParser {\n    constructor() {\n        /**\n         * The parsed (and possibly dereferenced) JSON schema object\n         *\n         * @type {object}\n         * @readonly\n         */\n        this.schema = null;\n        /**\n         * The resolved JSON references\n         *\n         * @type {$Refs}\n         * @readonly\n         */\n        this.$refs = new refs_js_1.default();\n    }\n    async parse() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        let promise;\n        if (!args.path && !args.schema) {\n            const err = (0, ono_1.ono)(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n        // Reset everything\n        this.schema = null;\n        this.$refs = new refs_js_1.default();\n        // If the path is a filesystem path, then convert it to a URL.\n        // NOTE: According to the JSON Reference spec, these should already be URLs,\n        // but, in practice, many people use local filesystem paths instead.\n        // So we're being generous here and doing the conversion automatically.\n        // This is not intended to be a 100% bulletproof solution.\n        // If it doesn't work for your use-case, then use a URL instead.\n        let pathType = \"http\";\n        if (url.isFileSystemPath(args.path)) {\n            args.path = url.fromFileSystemPath(args.path);\n            pathType = \"file\";\n        }\n        else if (!args.path && args.schema && \"$id\" in args.schema && args.schema.$id) {\n            // when schema id has defined an URL should use that hostname to request the references,\n            // instead of using the current page URL\n            const params = url.parse(args.schema.$id);\n            const port = params.protocol === \"https:\" ? 443 : 80;\n            args.path = `${params.protocol}//${params.hostname}:${port}`;\n        }\n        // Resolve the absolute path of the schema\n        args.path = url.resolve(url.cwd(), args.path);\n        if (args.schema && typeof args.schema === \"object\") {\n            // A schema object was passed-in.\n            // So immediately add a new $Ref with the schema object as its value\n            const $ref = this.$refs._add(args.path);\n            $ref.value = args.schema;\n            $ref.pathType = pathType;\n            promise = Promise.resolve(args.schema);\n        }\n        else {\n            // Parse the schema file/url\n            promise = (0, parse_js_1.default)(args.path, this.$refs, args.options);\n        }\n        try {\n            const result = await promise;\n            if (result !== null && typeof result === \"object\" && !Buffer.isBuffer(result)) {\n                this.schema = result;\n                return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n            }\n            else if (args.options.continueOnError) {\n                this.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability\n                return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n            }\n            else {\n                throw ono_1.ono.syntax(`\"${this.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n            }\n        }\n        catch (err) {\n            if (!args.options.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n                return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n            }\n            if (this.$refs._$refs[url.stripHash(args.path)]) {\n                this.$refs._$refs[url.stripHash(args.path)].addError(err);\n            }\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(null));\n        }\n    }\n    static parse() {\n        const parser = new $RefParser();\n        return parser.parse.apply(parser, arguments);\n    }\n    async resolve() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.parse(args.path, args.schema, args.options);\n            await (0, resolve_external_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.$refs));\n        }\n        catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n    static resolve() {\n        const instance = new $RefParser();\n        return instance.resolve.apply(instance, arguments);\n    }\n    static bundle() {\n        const instance = new $RefParser();\n        return instance.bundle.apply(instance, arguments);\n    }\n    async bundle() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.resolve(args.path, args.schema, args.options);\n            (0, bundle_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n        }\n        catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n    static dereference() {\n        const instance = new $RefParser();\n        return instance.dereference.apply(instance, arguments);\n    }\n    async dereference() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.resolve(args.path, args.schema, args.options);\n            (0, dereference_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n        }\n        catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n}\nexports.$RefParser = $RefParser;\nexports[\"default\"] = $RefParser;\nfunction finalize(parser) {\n    const errors = errors_js_1.JSONParserErrorGroup.getParserErrors(parser);\n    if (errors.length > 0) {\n        throw new errors_js_1.JSONParserErrorGroup(parser);\n    }\n}\nexports.parse = $RefParser.parse;\nexports.resolve = $RefParser.resolve;\nexports.bundle = $RefParser.bundle;\nexports.dereference = $RefParser.dereference;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRDQUE0QyxHQUFHLHFDQUFxQyxHQUFHLDJCQUEyQixHQUFHLDRCQUE0QixHQUFHLHNCQUFzQixHQUFHLDRCQUE0QixHQUFHLG1CQUFtQixHQUFHLHFCQUFxQixHQUFHLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLHVCQUF1QixHQUFHLDhCQUE4QixHQUFHLG1CQUFtQixHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLGtCQUFrQjtBQUM1YyxrQ0FBa0MsbUJBQU8sQ0FBQywwSkFBVztBQUNyRCxtQ0FBbUMsbUJBQU8sQ0FBQyw0SkFBWTtBQUN2RCw0Q0FBNEMsbUJBQU8sQ0FBQyw4S0FBcUI7QUFDekUscUNBQXFDO0FBQ3JDLDhDQUE4QyxtQkFBTyxDQUFDLGtMQUF1QjtBQUM3RSxvQ0FBb0MsbUJBQU8sQ0FBQyw4SkFBYTtBQUN6RCx5Q0FBeUMsbUJBQU8sQ0FBQyx3S0FBa0I7QUFDbkUsMkJBQTJCO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLGtLQUFlO0FBQ2hELG9CQUFvQixtQkFBTyxDQUFDLHdLQUFrQjtBQUM5QyxtREFBa0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDakksdURBQXNELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3pJLHVEQUFzRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN6SSxpREFBZ0QsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDN0gsK0NBQThDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3pILHdEQUF1RCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUMzSSwwREFBeUQsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDL0ksa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9ILHdEQUF1RCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUMzSSxjQUFjLG1CQUFPLENBQUMsbUhBQWlCO0FBQ3ZDLG1DQUFtQyxtQkFBTyxDQUFDLHNLQUFpQjtBQUM1RCxxQkFBcUIsbUJBQU8sQ0FBQyxnS0FBYztBQUMzQyx3RUFBdUUsRUFBRSxxQ0FBcUMsNkRBQTZELEVBQUM7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRix5QkFBeUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQixJQUFJLGdCQUFnQixHQUFHLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9DQUFvQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGVBQWU7QUFDZixjQUFjO0FBQ2QsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVhLW9saXZlLXdlYi8uL25vZGVfbW9kdWxlcy8ucG5wbS9AYXBpZGV2dG9vbHMranNvbi1zY2hlbWEtcmVmLXBhcnNlckAxMS45LjMvbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL2luZGV4LmpzPzdmOWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0SnNvblNjaGVtYVJlZlBhcnNlckRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5qc29uU2NoZW1hUGFyc2VyTm9ybWFsaXplQXJncyA9IGV4cG9ydHMuZGVyZWZlcmVuY2VJbnRlcm5hbCA9IGV4cG9ydHMuSlNPTlBhcnNlckVycm9yR3JvdXAgPSBleHBvcnRzLmlzSGFuZGxlZEVycm9yID0gZXhwb3J0cy5Vbm1hdGNoZWRQYXJzZXJFcnJvciA9IGV4cG9ydHMuUGFyc2VyRXJyb3IgPSBleHBvcnRzLlJlc29sdmVyRXJyb3IgPSBleHBvcnRzLk1pc3NpbmdQb2ludGVyRXJyb3IgPSBleHBvcnRzLkludmFsaWRQb2ludGVyRXJyb3IgPSBleHBvcnRzLkpTT05QYXJzZXJFcnJvciA9IGV4cG9ydHMuVW5tYXRjaGVkUmVzb2x2ZXJFcnJvciA9IGV4cG9ydHMuZGVyZWZlcmVuY2UgPSBleHBvcnRzLmJ1bmRsZSA9IGV4cG9ydHMucmVzb2x2ZSA9IGV4cG9ydHMucGFyc2UgPSBleHBvcnRzLiRSZWZQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCByZWZzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVmcy5qc1wiKSk7XG5jb25zdCBwYXJzZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcbmNvbnN0IG5vcm1hbGl6ZV9hcmdzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbm9ybWFsaXplLWFyZ3MuanNcIikpO1xuZXhwb3J0cy5qc29uU2NoZW1hUGFyc2VyTm9ybWFsaXplQXJncyA9IG5vcm1hbGl6ZV9hcmdzX2pzXzEuZGVmYXVsdDtcbmNvbnN0IHJlc29sdmVfZXh0ZXJuYWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZXNvbHZlLWV4dGVybmFsLmpzXCIpKTtcbmNvbnN0IGJ1bmRsZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2J1bmRsZS5qc1wiKSk7XG5jb25zdCBkZXJlZmVyZW5jZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2RlcmVmZXJlbmNlLmpzXCIpKTtcbmV4cG9ydHMuZGVyZWZlcmVuY2VJbnRlcm5hbCA9IGRlcmVmZXJlbmNlX2pzXzEuZGVmYXVsdDtcbmNvbnN0IHVybCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvZXJyb3JzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSlNPTlBhcnNlckVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5KU09OUGFyc2VyRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnZhbGlkUG9pbnRlckVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5JbnZhbGlkUG9pbnRlckVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWlzc2luZ1BvaW50ZXJFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuTWlzc2luZ1BvaW50ZXJFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc29sdmVyRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLlJlc29sdmVyRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJzZXJFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuUGFyc2VyRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbm1hdGNoZWRQYXJzZXJFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuVW5tYXRjaGVkUGFyc2VyRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbm1hdGNoZWRSZXNvbHZlckVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5Vbm1hdGNoZWRSZXNvbHZlckVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIYW5kbGVkRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLmlzSGFuZGxlZEVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSlNPTlBhcnNlckVycm9yR3JvdXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLkpTT05QYXJzZXJFcnJvckdyb3VwOyB9IH0pO1xuY29uc3Qgb25vXzEgPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3QgbWF5YmVfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL21heWJlLmpzXCIpKTtcbmNvbnN0IG9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuL29wdGlvbnMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRKc29uU2NoZW1hUmVmUGFyc2VyRGVmYXVsdE9wdGlvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wdGlvbnNfanNfMS5nZXRKc29uU2NoZW1hUmVmUGFyc2VyRGVmYXVsdE9wdGlvbnM7IH0gfSk7XG4vKipcbiAqIFRoaXMgY2xhc3MgcGFyc2VzIGEgSlNPTiBzY2hlbWEsIGJ1aWxkcyBhIG1hcCBvZiBpdHMgSlNPTiByZWZlcmVuY2VzIGFuZCB0aGVpciByZXNvbHZlZCB2YWx1ZXMsXG4gKiBhbmQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgdHJhdmVyc2luZywgbWFuaXB1bGF0aW5nLCBhbmQgZGVyZWZlcmVuY2luZyB0aG9zZSByZWZlcmVuY2VzLlxuICpcbiAqIEBjbGFzc1xuICovXG5jbGFzcyAkUmVmUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJzZWQgKGFuZCBwb3NzaWJseSBkZXJlZmVyZW5jZWQpIEpTT04gc2NoZW1hIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NoZW1hID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXNvbHZlZCBKU09OIHJlZmVyZW5jZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgeyRSZWZzfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJHJlZnMgPSBuZXcgcmVmc19qc18xLmRlZmF1bHQoKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSAoMCwgbm9ybWFsaXplX2FyZ3NfanNfMS5kZWZhdWx0KShhcmd1bWVudHMpO1xuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgaWYgKCFhcmdzLnBhdGggJiYgIWFyZ3Muc2NoZW1hKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSAoMCwgb25vXzEub25vKShgRXhwZWN0ZWQgYSBmaWxlIHBhdGgsIFVSTCwgb3Igb2JqZWN0LiBHb3QgJHthcmdzLnBhdGggfHwgYXJncy5zY2hlbWF9YCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIG1heWJlX2pzXzEuZGVmYXVsdCkoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgZXZlcnl0aGluZ1xuICAgICAgICB0aGlzLnNjaGVtYSA9IG51bGw7XG4gICAgICAgIHRoaXMuJHJlZnMgPSBuZXcgcmVmc19qc18xLmRlZmF1bHQoKTtcbiAgICAgICAgLy8gSWYgdGhlIHBhdGggaXMgYSBmaWxlc3lzdGVtIHBhdGgsIHRoZW4gY29udmVydCBpdCB0byBhIFVSTC5cbiAgICAgICAgLy8gTk9URTogQWNjb3JkaW5nIHRvIHRoZSBKU09OIFJlZmVyZW5jZSBzcGVjLCB0aGVzZSBzaG91bGQgYWxyZWFkeSBiZSBVUkxzLFxuICAgICAgICAvLyBidXQsIGluIHByYWN0aWNlLCBtYW55IHBlb3BsZSB1c2UgbG9jYWwgZmlsZXN5c3RlbSBwYXRocyBpbnN0ZWFkLlxuICAgICAgICAvLyBTbyB3ZSdyZSBiZWluZyBnZW5lcm91cyBoZXJlIGFuZCBkb2luZyB0aGUgY29udmVyc2lvbiBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAvLyBUaGlzIGlzIG5vdCBpbnRlbmRlZCB0byBiZSBhIDEwMCUgYnVsbGV0cHJvb2Ygc29sdXRpb24uXG4gICAgICAgIC8vIElmIGl0IGRvZXNuJ3Qgd29yayBmb3IgeW91ciB1c2UtY2FzZSwgdGhlbiB1c2UgYSBVUkwgaW5zdGVhZC5cbiAgICAgICAgbGV0IHBhdGhUeXBlID0gXCJodHRwXCI7XG4gICAgICAgIGlmICh1cmwuaXNGaWxlU3lzdGVtUGF0aChhcmdzLnBhdGgpKSB7XG4gICAgICAgICAgICBhcmdzLnBhdGggPSB1cmwuZnJvbUZpbGVTeXN0ZW1QYXRoKGFyZ3MucGF0aCk7XG4gICAgICAgICAgICBwYXRoVHlwZSA9IFwiZmlsZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhcmdzLnBhdGggJiYgYXJncy5zY2hlbWEgJiYgXCIkaWRcIiBpbiBhcmdzLnNjaGVtYSAmJiBhcmdzLnNjaGVtYS4kaWQpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gc2NoZW1hIGlkIGhhcyBkZWZpbmVkIGFuIFVSTCBzaG91bGQgdXNlIHRoYXQgaG9zdG5hbWUgdG8gcmVxdWVzdCB0aGUgcmVmZXJlbmNlcyxcbiAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgdGhlIGN1cnJlbnQgcGFnZSBVUkxcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHVybC5wYXJzZShhcmdzLnNjaGVtYS4kaWQpO1xuICAgICAgICAgICAgY29uc3QgcG9ydCA9IHBhcmFtcy5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IDQ0MyA6IDgwO1xuICAgICAgICAgICAgYXJncy5wYXRoID0gYCR7cGFyYW1zLnByb3RvY29sfS8vJHtwYXJhbXMuaG9zdG5hbWV9OiR7cG9ydH1gO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIGFic29sdXRlIHBhdGggb2YgdGhlIHNjaGVtYVxuICAgICAgICBhcmdzLnBhdGggPSB1cmwucmVzb2x2ZSh1cmwuY3dkKCksIGFyZ3MucGF0aCk7XG4gICAgICAgIGlmIChhcmdzLnNjaGVtYSAmJiB0eXBlb2YgYXJncy5zY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIEEgc2NoZW1hIG9iamVjdCB3YXMgcGFzc2VkLWluLlxuICAgICAgICAgICAgLy8gU28gaW1tZWRpYXRlbHkgYWRkIGEgbmV3ICRSZWYgd2l0aCB0aGUgc2NoZW1hIG9iamVjdCBhcyBpdHMgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0ICRyZWYgPSB0aGlzLiRyZWZzLl9hZGQoYXJncy5wYXRoKTtcbiAgICAgICAgICAgICRyZWYudmFsdWUgPSBhcmdzLnNjaGVtYTtcbiAgICAgICAgICAgICRyZWYucGF0aFR5cGUgPSBwYXRoVHlwZTtcbiAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYXJncy5zY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIHNjaGVtYSBmaWxlL3VybFxuICAgICAgICAgICAgcHJvbWlzZSA9ICgwLCBwYXJzZV9qc18xLmRlZmF1bHQpKGFyZ3MucGF0aCwgdGhpcy4kcmVmcywgYXJncy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiAhQnVmZmVyLmlzQnVmZmVyKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIG1heWJlX2pzXzEuZGVmYXVsdCkoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2NoZW1hKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmdzLm9wdGlvbnMuY29udGludWVPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSBudWxsOyAvLyBpdCdzIGFscmVhZHkgc2V0IHRvIG51bGwgYXQgbGluZSA3OSwgYnV0IGxldCdzIHNldCBpdCBhZ2FpbiBmb3IgdGhlIHNha2Ugb2YgcmVhZGFiaWxpdHlcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIG1heWJlX2pzXzEuZGVmYXVsdCkoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2NoZW1hKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBvbm9fMS5vbm8uc3ludGF4KGBcIiR7dGhpcy4kcmVmcy5fcm9vdCRSZWYucGF0aCB8fCByZXN1bHR9XCIgaXMgbm90IGEgdmFsaWQgSlNPTiBTY2hlbWFgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3Mub3B0aW9ucy5jb250aW51ZU9uRXJyb3IgfHwgISgwLCBlcnJvcnNfanNfMS5pc0hhbmRsZWRFcnJvcikoZXJyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlamVjdChlcnIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRyZWZzLl8kcmVmc1t1cmwuc3RyaXBIYXNoKGFyZ3MucGF0aCldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVmcy5fJHJlZnNbdXJsLnN0cmlwSGFzaChhcmdzLnBhdGgpXS5hZGRFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBtYXliZV9qc18xLmRlZmF1bHQpKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVzb2x2ZShudWxsKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKCkge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgJFJlZlBhcnNlcigpO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlLmFwcGx5KHBhcnNlciwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZSgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9ICgwLCBub3JtYWxpemVfYXJnc19qc18xLmRlZmF1bHQpKGFyZ3VtZW50cyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBhcnNlKGFyZ3MucGF0aCwgYXJncy5zY2hlbWEsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICAgICAgICBhd2FpdCAoMCwgcmVzb2x2ZV9leHRlcm5hbF9qc18xLmRlZmF1bHQpKHRoaXMsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICAgICAgICBmaW5hbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUodGhpcy4kcmVmcykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlamVjdChlcnIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcmVzb2x2ZSgpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgJFJlZlBhcnNlcigpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVzb2x2ZS5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgc3RhdGljIGJ1bmRsZSgpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgJFJlZlBhcnNlcigpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UuYnVuZGxlLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBhc3luYyBidW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSAoMCwgbm9ybWFsaXplX2FyZ3NfanNfMS5kZWZhdWx0KShhcmd1bWVudHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXNvbHZlKGFyZ3MucGF0aCwgYXJncy5zY2hlbWEsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICAgICAgICAoMCwgYnVuZGxlX2pzXzEuZGVmYXVsdCkodGhpcywgYXJncy5vcHRpb25zKTtcbiAgICAgICAgICAgIGZpbmFsaXplKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBtYXliZV9qc18xLmRlZmF1bHQpKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVzb2x2ZSh0aGlzLnNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlamVjdChlcnIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZGVyZWZlcmVuY2UoKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3ICRSZWZQYXJzZXIoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmRlcmVmZXJlbmNlLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBhc3luYyBkZXJlZmVyZW5jZSgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9ICgwLCBub3JtYWxpemVfYXJnc19qc18xLmRlZmF1bHQpKGFyZ3VtZW50cyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc29sdmUoYXJncy5wYXRoLCBhcmdzLnNjaGVtYSwgYXJncy5vcHRpb25zKTtcbiAgICAgICAgICAgICgwLCBkZXJlZmVyZW5jZV9qc18xLmRlZmF1bHQpKHRoaXMsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICAgICAgICBmaW5hbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUodGhpcy5zY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIG1heWJlX2pzXzEuZGVmYXVsdCkoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLiRSZWZQYXJzZXIgPSAkUmVmUGFyc2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gJFJlZlBhcnNlcjtcbmZ1bmN0aW9uIGZpbmFsaXplKHBhcnNlcikge1xuICAgIGNvbnN0IGVycm9ycyA9IGVycm9yc19qc18xLkpTT05QYXJzZXJFcnJvckdyb3VwLmdldFBhcnNlckVycm9ycyhwYXJzZXIpO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuSlNPTlBhcnNlckVycm9yR3JvdXAocGFyc2VyKTtcbiAgICB9XG59XG5leHBvcnRzLnBhcnNlID0gJFJlZlBhcnNlci5wYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9ICRSZWZQYXJzZXIucmVzb2x2ZTtcbmV4cG9ydHMuYnVuZGxlID0gJFJlZlBhcnNlci5idW5kbGU7XG5leHBvcnRzLmRlcmVmZXJlbmNlID0gJFJlZlBhcnNlci5kZXJlZmVyZW5jZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalizeArgs = normalizeArgs;\nconst options_js_1 = __webpack_require__(/*! ./options.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js\");\n/**\n * Normalizes the given arguments, accounting for optional args.\n */\nfunction normalizeArgs(_args) {\n    let path;\n    let schema;\n    let options;\n    let callback;\n    const args = Array.prototype.slice.call(_args);\n    if (typeof args[args.length - 1] === \"function\") {\n        // The last parameter is a callback function\n        callback = args.pop();\n    }\n    if (typeof args[0] === \"string\") {\n        // The first parameter is the path\n        path = args[0];\n        if (typeof args[2] === \"object\") {\n            // The second parameter is the schema, and the third parameter is the options\n            schema = args[1];\n            options = args[2];\n        }\n        else {\n            // The second parameter is the options\n            schema = undefined;\n            options = args[1];\n        }\n    }\n    else {\n        // The first parameter is the schema\n        path = \"\";\n        schema = args[0];\n        options = args[1];\n    }\n    try {\n        options = (0, options_js_1.getNewOptions)(options);\n    }\n    catch (e) {\n        console.error(`JSON Schema Ref Parser: Error normalizing options: ${e}`);\n    }\n    if (!options.mutateInputSchema && typeof schema === \"object\") {\n        // Make a deep clone of the schema, so that we don't alter the original object\n        schema = JSON.parse(JSON.stringify(schema));\n    }\n    return {\n        path,\n        schema,\n        options,\n        callback,\n    };\n}\nexports[\"default\"] = normalizeArgs;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9ub3JtYWxpemUtYXJncy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIscUJBQXFCLG1CQUFPLENBQUMsZ0tBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsRUFBRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlYS1vbGl2ZS13ZWIvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9ub3JtYWxpemUtYXJncy5qcz9hMWM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3JtYWxpemVBcmdzID0gbm9ybWFsaXplQXJncztcbmNvbnN0IG9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuL29wdGlvbnMuanNcIik7XG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIGFyZ3VtZW50cywgYWNjb3VudGluZyBmb3Igb3B0aW9uYWwgYXJncy5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQXJncyhfYXJncykge1xuICAgIGxldCBwYXRoO1xuICAgIGxldCBzY2hlbWE7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgbGV0IGNhbGxiYWNrO1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChfYXJncyk7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBUaGUgbGFzdCBwYXJhbWV0ZXIgaXMgYSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSBwYXRoXG4gICAgICAgIHBhdGggPSBhcmdzWzBdO1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBzY2hlbWEsIGFuZCB0aGUgdGhpcmQgcGFyYW1ldGVyIGlzIHRoZSBvcHRpb25zXG4gICAgICAgICAgICBzY2hlbWEgPSBhcmdzWzFdO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZ3NbMl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyB0aGUgb3B0aW9uc1xuICAgICAgICAgICAgc2NoZW1hID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHNjaGVtYVxuICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgc2NoZW1hID0gYXJnc1swXTtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIG9wdGlvbnMgPSAoMCwgb3B0aW9uc19qc18xLmdldE5ld09wdGlvbnMpKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBKU09OIFNjaGVtYSBSZWYgUGFyc2VyOiBFcnJvciBub3JtYWxpemluZyBvcHRpb25zOiAke2V9YCk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5tdXRhdGVJbnB1dFNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIE1ha2UgYSBkZWVwIGNsb25lIG9mIHRoZSBzY2hlbWEsIHNvIHRoYXQgd2UgZG9uJ3QgYWx0ZXIgdGhlIG9yaWdpbmFsIG9iamVjdFxuICAgICAgICBzY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNjaGVtYSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGNhbGxiYWNrLFxuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBub3JtYWxpemVBcmdzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js ***!
  \********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getNewOptions = exports.getJsonSchemaRefParserDefaultOptions = void 0;\nconst json_js_1 = __importDefault(__webpack_require__(/*! ./parsers/json.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js\"));\nconst yaml_js_1 = __importDefault(__webpack_require__(/*! ./parsers/yaml.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js\"));\nconst text_js_1 = __importDefault(__webpack_require__(/*! ./parsers/text.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js\"));\nconst binary_js_1 = __importDefault(__webpack_require__(/*! ./parsers/binary.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js\"));\nconst file_js_1 = __importDefault(__webpack_require__(/*! ./resolvers/file.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js\"));\nconst http_js_1 = __importDefault(__webpack_require__(/*! ./resolvers/http.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js\"));\nconst getJsonSchemaRefParserDefaultOptions = () => {\n    const defaults = {\n        /**\n         * Determines how different types of files will be parsed.\n         *\n         * You can add additional parsers of your own, replace an existing one with\n         * your own implementation, or disable any parser by setting it to false.\n         */\n        parse: {\n            json: { ...json_js_1.default },\n            yaml: { ...yaml_js_1.default },\n            text: { ...text_js_1.default },\n            binary: { ...binary_js_1.default },\n        },\n        /**\n         * Determines how JSON References will be resolved.\n         *\n         * You can add additional resolvers of your own, replace an existing one with\n         * your own implementation, or disable any resolver by setting it to false.\n         */\n        resolve: {\n            file: { ...file_js_1.default },\n            http: { ...http_js_1.default },\n            /**\n             * Determines whether external $ref pointers will be resolved.\n             * If this option is disabled, then none of above resolvers will be called.\n             * Instead, external $ref pointers will simply be ignored.\n             *\n             * @type {boolean}\n             */\n            external: true,\n        },\n        /**\n         * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`\n         * causes it to keep processing as much as possible and then throw a single error that contains all errors\n         * that were encountered.\n         */\n        continueOnError: false,\n        /**\n         * Determines the types of JSON references that are allowed.\n         */\n        dereference: {\n            /**\n             * Dereference circular (recursive) JSON references?\n             * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.\n             * If \"ignore\", then circular references will not be dereferenced.\n             *\n             * @type {boolean|string}\n             */\n            circular: true,\n            /**\n             * A function, called for each path, which can return true to stop this path and all\n             * subpaths from being dereferenced further. This is useful in schemas where some\n             * subpaths contain literal $ref keys that should not be dereferenced.\n             *\n             * @type {function}\n             */\n            excludedPathMatcher: () => false,\n            referenceResolution: \"relative\",\n        },\n        mutateInputSchema: true,\n    };\n    return defaults;\n};\nexports.getJsonSchemaRefParserDefaultOptions = getJsonSchemaRefParserDefaultOptions;\nconst getNewOptions = (options) => {\n    const newOptions = (0, exports.getJsonSchemaRefParserDefaultOptions)();\n    if (options) {\n        merge(newOptions, options);\n    }\n    return newOptions;\n};\nexports.getNewOptions = getNewOptions;\n/**\n * Merges the properties of the source object into the target object.\n *\n * @param target - The object that we're populating\n * @param source - The options that are being merged\n * @returns\n */\nfunction merge(target, source) {\n    if (isMergeable(source)) {\n        // prevent prototype pollution\n        const keys = Object.keys(source).filter((key) => ![\"__proto__\", \"constructor\", \"prototype\"].includes(key));\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const sourceSetting = source[key];\n            const targetSetting = target[key];\n            if (isMergeable(sourceSetting)) {\n                // It's a nested object, so merge it recursively\n                target[key] = merge(targetSetting || {}, sourceSetting);\n            }\n            else if (sourceSetting !== undefined) {\n                // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.\n                target[key] = sourceSetting;\n            }\n        }\n    }\n    return target;\n}\n/**\n * Determines whether the given value can be merged,\n * or if it is a scalar value that should just override the target value.\n *\n * @param val\n * @returns\n */\nfunction isMergeable(val) {\n    return val && typeof val === \"object\" && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsNENBQTRDO0FBQ3BFLGtDQUFrQyxtQkFBTyxDQUFDLDBLQUFtQjtBQUM3RCxrQ0FBa0MsbUJBQU8sQ0FBQywwS0FBbUI7QUFDN0Qsa0NBQWtDLG1CQUFPLENBQUMsMEtBQW1CO0FBQzdELG9DQUFvQyxtQkFBTyxDQUFDLDhLQUFxQjtBQUNqRSxrQ0FBa0MsbUJBQU8sQ0FBQyw4S0FBcUI7QUFDL0Qsa0NBQWtDLG1CQUFPLENBQUMsOEtBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUMsb0JBQW9CLHNCQUFzQjtBQUMxQyxvQkFBb0Isc0JBQXNCO0FBQzFDLHNCQUFzQix3QkFBd0I7QUFDOUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQyxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0JBQXNCO0FBQ3ZEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWEtb2xpdmUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhcGlkZXZ0b29scytqc29uLXNjaGVtYS1yZWYtcGFyc2VyQDExLjkuMy9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvb3B0aW9ucy5qcz8yNzU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXROZXdPcHRpb25zID0gZXhwb3J0cy5nZXRKc29uU2NoZW1hUmVmUGFyc2VyRGVmYXVsdE9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBqc29uX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFyc2Vycy9qc29uLmpzXCIpKTtcbmNvbnN0IHlhbWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZXJzL3lhbWwuanNcIikpO1xuY29uc3QgdGV4dF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlcnMvdGV4dC5qc1wiKSk7XG5jb25zdCBiaW5hcnlfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZXJzL2JpbmFyeS5qc1wiKSk7XG5jb25zdCBmaWxlX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVzb2x2ZXJzL2ZpbGUuanNcIikpO1xuY29uc3QgaHR0cF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc29sdmVycy9odHRwLmpzXCIpKTtcbmNvbnN0IGdldEpzb25TY2hlbWFSZWZQYXJzZXJEZWZhdWx0T3B0aW9ucyA9ICgpID0+IHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaG93IGRpZmZlcmVudCB0eXBlcyBvZiBmaWxlcyB3aWxsIGJlIHBhcnNlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhZGQgYWRkaXRpb25hbCBwYXJzZXJzIG9mIHlvdXIgb3duLCByZXBsYWNlIGFuIGV4aXN0aW5nIG9uZSB3aXRoXG4gICAgICAgICAqIHlvdXIgb3duIGltcGxlbWVudGF0aW9uLCBvciBkaXNhYmxlIGFueSBwYXJzZXIgYnkgc2V0dGluZyBpdCB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlOiB7XG4gICAgICAgICAgICBqc29uOiB7IC4uLmpzb25fanNfMS5kZWZhdWx0IH0sXG4gICAgICAgICAgICB5YW1sOiB7IC4uLnlhbWxfanNfMS5kZWZhdWx0IH0sXG4gICAgICAgICAgICB0ZXh0OiB7IC4uLnRleHRfanNfMS5kZWZhdWx0IH0sXG4gICAgICAgICAgICBiaW5hcnk6IHsgLi4uYmluYXJ5X2pzXzEuZGVmYXVsdCB9LFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBob3cgSlNPTiBSZWZlcmVuY2VzIHdpbGwgYmUgcmVzb2x2ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gYWRkIGFkZGl0aW9uYWwgcmVzb2x2ZXJzIG9mIHlvdXIgb3duLCByZXBsYWNlIGFuIGV4aXN0aW5nIG9uZSB3aXRoXG4gICAgICAgICAqIHlvdXIgb3duIGltcGxlbWVudGF0aW9uLCBvciBkaXNhYmxlIGFueSByZXNvbHZlciBieSBzZXR0aW5nIGl0IHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzb2x2ZToge1xuICAgICAgICAgICAgZmlsZTogeyAuLi5maWxlX2pzXzEuZGVmYXVsdCB9LFxuICAgICAgICAgICAgaHR0cDogeyAuLi5odHRwX2pzXzEuZGVmYXVsdCB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgZXh0ZXJuYWwgJHJlZiBwb2ludGVycyB3aWxsIGJlIHJlc29sdmVkLlxuICAgICAgICAgICAgICogSWYgdGhpcyBvcHRpb24gaXMgZGlzYWJsZWQsIHRoZW4gbm9uZSBvZiBhYm92ZSByZXNvbHZlcnMgd2lsbCBiZSBjYWxsZWQuXG4gICAgICAgICAgICAgKiBJbnN0ZWFkLCBleHRlcm5hbCAkcmVmIHBvaW50ZXJzIHdpbGwgc2ltcGx5IGJlIGlnbm9yZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGV4dGVybmFsOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQnkgZGVmYXVsdCwgSlNPTiBTY2hlbWEgJFJlZiBQYXJzZXIgdGhyb3dzIHRoZSBmaXJzdCBlcnJvciBpdCBlbmNvdW50ZXJzLiBTZXR0aW5nIGBjb250aW51ZU9uRXJyb3JgIHRvIGB0cnVlYFxuICAgICAgICAgKiBjYXVzZXMgaXQgdG8ga2VlcCBwcm9jZXNzaW5nIGFzIG11Y2ggYXMgcG9zc2libGUgYW5kIHRoZW4gdGhyb3cgYSBzaW5nbGUgZXJyb3IgdGhhdCBjb250YWlucyBhbGwgZXJyb3JzXG4gICAgICAgICAqIHRoYXQgd2VyZSBlbmNvdW50ZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRpbnVlT25FcnJvcjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSB0eXBlcyBvZiBKU09OIHJlZmVyZW5jZXMgdGhhdCBhcmUgYWxsb3dlZC5cbiAgICAgICAgICovXG4gICAgICAgIGRlcmVmZXJlbmNlOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlcmVmZXJlbmNlIGNpcmN1bGFyIChyZWN1cnNpdmUpIEpTT04gcmVmZXJlbmNlcz9cbiAgICAgICAgICAgICAqIElmIGZhbHNlLCB0aGVuIGEge0BsaW5rIFJlZmVyZW5jZUVycm9yfSB3aWxsIGJlIHRocm93biBpZiBhIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyBmb3VuZC5cbiAgICAgICAgICAgICAqIElmIFwiaWdub3JlXCIsIHRoZW4gY2lyY3VsYXIgcmVmZXJlbmNlcyB3aWxsIG5vdCBiZSBkZXJlZmVyZW5jZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiwgY2FsbGVkIGZvciBlYWNoIHBhdGgsIHdoaWNoIGNhbiByZXR1cm4gdHJ1ZSB0byBzdG9wIHRoaXMgcGF0aCBhbmQgYWxsXG4gICAgICAgICAgICAgKiBzdWJwYXRocyBmcm9tIGJlaW5nIGRlcmVmZXJlbmNlZCBmdXJ0aGVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBzY2hlbWFzIHdoZXJlIHNvbWVcbiAgICAgICAgICAgICAqIHN1YnBhdGhzIGNvbnRhaW4gbGl0ZXJhbCAkcmVmIGtleXMgdGhhdCBzaG91bGQgbm90IGJlIGRlcmVmZXJlbmNlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGV4Y2x1ZGVkUGF0aE1hdGNoZXI6ICgpID0+IGZhbHNlLFxuICAgICAgICAgICAgcmVmZXJlbmNlUmVzb2x1dGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICB9LFxuICAgICAgICBtdXRhdGVJbnB1dFNjaGVtYTogdHJ1ZSxcbiAgICB9O1xuICAgIHJldHVybiBkZWZhdWx0cztcbn07XG5leHBvcnRzLmdldEpzb25TY2hlbWFSZWZQYXJzZXJEZWZhdWx0T3B0aW9ucyA9IGdldEpzb25TY2hlbWFSZWZQYXJzZXJEZWZhdWx0T3B0aW9ucztcbmNvbnN0IGdldE5ld09wdGlvbnMgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSAoMCwgZXhwb3J0cy5nZXRKc29uU2NoZW1hUmVmUGFyc2VyRGVmYXVsdE9wdGlvbnMpKCk7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2UobmV3T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdPcHRpb25zO1xufTtcbmV4cG9ydHMuZ2V0TmV3T3B0aW9ucyA9IGdldE5ld09wdGlvbnM7XG4vKipcbiAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgb2JqZWN0IHRoYXQgd2UncmUgcG9wdWxhdGluZ1xuICogQHBhcmFtIHNvdXJjZSAtIFRoZSBvcHRpb25zIHRoYXQgYXJlIGJlaW5nIG1lcmdlZFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAoaXNNZXJnZWFibGUoc291cmNlKSkge1xuICAgICAgICAvLyBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSkuZmlsdGVyKChrZXkpID0+ICFbXCJfX3Byb3RvX19cIiwgXCJjb25zdHJ1Y3RvclwiLCBcInByb3RvdHlwZVwiXS5pbmNsdWRlcyhrZXkpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlU2V0dGluZyA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0U2V0dGluZyA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgaWYgKGlzTWVyZ2VhYmxlKHNvdXJjZVNldHRpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIG5lc3RlZCBvYmplY3QsIHNvIG1lcmdlIGl0IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZSh0YXJnZXRTZXR0aW5nIHx8IHt9LCBzb3VyY2VTZXR0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVNldHRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEl0J3MgYSBzY2FsYXIgdmFsdWUsIGZ1bmN0aW9uLCBvciBhcnJheS4gTm8gbWVyZ2luZyBuZWNlc3NhcnkuIEp1c3Qgb3ZlcndyaXRlIHRoZSB0YXJnZXQgdmFsdWUuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2VTZXR0aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY2FuIGJlIG1lcmdlZCxcbiAqIG9yIGlmIGl0IGlzIGEgc2NhbGFyIHZhbHVlIHRoYXQgc2hvdWxkIGp1c3Qgb3ZlcnJpZGUgdGhlIHRhcmdldCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gdmFsXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc01lcmdlYWJsZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsKSAmJiAhKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgISh2YWwgaW5zdGFuY2VvZiBEYXRlKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js ***!
  \******************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst plugins = __importStar(__webpack_require__(/*! ./util/plugins.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\n/**\n * Reads and parses the specified file path or URL.\n */\nasync function parse(path, $refs, options) {\n    // Remove the URL fragment, if any\n    const hashIndex = path.indexOf(\"#\");\n    let hash = \"\";\n    if (hashIndex >= 0) {\n        hash = path.substring(hashIndex);\n        // Remove the URL fragment, if any\n        path = path.substring(0, hashIndex);\n    }\n    // Add a new $Ref for this file, even though we don't have the value yet.\n    // This ensures that we don't simultaneously read & parse the same file multiple times\n    const $ref = $refs._add(path);\n    // This \"file object\" will be passed to all resolvers and parsers.\n    const file = {\n        url: path,\n        hash,\n        extension: url.getExtension(path),\n    };\n    // Read the file and then parse the data\n    try {\n        const resolver = await readFile(file, options, $refs);\n        $ref.pathType = resolver.plugin.name;\n        file.data = resolver.result;\n        const parser = await parseFile(file, options, $refs);\n        $ref.value = parser.result;\n        return parser.result;\n    }\n    catch (err) {\n        if ((0, errors_js_1.isHandledError)(err)) {\n            $ref.value = err;\n        }\n        throw err;\n    }\n}\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param file           - An object containing information about the referenced file\n * @param file.url       - The full URL of the referenced file\n * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param options\n * @param $refs\n * @returns\n * The promise resolves with the raw file contents and the resolver that was used.\n */\nasync function readFile(file, options, $refs) {\n    // console.log('Reading %s', file.url);\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file);\n    // Run the resolvers, in order, until one of them succeeds\n    plugins.sort(resolvers);\n    try {\n        const data = await plugins.run(resolvers, \"read\", file, $refs);\n        return data;\n    }\n    catch (err) {\n        if (!err && options.continueOnError) {\n            // No resolver could be matched\n            throw new errors_js_1.UnmatchedResolverError(file.url);\n        }\n        else if (!err || !(\"error\" in err)) {\n            // Throw a generic, friendly error.\n            throw ono_1.ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`);\n        }\n        // Throw the original error, if it's one of our own (user-friendly) errors.\n        else if (err.error instanceof errors_js_1.ResolverError) {\n            throw err.error;\n        }\n        else {\n            throw new errors_js_1.ResolverError(err, file.url);\n        }\n    }\n}\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param file           - An object containing information about the referenced file\n * @param file.url       - The full URL of the referenced file\n * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param options\n * @param $refs\n *\n * @returns\n * The promise resolves with the parsed file contents and the parser that was used.\n */\nasync function parseFile(file, options, $refs) {\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    const allParsers = plugins.all(options.parse);\n    const filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    const parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;\n    // Run the parsers, in order, until one of them succeeds\n    plugins.sort(parsers);\n    try {\n        const parser = await plugins.run(parsers, \"parse\", file, $refs);\n        if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n            throw ono_1.ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`);\n        }\n        else {\n            return parser;\n        }\n    }\n    catch (err) {\n        if (!err && options.continueOnError) {\n            // No resolver could be matched\n            throw new errors_js_1.UnmatchedParserError(file.url);\n        }\n        else if (err && err.message && err.message.startsWith(\"Error parsing\")) {\n            throw err;\n        }\n        else if (!err || !(\"error\" in err)) {\n            throw ono_1.ono.syntax(`Unable to parse ${file.url}`);\n        }\n        else if (err.error instanceof errors_js_1.ParserError) {\n            throw err.error;\n        }\n        else {\n            throw new errors_js_1.ParserError(err.error.message, file.url);\n        }\n    }\n}\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param value\n * @returns\n */\nfunction isEmpty(value) {\n    return (value === undefined ||\n        (typeof value === \"object\" && Object.keys(value).length === 0) ||\n        (typeof value === \"string\" && value.trim().length === 0) ||\n        (Buffer.isBuffer(value) && value.length === 0));\n}\nexports[\"default\"] = parse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLG1CQUFPLENBQUMsbUhBQWlCO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLGtLQUFlO0FBQ2hELDZCQUE2QixtQkFBTyxDQUFDLDBLQUFtQjtBQUN4RCxvQkFBb0IsbUJBQU8sQ0FBQyx3S0FBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFNBQVM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTLE9BQU8sbUJBQW1CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlYS1vbGl2ZS13ZWIvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wYXJzZS5qcz9lYTkyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBvbm9fMSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCB1cmwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbC91cmwuanNcIikpO1xuY29uc3QgcGx1Z2lucyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3BsdWdpbnMuanNcIikpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlsL2Vycm9ycy5qc1wiKTtcbi8qKlxuICogUmVhZHMgYW5kIHBhcnNlcyB0aGUgc3BlY2lmaWVkIGZpbGUgcGF0aCBvciBVUkwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlKHBhdGgsICRyZWZzLCBvcHRpb25zKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBVUkwgZnJhZ21lbnQsIGlmIGFueVxuICAgIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgbGV0IGhhc2ggPSBcIlwiO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgICBoYXNoID0gcGF0aC5zdWJzdHJpbmcoaGFzaEluZGV4KTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBVUkwgZnJhZ21lbnQsIGlmIGFueVxuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgaGFzaEluZGV4KTtcbiAgICB9XG4gICAgLy8gQWRkIGEgbmV3ICRSZWYgZm9yIHRoaXMgZmlsZSwgZXZlbiB0aG91Z2ggd2UgZG9uJ3QgaGF2ZSB0aGUgdmFsdWUgeWV0LlxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IHNpbXVsdGFuZW91c2x5IHJlYWQgJiBwYXJzZSB0aGUgc2FtZSBmaWxlIG11bHRpcGxlIHRpbWVzXG4gICAgY29uc3QgJHJlZiA9ICRyZWZzLl9hZGQocGF0aCk7XG4gICAgLy8gVGhpcyBcImZpbGUgb2JqZWN0XCIgd2lsbCBiZSBwYXNzZWQgdG8gYWxsIHJlc29sdmVycyBhbmQgcGFyc2Vycy5cbiAgICBjb25zdCBmaWxlID0ge1xuICAgICAgICB1cmw6IHBhdGgsXG4gICAgICAgIGhhc2gsXG4gICAgICAgIGV4dGVuc2lvbjogdXJsLmdldEV4dGVuc2lvbihwYXRoKSxcbiAgICB9O1xuICAgIC8vIFJlYWQgdGhlIGZpbGUgYW5kIHRoZW4gcGFyc2UgdGhlIGRhdGFcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHJlYWRGaWxlKGZpbGUsIG9wdGlvbnMsICRyZWZzKTtcbiAgICAgICAgJHJlZi5wYXRoVHlwZSA9IHJlc29sdmVyLnBsdWdpbi5uYW1lO1xuICAgICAgICBmaWxlLmRhdGEgPSByZXNvbHZlci5yZXN1bHQ7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IGF3YWl0IHBhcnNlRmlsZShmaWxlLCBvcHRpb25zLCAkcmVmcyk7XG4gICAgICAgICRyZWYudmFsdWUgPSBwYXJzZXIucmVzdWx0O1xuICAgICAgICByZXR1cm4gcGFyc2VyLnJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoKDAsIGVycm9yc19qc18xLmlzSGFuZGxlZEVycm9yKShlcnIpKSB7XG4gICAgICAgICAgICAkcmVmLnZhbHVlID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG4vKipcbiAqIFJlYWRzIHRoZSBnaXZlbiBmaWxlLCB1c2luZyB0aGUgY29uZmlndXJlZCByZXNvbHZlciBwbHVnaW5zXG4gKlxuICogQHBhcmFtIGZpbGUgICAgICAgICAgIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICogQHBhcmFtIGZpbGUudXJsICAgICAgIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAqIEBwYXJhbSBmaWxlLmV4dGVuc2lvbiAtIFRoZSBsb3dlcmNhc2VkIGZpbGUgZXh0ZW5zaW9uIChlLmcuIFwiLnR4dFwiLCBcIi5odG1sXCIsIGV0Yy4pXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtICRyZWZzXG4gKiBAcmV0dXJuc1xuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgcmF3IGZpbGUgY29udGVudHMgYW5kIHRoZSByZXNvbHZlciB0aGF0IHdhcyB1c2VkLlxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkRmlsZShmaWxlLCBvcHRpb25zLCAkcmVmcykge1xuICAgIC8vIGNvbnNvbGUubG9nKCdSZWFkaW5nICVzJywgZmlsZS51cmwpO1xuICAgIC8vIEZpbmQgdGhlIHJlc29sdmVycyB0aGF0IGNhbiByZWFkIHRoaXMgZmlsZVxuICAgIGxldCByZXNvbHZlcnMgPSBwbHVnaW5zLmFsbChvcHRpb25zLnJlc29sdmUpO1xuICAgIHJlc29sdmVycyA9IHBsdWdpbnMuZmlsdGVyKHJlc29sdmVycywgXCJjYW5SZWFkXCIsIGZpbGUpO1xuICAgIC8vIFJ1biB0aGUgcmVzb2x2ZXJzLCBpbiBvcmRlciwgdW50aWwgb25lIG9mIHRoZW0gc3VjY2VlZHNcbiAgICBwbHVnaW5zLnNvcnQocmVzb2x2ZXJzKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcGx1Z2lucy5ydW4ocmVzb2x2ZXJzLCBcInJlYWRcIiwgZmlsZSwgJHJlZnMpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWVyciAmJiBvcHRpb25zLmNvbnRpbnVlT25FcnJvcikge1xuICAgICAgICAgICAgLy8gTm8gcmVzb2x2ZXIgY291bGQgYmUgbWF0Y2hlZFxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlVubWF0Y2hlZFJlc29sdmVyRXJyb3IoZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFlcnIgfHwgIShcImVycm9yXCIgaW4gZXJyKSkge1xuICAgICAgICAgICAgLy8gVGhyb3cgYSBnZW5lcmljLCBmcmllbmRseSBlcnJvci5cbiAgICAgICAgICAgIHRocm93IG9ub18xLm9uby5zeW50YXgoYFVuYWJsZSB0byByZXNvbHZlICRyZWYgcG9pbnRlciBcIiR7ZmlsZS51cmx9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IsIGlmIGl0J3Mgb25lIG9mIG91ciBvd24gKHVzZXItZnJpZW5kbHkpIGVycm9ycy5cbiAgICAgICAgZWxzZSBpZiAoZXJyLmVycm9yIGluc3RhbmNlb2YgZXJyb3JzX2pzXzEuUmVzb2x2ZXJFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlJlc29sdmVyRXJyb3IoZXJyLCBmaWxlLnVybCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gZmlsZSdzIGNvbnRlbnRzLCB1c2luZyB0aGUgY29uZmlndXJlZCBwYXJzZXIgcGx1Z2lucy5cbiAqXG4gKiBAcGFyYW0gZmlsZSAgICAgICAgICAgLSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVmZXJlbmNlZCBmaWxlXG4gKiBAcGFyYW0gZmlsZS51cmwgICAgICAgLSBUaGUgZnVsbCBVUkwgb2YgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICogQHBhcmFtIGZpbGUuZXh0ZW5zaW9uIC0gVGhlIGxvd2VyY2FzZWQgZmlsZSBleHRlbnNpb24gKGUuZy4gXCIudHh0XCIsIFwiLmh0bWxcIiwgZXRjLilcbiAqIEBwYXJhbSBmaWxlLmRhdGEgICAgICAtIFRoZSBmaWxlIGNvbnRlbnRzLiBUaGlzIHdpbGwgYmUgd2hhdGV2ZXIgZGF0YSB0eXBlIHdhcyByZXR1cm5lZCBieSB0aGUgcmVzb2x2ZXJcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gJHJlZnNcbiAqXG4gKiBAcmV0dXJuc1xuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgcGFyc2VkIGZpbGUgY29udGVudHMgYW5kIHRoZSBwYXJzZXIgdGhhdCB3YXMgdXNlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VGaWxlKGZpbGUsIG9wdGlvbnMsICRyZWZzKSB7XG4gICAgLy8gRmluZCB0aGUgcGFyc2VycyB0aGF0IGNhbiByZWFkIHRoaXMgZmlsZSB0eXBlLlxuICAgIC8vIElmIG5vbmUgb2YgdGhlIHBhcnNlcnMgYXJlIGFuIGV4YWN0IG1hdGNoIGZvciB0aGlzIGZpbGUsIHRoZW4gd2UnbGwgdHJ5IEFMTCBvZiB0aGVtLlxuICAgIC8vIFRoaXMgaGFuZGxlcyBzaXR1YXRpb25zIHdoZXJlIHRoZSBmaWxlIElTIGEgc3VwcG9ydGVkIHR5cGUsIGp1c3Qgd2l0aCBhbiB1bmtub3duIGV4dGVuc2lvbi5cbiAgICBjb25zdCBhbGxQYXJzZXJzID0gcGx1Z2lucy5hbGwob3B0aW9ucy5wYXJzZSk7XG4gICAgY29uc3QgZmlsdGVyZWRQYXJzZXJzID0gcGx1Z2lucy5maWx0ZXIoYWxsUGFyc2VycywgXCJjYW5QYXJzZVwiLCBmaWxlKTtcbiAgICBjb25zdCBwYXJzZXJzID0gZmlsdGVyZWRQYXJzZXJzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZFBhcnNlcnMgOiBhbGxQYXJzZXJzO1xuICAgIC8vIFJ1biB0aGUgcGFyc2VycywgaW4gb3JkZXIsIHVudGlsIG9uZSBvZiB0aGVtIHN1Y2NlZWRzXG4gICAgcGx1Z2lucy5zb3J0KHBhcnNlcnMpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IGF3YWl0IHBsdWdpbnMucnVuKHBhcnNlcnMsIFwicGFyc2VcIiwgZmlsZSwgJHJlZnMpO1xuICAgICAgICBpZiAoIXBhcnNlci5wbHVnaW4uYWxsb3dFbXB0eSAmJiBpc0VtcHR5KHBhcnNlci5yZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBvbm9fMS5vbm8uc3ludGF4KGBFcnJvciBwYXJzaW5nIFwiJHtmaWxlLnVybH1cIiBhcyAke3BhcnNlci5wbHVnaW4ubmFtZX0uIFxcblBhcnNlZCB2YWx1ZSBpcyBlbXB0eWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghZXJyICYmIG9wdGlvbnMuY29udGludWVPbkVycm9yKSB7XG4gICAgICAgICAgICAvLyBObyByZXNvbHZlciBjb3VsZCBiZSBtYXRjaGVkXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuVW5tYXRjaGVkUGFyc2VyRXJyb3IoZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVyciAmJiBlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5zdGFydHNXaXRoKFwiRXJyb3IgcGFyc2luZ1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFlcnIgfHwgIShcImVycm9yXCIgaW4gZXJyKSkge1xuICAgICAgICAgICAgdGhyb3cgb25vXzEub25vLnN5bnRheChgVW5hYmxlIHRvIHBhcnNlICR7ZmlsZS51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyLmVycm9yIGluc3RhbmNlb2YgZXJyb3JzX2pzXzEuUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVyci5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5QYXJzZXJFcnJvcihlcnIuZXJyb3IubWVzc2FnZSwgZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhcnNlZCB2YWx1ZSBpcyBcImVtcHR5XCIuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BINARY_REGEXP = /\\.(jpeg|jpg|gif|png|bmp|ico)$/i;\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 400,\n    /**\n     * Whether to allow \"empty\" files (zero bytes).\n     */\n    allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that return true will be tried, in order, until one successfully parses the file.\n     * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n     * every parser will be tried.\n     */\n    canParse(file) {\n        // Use this parser if the file is a Buffer, and has a known binary extension\n        return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);\n    },\n    /**\n     * Parses the given data as a Buffer (byte array).\n     */\n    parse(file) {\n        if (Buffer.isBuffer(file.data)) {\n            return file.data;\n        }\n        else {\n            // This will reject if data is anything other than a string or typed array\n            return Buffer.from(file.data);\n        }\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wYXJzZXJzL2JpbmFyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVhLW9saXZlLXdlYi8uL25vZGVfbW9kdWxlcy8ucG5wbS9AYXBpZGV2dG9vbHMranNvbi1zY2hlbWEtcmVmLXBhcnNlckAxMS45LjMvbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3BhcnNlcnMvYmluYXJ5LmpzP2YxNTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCSU5BUllfUkVHRVhQID0gL1xcLihqcGVnfGpwZ3xnaWZ8cG5nfGJtcHxpY28pJC9pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlciB0aGF0IHRoaXMgcGFyc2VyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciBwYXJzZXJzLlxuICAgICAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBhbGxvdyBcImVtcHR5XCIgZmlsZXMgKHplcm8gYnl0ZXMpLlxuICAgICAqL1xuICAgIGFsbG93RW1wdHk6IHRydWUsXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgcGFyc2VyIGNhbiBwYXJzZSBhIGdpdmVuIGZpbGUgcmVmZXJlbmNlLlxuICAgICAqIFBhcnNlcnMgdGhhdCByZXR1cm4gdHJ1ZSB3aWxsIGJlIHRyaWVkLCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSBwYXJzZXMgdGhlIGZpbGUuXG4gICAgICogUGFyc2VycyB0aGF0IHJldHVybiBmYWxzZSB3aWxsIGJlIHNraXBwZWQsIFVOTEVTUyBhbGwgcGFyc2VycyByZXR1cm5lZCBmYWxzZSwgaW4gd2hpY2ggY2FzZVxuICAgICAqIGV2ZXJ5IHBhcnNlciB3aWxsIGJlIHRyaWVkLlxuICAgICAqL1xuICAgIGNhblBhcnNlKGZpbGUpIHtcbiAgICAgICAgLy8gVXNlIHRoaXMgcGFyc2VyIGlmIHRoZSBmaWxlIGlzIGEgQnVmZmVyLCBhbmQgaGFzIGEga25vd24gYmluYXJ5IGV4dGVuc2lvblxuICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGZpbGUuZGF0YSkgJiYgQklOQVJZX1JFR0VYUC50ZXN0KGZpbGUudXJsKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gZGF0YSBhcyBhIEJ1ZmZlciAoYnl0ZSBhcnJheSkuXG4gICAgICovXG4gICAgcGFyc2UoZmlsZSkge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGZpbGUuZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgcmVqZWN0IGlmIGRhdGEgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhIHN0cmluZyBvciB0eXBlZCBhcnJheVxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGZpbGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 100,\n    /**\n     * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n     */\n    allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that match will be tried, in order, until one successfully parses the file.\n     * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n     * every parser will be tried.\n     */\n    canParse: \".json\",\n    /**\n     * Allow JSON files with byte order marks (BOM)\n     */\n    allowBOM: true,\n    /**\n     * Parses the given file as JSON\n     */\n    async parse(file) {\n        let data = file.data;\n        if (Buffer.isBuffer(data)) {\n            data = data.toString();\n        }\n        if (typeof data === \"string\") {\n            if (data.trim().length === 0) {\n                return; // This mirrors the YAML behavior\n            }\n            else {\n                try {\n                    return JSON.parse(data);\n                }\n                catch (e) {\n                    if (this.allowBOM) {\n                        try {\n                            // find the first curly brace\n                            const firstCurlyBrace = data.indexOf(\"{\");\n                            // remove any characters before the first curly brace\n                            data = data.slice(firstCurlyBrace);\n                            return JSON.parse(data);\n                        }\n                        catch (e) {\n                            throw new errors_js_1.ParserError(e.message, file.url);\n                        }\n                    }\n                    throw new errors_js_1.ParserError(e.message, file.url);\n                }\n            }\n        }\n        else {\n            // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n            return data;\n        }\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wYXJzZXJzL2pzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLG1CQUFPLENBQUMseUtBQW1CO0FBQy9DLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWEtb2xpdmUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhcGlkZXZ0b29scytqc29uLXNjaGVtYS1yZWYtcGFyc2VyQDExLjkuMy9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy9qc29uLmpzPzNkMzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9ycy5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JkZXIgdGhhdCB0aGlzIHBhcnNlciB3aWxsIHJ1biwgaW4gcmVsYXRpb24gdG8gb3RoZXIgcGFyc2Vycy5cbiAgICAgKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gYWxsb3cgXCJlbXB0eVwiIGZpbGVzLiBUaGlzIGluY2x1ZGVzIHplcm8tYnl0ZSBmaWxlcywgYXMgd2VsbCBhcyBlbXB0eSBKU09OIG9iamVjdHMuXG4gICAgICovXG4gICAgYWxsb3dFbXB0eTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBwYXJzZXIgY2FuIHBhcnNlIGEgZ2l2ZW4gZmlsZSByZWZlcmVuY2UuXG4gICAgICogUGFyc2VycyB0aGF0IG1hdGNoIHdpbGwgYmUgdHJpZWQsIGluIG9yZGVyLCB1bnRpbCBvbmUgc3VjY2Vzc2Z1bGx5IHBhcnNlcyB0aGUgZmlsZS5cbiAgICAgKiBQYXJzZXJzIHRoYXQgZG9uJ3QgbWF0Y2ggd2lsbCBiZSBza2lwcGVkLCBVTkxFU1Mgbm9uZSBvZiB0aGUgcGFyc2VycyBtYXRjaCwgaW4gd2hpY2ggY2FzZVxuICAgICAqIGV2ZXJ5IHBhcnNlciB3aWxsIGJlIHRyaWVkLlxuICAgICAqL1xuICAgIGNhblBhcnNlOiBcIi5qc29uXCIsXG4gICAgLyoqXG4gICAgICogQWxsb3cgSlNPTiBmaWxlcyB3aXRoIGJ5dGUgb3JkZXIgbWFya3MgKEJPTSlcbiAgICAgKi9cbiAgICBhbGxvd0JPTTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGdpdmVuIGZpbGUgYXMgSlNPTlxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlKGZpbGUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBmaWxlLmRhdGE7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUaGlzIG1pcnJvcnMgdGhlIFlBTUwgYmVoYXZpb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd0JPTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBjdXJseSBicmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q3VybHlCcmFjZSA9IGRhdGEuaW5kZXhPZihcIntcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFueSBjaGFyYWN0ZXJzIGJlZm9yZSB0aGUgZmlyc3QgY3VybHkgYnJhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zbGljZShmaXJzdEN1cmx5QnJhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuUGFyc2VyRXJyb3IoZS5tZXNzYWdlLCBmaWxlLnVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlBhcnNlckVycm9yKGUubWVzc2FnZSwgZmlsZS51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRhdGEgaXMgYWxyZWFkeSBhIEphdmFTY3JpcHQgdmFsdWUgKG9iamVjdCwgYXJyYXksIG51bWJlciwgbnVsbCwgTmFOLCBldGMuKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nconst TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 300,\n    /**\n     * Whether to allow \"empty\" files (zero bytes).\n     */\n    allowEmpty: true,\n    /**\n     * The encoding that the text is expected to be in.\n     */\n    encoding: \"utf8\",\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that return true will be tried, in order, until one successfully parses the file.\n     * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n     * every parser will be tried.\n     */\n    canParse(file) {\n        // Use this parser if the file is a string or Buffer, and has a known text-based extension\n        return (typeof file.data === \"string\" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n    },\n    /**\n     * Parses the given file as text\n     */\n    parse(file) {\n        if (typeof file.data === \"string\") {\n            return file.data;\n        }\n        else if (Buffer.isBuffer(file.data)) {\n            return file.data.toString(this.encoding);\n        }\n        else {\n            throw new errors_js_1.ParserError(\"data is not text\", file.url);\n        }\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wYXJzZXJzL3RleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLG1CQUFPLENBQUMseUtBQW1CO0FBQy9DO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWEtb2xpdmUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhcGlkZXZ0b29scytqc29uLXNjaGVtYS1yZWYtcGFyc2VyQDExLjkuMy9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy90ZXh0LmpzP2NlNTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9ycy5qc1wiKTtcbmNvbnN0IFRFWFRfUkVHRVhQID0gL1xcLih0eHR8aHRtfGh0bWx8bWR8eG1sfGpzfG1pbnxtYXB8Y3NzfHNjc3N8bGVzc3xzdmcpJC9pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlciB0aGF0IHRoaXMgcGFyc2VyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciBwYXJzZXJzLlxuICAgICAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBhbGxvdyBcImVtcHR5XCIgZmlsZXMgKHplcm8gYnl0ZXMpLlxuICAgICAqL1xuICAgIGFsbG93RW1wdHk6IHRydWUsXG4gICAgLyoqXG4gICAgICogVGhlIGVuY29kaW5nIHRoYXQgdGhlIHRleHQgaXMgZXhwZWN0ZWQgdG8gYmUgaW4uXG4gICAgICovXG4gICAgZW5jb2Rpbmc6IFwidXRmOFwiLFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIHBhcnNlciBjYW4gcGFyc2UgYSBnaXZlbiBmaWxlIHJlZmVyZW5jZS5cbiAgICAgKiBQYXJzZXJzIHRoYXQgcmV0dXJuIHRydWUgd2lsbCBiZSB0cmllZCwgaW4gb3JkZXIsIHVudGlsIG9uZSBzdWNjZXNzZnVsbHkgcGFyc2VzIHRoZSBmaWxlLlxuICAgICAqIFBhcnNlcnMgdGhhdCByZXR1cm4gZmFsc2Ugd2lsbCBiZSBza2lwcGVkLCBVTkxFU1MgYWxsIHBhcnNlcnMgcmV0dXJuZWQgZmFsc2UsIGluIHdoaWNoIGNhc2VcbiAgICAgKiBldmVyeSBwYXJzZXIgd2lsbCBiZSB0cmllZC5cbiAgICAgKi9cbiAgICBjYW5QYXJzZShmaWxlKSB7XG4gICAgICAgIC8vIFVzZSB0aGlzIHBhcnNlciBpZiB0aGUgZmlsZSBpcyBhIHN0cmluZyBvciBCdWZmZXIsIGFuZCBoYXMgYSBrbm93biB0ZXh0LWJhc2VkIGV4dGVuc2lvblxuICAgICAgICByZXR1cm4gKHR5cGVvZiBmaWxlLmRhdGEgPT09IFwic3RyaW5nXCIgfHwgQnVmZmVyLmlzQnVmZmVyKGZpbGUuZGF0YSkpICYmIFRFWFRfUkVHRVhQLnRlc3QoZmlsZS51cmwpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBnaXZlbiBmaWxlIGFzIHRleHRcbiAgICAgKi9cbiAgICBwYXJzZShmaWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZS5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihmaWxlLmRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZS5kYXRhLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlBhcnNlckVycm9yKFwiZGF0YSBpcyBub3QgdGV4dFwiLCBmaWxlLnVybCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js ***!
  \*************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nconst js_yaml_1 = __importDefault(__webpack_require__(/*! js-yaml */ \"(rsc)/./node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/index.js\"));\nconst js_yaml_2 = __webpack_require__(/*! js-yaml */ \"(rsc)/./node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/index.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 200,\n    /**\n     * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n     */\n    allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that match will be tried, in order, until one successfully parses the file.\n     * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n     * every parser will be tried.\n     */\n    canParse: [\".yaml\", \".yml\", \".json\"], // JSON is valid YAML\n    /**\n     * Parses the given file as YAML\n     *\n     * @param file           - An object containing information about the referenced file\n     * @param file.url       - The full URL of the referenced file\n     * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n     * @param file.data      - The file contents. This will be whatever data type was returned by the resolver\n     * @returns\n     */\n    async parse(file) {\n        let data = file.data;\n        if (Buffer.isBuffer(data)) {\n            data = data.toString();\n        }\n        if (typeof data === \"string\") {\n            try {\n                return js_yaml_1.default.load(data, { schema: js_yaml_2.JSON_SCHEMA });\n            }\n            catch (e) {\n                throw new errors_js_1.ParserError(e?.message || \"Parser Error\", file.url);\n            }\n        }\n        else {\n            // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n            return data;\n        }\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wYXJzZXJzL3lhbWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyx5S0FBbUI7QUFDL0Msa0NBQWtDLG1CQUFPLENBQUMsdUZBQVM7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsdUZBQVM7QUFDbkMsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwrQkFBK0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVhLW9saXZlLXdlYi8uL25vZGVfbW9kdWxlcy8ucG5wbS9AYXBpZGV2dG9vbHMranNvbi1zY2hlbWEtcmVmLXBhcnNlckAxMS45LjMvbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3BhcnNlcnMveWFtbC5qcz85NzA1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9lcnJvcnMuanNcIik7XG5jb25zdCBqc195YW1sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzLXlhbWxcIikpO1xuY29uc3QganNfeWFtbF8yID0gcmVxdWlyZShcImpzLXlhbWxcIik7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIG9yZGVyIHRoYXQgdGhpcyBwYXJzZXIgd2lsbCBydW4sIGluIHJlbGF0aW9uIHRvIG90aGVyIHBhcnNlcnMuXG4gICAgICovXG4gICAgb3JkZXI6IDIwMCxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGFsbG93IFwiZW1wdHlcIiBmaWxlcy4gVGhpcyBpbmNsdWRlcyB6ZXJvLWJ5dGUgZmlsZXMsIGFzIHdlbGwgYXMgZW1wdHkgSlNPTiBvYmplY3RzLlxuICAgICAqL1xuICAgIGFsbG93RW1wdHk6IHRydWUsXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgcGFyc2VyIGNhbiBwYXJzZSBhIGdpdmVuIGZpbGUgcmVmZXJlbmNlLlxuICAgICAqIFBhcnNlcnMgdGhhdCBtYXRjaCB3aWxsIGJlIHRyaWVkLCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSBwYXJzZXMgdGhlIGZpbGUuXG4gICAgICogUGFyc2VycyB0aGF0IGRvbid0IG1hdGNoIHdpbGwgYmUgc2tpcHBlZCwgVU5MRVNTIG5vbmUgb2YgdGhlIHBhcnNlcnMgbWF0Y2gsIGluIHdoaWNoIGNhc2VcbiAgICAgKiBldmVyeSBwYXJzZXIgd2lsbCBiZSB0cmllZC5cbiAgICAgKi9cbiAgICBjYW5QYXJzZTogW1wiLnlhbWxcIiwgXCIueW1sXCIsIFwiLmpzb25cIl0sIC8vIEpTT04gaXMgdmFsaWQgWUFNTFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gZmlsZSBhcyBZQU1MXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZSAgICAgICAgICAgLSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVmZXJlbmNlZCBmaWxlXG4gICAgICogQHBhcmFtIGZpbGUudXJsICAgICAgIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICAgKiBAcGFyYW0gZmlsZS5leHRlbnNpb24gLSBUaGUgbG93ZXJjYXNlZCBmaWxlIGV4dGVuc2lvbiAoZS5nLiBcIi50eHRcIiwgXCIuaHRtbFwiLCBldGMuKVxuICAgICAqIEBwYXJhbSBmaWxlLmRhdGEgICAgICAtIFRoZSBmaWxlIGNvbnRlbnRzLiBUaGlzIHdpbGwgYmUgd2hhdGV2ZXIgZGF0YSB0eXBlIHdhcyByZXR1cm5lZCBieSB0aGUgcmVzb2x2ZXJcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlKGZpbGUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBmaWxlLmRhdGE7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc195YW1sXzEuZGVmYXVsdC5sb2FkKGRhdGEsIHsgc2NoZW1hOiBqc195YW1sXzIuSlNPTl9TQ0hFTUEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5QYXJzZXJFcnJvcihlPy5tZXNzYWdlIHx8IFwiUGFyc2VyIEVycm9yXCIsIGZpbGUudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRhdGEgaXMgYWxyZWFkeSBhIEphdmFTY3JpcHQgdmFsdWUgKG9iamVjdCwgYXJyYXksIG51bWJlciwgbnVsbCwgTmFOLCBldGMuKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js ***!
  \********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.nullSymbol = void 0;\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports.nullSymbol = Symbol('null');\nconst slashes = /\\//g;\nconst tildes = /~/g;\nconst escapedSlash = /~1/g;\nconst escapedTilde = /~0/g;\nconst safeDecodeURIComponent = (encodedURIComponent) => {\n    try {\n        return decodeURIComponent(encodedURIComponent);\n    }\n    catch {\n        return encodedURIComponent;\n    }\n};\n/**\n * This class represents a single JSON pointer and its resolved value.\n *\n * @param $ref\n * @param path\n * @param [friendlyPath] - The original user-specified path (used for error messages)\n * @class\n */\nclass Pointer {\n    constructor($ref, path, friendlyPath) {\n        this.$ref = $ref;\n        this.path = path;\n        this.originalPath = friendlyPath || path;\n        this.value = undefined;\n        this.circular = false;\n        this.indirections = 0;\n    }\n    /**\n     * Resolves the value of a nested property within the given object.\n     *\n     * @param obj - The object that will be crawled\n     * @param options\n     * @param pathFromRoot - the path of place that initiated resolving\n     *\n     * @returns\n     * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.\n     * If resolving this value required resolving other JSON references, then\n     * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path\n     * of the resolved value.\n     */\n    resolve(obj, options, pathFromRoot) {\n        const tokens = Pointer.parse(this.path, this.originalPath);\n        const found = [];\n        // Crawl the object, one token at a time\n        this.value = unwrapOrThrow(obj);\n        for (let i = 0; i < tokens.length; i++) {\n            if (resolveIf$Ref(this, options, pathFromRoot)) {\n                // The $ref path has changed, so append the remaining tokens to the path\n                this.path = Pointer.join(this.path, tokens.slice(i));\n            }\n            if (typeof this.value === \"object\" && this.value !== null && !isRootPath(pathFromRoot) && \"$ref\" in this.value) {\n                return this;\n            }\n            const token = tokens[i];\n            if (this.value[token] === undefined || (this.value[token] === null && i === tokens.length - 1)) {\n                // one final case is if the entry itself includes slashes, and was parsed out as a token - we can join the remaining tokens and try again\n                let didFindSubstringSlashMatch = false;\n                for (let j = tokens.length - 1; j > i; j--) {\n                    const joinedToken = tokens.slice(i, j + 1).join(\"/\");\n                    if (this.value[joinedToken] !== undefined) {\n                        this.value = this.value[joinedToken];\n                        i = j;\n                        didFindSubstringSlashMatch = true;\n                        break;\n                    }\n                }\n                if (didFindSubstringSlashMatch) {\n                    continue;\n                }\n                // If the token we're looking for ended up not containing any slashes but is\n                // actually instead pointing to an existing `null` value then we should use that\n                // `null` value.\n                if (token in this.value && this.value[token] === null) {\n                    // We use a `null` symbol for internal tracking to differntiate between a general `null`\n                    // value and our expected `null` value.\n                    this.value = exports.nullSymbol;\n                    continue;\n                }\n                this.value = null;\n                const path = this.$ref.path || \"\";\n                const targetRef = this.path.replace(path, \"\");\n                const targetFound = Pointer.join(\"\", found);\n                const parentPath = pathFromRoot?.replace(path, \"\");\n                throw new errors_js_1.MissingPointerError(token, decodeURI(this.originalPath), targetRef, targetFound, parentPath);\n            }\n            else {\n                this.value = this.value[token];\n            }\n            found.push(token);\n        }\n        // Resolve the final value\n        if (!this.value || (this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot)) {\n            resolveIf$Ref(this, options, pathFromRoot);\n        }\n        return this;\n    }\n    /**\n     * Sets the value of a nested property within the given object.\n     *\n     * @param obj - The object that will be crawled\n     * @param value - the value to assign\n     * @param options\n     *\n     * @returns\n     * Returns the modified object, or an entirely new object if the entire object is overwritten.\n     */\n    set(obj, value, options) {\n        const tokens = Pointer.parse(this.path);\n        let token;\n        if (tokens.length === 0) {\n            // There are no tokens, replace the entire object with the new value\n            this.value = value;\n            return value;\n        }\n        // Crawl the object, one token at a time\n        this.value = unwrapOrThrow(obj);\n        for (let i = 0; i < tokens.length - 1; i++) {\n            resolveIf$Ref(this, options);\n            token = tokens[i];\n            if (this.value && this.value[token] !== undefined) {\n                // The token exists\n                this.value = this.value[token];\n            }\n            else {\n                // The token doesn't exist, so create it\n                this.value = setValue(this, token, {});\n            }\n        }\n        // Set the value of the final token\n        resolveIf$Ref(this, options);\n        token = tokens[tokens.length - 1];\n        setValue(this, token, value);\n        // Return the updated object\n        return obj;\n    }\n    /**\n     * Parses a JSON pointer (or a path containing a JSON pointer in the hash)\n     * and returns an array of the pointer's tokens.\n     * (e.g. \"schema.json#/definitions/person/name\" => [\"definitions\", \"person\", \"name\"])\n     *\n     * The pointer is parsed according to RFC 6901\n     * {@link https://tools.ietf.org/html/rfc6901#section-3}\n     *\n     * @param path\n     * @param [originalPath]\n     * @returns\n     */\n    static parse(path, originalPath) {\n        // Get the JSON pointer from the path's hash\n        const pointer = url.getHash(path).substring(1);\n        // If there's no pointer, then there are no tokens,\n        // so return an empty array\n        if (!pointer) {\n            return [];\n        }\n        // Split into an array\n        const split = pointer.split(\"/\");\n        // Decode each part, according to RFC 6901\n        for (let i = 0; i < split.length; i++) {\n            split[i] = safeDecodeURIComponent(split[i].replace(escapedSlash, \"/\").replace(escapedTilde, \"~\"));\n        }\n        if (split[0] !== \"\") {\n            throw new errors_js_1.InvalidPointerError(pointer, originalPath === undefined ? path : originalPath);\n        }\n        return split.slice(1);\n    }\n    /**\n     * Creates a JSON pointer path, by joining one or more tokens to a base path.\n     *\n     * @param base - The base path (e.g. \"schema.json#/definitions/person\")\n     * @param tokens - The token(s) to append (e.g. [\"name\", \"first\"])\n     * @returns\n     */\n    static join(base, tokens) {\n        // Ensure that the base path contains a hash\n        if (base.indexOf(\"#\") === -1) {\n            base += \"#\";\n        }\n        // Append each token to the base path\n        tokens = Array.isArray(tokens) ? tokens : [tokens];\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n            // Encode the token, according to RFC 6901\n            base += \"/\" + encodeURIComponent(token.replace(tildes, \"~0\").replace(slashes, \"~1\"));\n        }\n        return base;\n    }\n}\n/**\n * If the given pointer's {@link Pointer#value} is a JSON reference,\n * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.\n * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the\n * resolution path of the new value.\n *\n * @param pointer\n * @param options\n * @param [pathFromRoot] - the path of place that initiated resolving\n * @returns - Returns `true` if the resolution path changed\n */\nfunction resolveIf$Ref(pointer, options, pathFromRoot) {\n    // Is the value a JSON reference? (and allowed?)\n    if (ref_js_1.default.isAllowed$Ref(pointer.value, options)) {\n        const $refPath = url.resolve(pointer.path, pointer.value.$ref);\n        if ($refPath === pointer.path && !isRootPath(pathFromRoot)) {\n            // The value is a reference to itself, so there's nothing to do.\n            pointer.circular = true;\n        }\n        else {\n            const resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);\n            if (resolved === null) {\n                return false;\n            }\n            pointer.indirections += resolved.indirections + 1;\n            if (ref_js_1.default.isExtended$Ref(pointer.value)) {\n                // This JSON reference \"extends\" the resolved value, rather than simply pointing to it.\n                // So the resolved path does NOT change.  Just the value does.\n                pointer.value = ref_js_1.default.dereference(pointer.value, resolved.value);\n                return false;\n            }\n            else {\n                // Resolve the reference\n                pointer.$ref = resolved.$ref;\n                pointer.path = resolved.path;\n                pointer.value = resolved.value;\n            }\n            return true;\n        }\n    }\n    return undefined;\n}\nexports[\"default\"] = Pointer;\n/**\n * Sets the specified token value of the {@link Pointer#value}.\n *\n * The token is evaluated according to RFC 6901.\n * {@link https://tools.ietf.org/html/rfc6901#section-4}\n *\n * @param pointer - The JSON Pointer whose value will be modified\n * @param token - A JSON Pointer token that indicates how to modify `obj`\n * @param value - The value to assign\n * @returns - Returns the assigned value\n */\nfunction setValue(pointer, token, value) {\n    if (pointer.value && typeof pointer.value === \"object\") {\n        if (token === \"-\" && Array.isArray(pointer.value)) {\n            pointer.value.push(value);\n        }\n        else {\n            pointer.value[token] = value;\n        }\n    }\n    else {\n        throw new errors_js_1.JSONParserError(`Error assigning $ref pointer \"${pointer.path}\". \\nCannot set \"${token}\" of a non-object.`);\n    }\n    return value;\n}\nfunction unwrapOrThrow(value) {\n    if ((0, errors_js_1.isHandledError)(value)) {\n        throw value;\n    }\n    return value;\n}\nfunction isRootPath(pathFromRoot) {\n    return typeof pathFromRoot == \"string\" && Pointer.parse(pathFromRoot).length == 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wb2ludGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGlDQUFpQyxtQkFBTyxDQUFDLHdKQUFVO0FBQ25ELHlCQUF5QixtQkFBTyxDQUFDLGtLQUFlO0FBQ2hELG9CQUFvQixtQkFBTyxDQUFDLHdLQUFrQjtBQUM5QyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFEO0FBQ0EsWUFBWSxvQkFBb0IsS0FBSyxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQsdUNBQXVDLHFCQUFxQjtBQUM1RCxpQkFBaUIsb0JBQW9CLEtBQUssb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGFBQWEsbUJBQW1CLE1BQU07QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVhLW9saXZlLXdlYi8uL25vZGVfbW9kdWxlcy8ucG5wbS9AYXBpZGV2dG9vbHMranNvbi1zY2hlbWEtcmVmLXBhcnNlckAxMS45LjMvbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3BvaW50ZXIuanM/NDg2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5udWxsU3ltYm9sID0gdm9pZCAwO1xuY29uc3QgcmVmX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVmLmpzXCIpKTtcbmNvbnN0IHVybCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvZXJyb3JzLmpzXCIpO1xuZXhwb3J0cy5udWxsU3ltYm9sID0gU3ltYm9sKCdudWxsJyk7XG5jb25zdCBzbGFzaGVzID0gL1xcLy9nO1xuY29uc3QgdGlsZGVzID0gL34vZztcbmNvbnN0IGVzY2FwZWRTbGFzaCA9IC9+MS9nO1xuY29uc3QgZXNjYXBlZFRpbGRlID0gL34wL2c7XG5jb25zdCBzYWZlRGVjb2RlVVJJQ29tcG9uZW50ID0gKGVuY29kZWRVUklDb21wb25lbnQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZWRVUklDb21wb25lbnQpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBlbmNvZGVkVVJJQ29tcG9uZW50O1xuICAgIH1cbn07XG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIHNpbmdsZSBKU09OIHBvaW50ZXIgYW5kIGl0cyByZXNvbHZlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gJHJlZlxuICogQHBhcmFtIHBhdGhcbiAqIEBwYXJhbSBbZnJpZW5kbHlQYXRoXSAtIFRoZSBvcmlnaW5hbCB1c2VyLXNwZWNpZmllZCBwYXRoICh1c2VkIGZvciBlcnJvciBtZXNzYWdlcylcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBQb2ludGVyIHtcbiAgICBjb25zdHJ1Y3RvcigkcmVmLCBwYXRoLCBmcmllbmRseVBhdGgpIHtcbiAgICAgICAgdGhpcy4kcmVmID0gJHJlZjtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFBhdGggPSBmcmllbmRseVBhdGggfHwgcGF0aDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jaXJjdWxhciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZGlyZWN0aW9ucyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSB2YWx1ZSBvZiBhIG5lc3RlZCBwcm9wZXJ0eSB3aXRoaW4gdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSBjcmF3bGVkXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gcGF0aEZyb21Sb290IC0gdGhlIHBhdGggb2YgcGxhY2UgdGhhdCBpbml0aWF0ZWQgcmVzb2x2aW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqIFJldHVybnMgYSBKU09OIHBvaW50ZXIgd2hvc2Uge0BsaW5rIFBvaW50ZXIjdmFsdWV9IGlzIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBJZiByZXNvbHZpbmcgdGhpcyB2YWx1ZSByZXF1aXJlZCByZXNvbHZpbmcgb3RoZXIgSlNPTiByZWZlcmVuY2VzLCB0aGVuXG4gICAgICogdGhlIHtAbGluayBQb2ludGVyIyRyZWZ9IGFuZCB7QGxpbmsgUG9pbnRlciNwYXRofSB3aWxsIHJlZmxlY3QgdGhlIHJlc29sdXRpb24gcGF0aFxuICAgICAqIG9mIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICByZXNvbHZlKG9iaiwgb3B0aW9ucywgcGF0aEZyb21Sb290KSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFBvaW50ZXIucGFyc2UodGhpcy5wYXRoLCB0aGlzLm9yaWdpbmFsUGF0aCk7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gW107XG4gICAgICAgIC8vIENyYXdsIHRoZSBvYmplY3QsIG9uZSB0b2tlbiBhdCBhIHRpbWVcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVud3JhcE9yVGhyb3cob2JqKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlSWYkUmVmKHRoaXMsIG9wdGlvbnMsIHBhdGhGcm9tUm9vdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgJHJlZiBwYXRoIGhhcyBjaGFuZ2VkLCBzbyBhcHBlbmQgdGhlIHJlbWFpbmluZyB0b2tlbnMgdG8gdGhlIHBhdGhcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBQb2ludGVyLmpvaW4odGhpcy5wYXRoLCB0b2tlbnMuc2xpY2UoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSBcIm9iamVjdFwiICYmIHRoaXMudmFsdWUgIT09IG51bGwgJiYgIWlzUm9vdFBhdGgocGF0aEZyb21Sb290KSAmJiBcIiRyZWZcIiBpbiB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlW3Rva2VuXSA9PT0gdW5kZWZpbmVkIHx8ICh0aGlzLnZhbHVlW3Rva2VuXSA9PT0gbnVsbCAmJiBpID09PSB0b2tlbnMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmUgZmluYWwgY2FzZSBpcyBpZiB0aGUgZW50cnkgaXRzZWxmIGluY2x1ZGVzIHNsYXNoZXMsIGFuZCB3YXMgcGFyc2VkIG91dCBhcyBhIHRva2VuIC0gd2UgY2FuIGpvaW4gdGhlIHJlbWFpbmluZyB0b2tlbnMgYW5kIHRyeSBhZ2FpblxuICAgICAgICAgICAgICAgIGxldCBkaWRGaW5kU3Vic3RyaW5nU2xhc2hNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0b2tlbnMubGVuZ3RoIC0gMTsgaiA+IGk7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqb2luZWRUb2tlbiA9IHRva2Vucy5zbGljZShpLCBqICsgMSkuam9pbihcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlW2pvaW5lZFRva2VuXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVtqb2luZWRUb2tlbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZEZpbmRTdWJzdHJpbmdTbGFzaE1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaWRGaW5kU3Vic3RyaW5nU2xhc2hNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRva2VuIHdlJ3JlIGxvb2tpbmcgZm9yIGVuZGVkIHVwIG5vdCBjb250YWluaW5nIGFueSBzbGFzaGVzIGJ1dCBpc1xuICAgICAgICAgICAgICAgIC8vIGFjdHVhbGx5IGluc3RlYWQgcG9pbnRpbmcgdG8gYW4gZXhpc3RpbmcgYG51bGxgIHZhbHVlIHRoZW4gd2Ugc2hvdWxkIHVzZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gYG51bGxgIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiBpbiB0aGlzLnZhbHVlICYmIHRoaXMudmFsdWVbdG9rZW5dID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBhIGBudWxsYCBzeW1ib2wgZm9yIGludGVybmFsIHRyYWNraW5nIHRvIGRpZmZlcm50aWF0ZSBiZXR3ZWVuIGEgZ2VuZXJhbCBgbnVsbGBcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgYW5kIG91ciBleHBlY3RlZCBgbnVsbGAgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBleHBvcnRzLm51bGxTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy4kcmVmLnBhdGggfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRSZWYgPSB0aGlzLnBhdGgucmVwbGFjZShwYXRoLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRGb3VuZCA9IFBvaW50ZXIuam9pbihcIlwiLCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGhGcm9tUm9vdD8ucmVwbGFjZShwYXRoLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuTWlzc2luZ1BvaW50ZXJFcnJvcih0b2tlbiwgZGVjb2RlVVJJKHRoaXMub3JpZ2luYWxQYXRoKSwgdGFyZ2V0UmVmLCB0YXJnZXRGb3VuZCwgcGFyZW50UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVt0b2tlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZC5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBmaW5hbCB2YWx1ZVxuICAgICAgICBpZiAoIXRoaXMudmFsdWUgfHwgKHRoaXMudmFsdWUuJHJlZiAmJiB1cmwucmVzb2x2ZSh0aGlzLnBhdGgsIHRoaXMudmFsdWUuJHJlZikgIT09IHBhdGhGcm9tUm9vdCkpIHtcbiAgICAgICAgICAgIHJlc29sdmVJZiRSZWYodGhpcywgb3B0aW9ucywgcGF0aEZyb21Sb290KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBuZXN0ZWQgcHJvcGVydHkgd2l0aGluIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqIC0gVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgY3Jhd2xlZFxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2RpZmllZCBvYmplY3QsIG9yIGFuIGVudGlyZWx5IG5ldyBvYmplY3QgaWYgdGhlIGVudGlyZSBvYmplY3QgaXMgb3ZlcndyaXR0ZW4uXG4gICAgICovXG4gICAgc2V0KG9iaiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gUG9pbnRlci5wYXJzZSh0aGlzLnBhdGgpO1xuICAgICAgICBsZXQgdG9rZW47XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gdG9rZW5zLCByZXBsYWNlIHRoZSBlbnRpcmUgb2JqZWN0IHdpdGggdGhlIG5ldyB2YWx1ZVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyYXdsIHRoZSBvYmplY3QsIG9uZSB0b2tlbiBhdCBhIHRpbWVcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVud3JhcE9yVGhyb3cob2JqKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICByZXNvbHZlSWYkUmVmKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlW3Rva2VuXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRva2VuIGV4aXN0c1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlW3Rva2VuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0b2tlbiBkb2Vzbid0IGV4aXN0LCBzbyBjcmVhdGUgaXRcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gc2V0VmFsdWUodGhpcywgdG9rZW4sIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIHZhbHVlIG9mIHRoZSBmaW5hbCB0b2tlblxuICAgICAgICByZXNvbHZlSWYkUmVmKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHNldFZhbHVlKHRoaXMsIHRva2VuLCB2YWx1ZSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgdXBkYXRlZCBvYmplY3RcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgSlNPTiBwb2ludGVyIChvciBhIHBhdGggY29udGFpbmluZyBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaClcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRlcidzIHRva2Vucy5cbiAgICAgKiAoZS5nLiBcInNjaGVtYS5qc29uIy9kZWZpbml0aW9ucy9wZXJzb24vbmFtZVwiID0+IFtcImRlZmluaXRpb25zXCIsIFwicGVyc29uXCIsIFwibmFtZVwiXSlcbiAgICAgKlxuICAgICAqIFRoZSBwb2ludGVyIGlzIHBhcnNlZCBhY2NvcmRpbmcgdG8gUkZDIDY5MDFcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi0zfVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGhcbiAgICAgKiBAcGFyYW0gW29yaWdpbmFsUGF0aF1cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZShwYXRoLCBvcmlnaW5hbFBhdGgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBKU09OIHBvaW50ZXIgZnJvbSB0aGUgcGF0aCdzIGhhc2hcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IHVybC5nZXRIYXNoKHBhdGgpLnN1YnN0cmluZygxKTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBwb2ludGVyLCB0aGVuIHRoZXJlIGFyZSBubyB0b2tlbnMsXG4gICAgICAgIC8vIHNvIHJldHVybiBhbiBlbXB0eSBhcnJheVxuICAgICAgICBpZiAoIXBvaW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGxpdCBpbnRvIGFuIGFycmF5XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gcG9pbnRlci5zcGxpdChcIi9cIik7XG4gICAgICAgIC8vIERlY29kZSBlYWNoIHBhcnQsIGFjY29yZGluZyB0byBSRkMgNjkwMVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzcGxpdFtpXSA9IHNhZmVEZWNvZGVVUklDb21wb25lbnQoc3BsaXRbaV0ucmVwbGFjZShlc2NhcGVkU2xhc2gsIFwiL1wiKS5yZXBsYWNlKGVzY2FwZWRUaWxkZSwgXCJ+XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BsaXRbMF0gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5JbnZhbGlkUG9pbnRlckVycm9yKHBvaW50ZXIsIG9yaWdpbmFsUGF0aCA9PT0gdW5kZWZpbmVkID8gcGF0aCA6IG9yaWdpbmFsUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0LnNsaWNlKDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgSlNPTiBwb2ludGVyIHBhdGgsIGJ5IGpvaW5pbmcgb25lIG9yIG1vcmUgdG9rZW5zIHRvIGEgYmFzZSBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhc2UgLSBUaGUgYmFzZSBwYXRoIChlLmcuIFwic2NoZW1hLmpzb24jL2RlZmluaXRpb25zL3BlcnNvblwiKVxuICAgICAqIEBwYXJhbSB0b2tlbnMgLSBUaGUgdG9rZW4ocykgdG8gYXBwZW5kIChlLmcuIFtcIm5hbWVcIiwgXCJmaXJzdFwiXSlcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBqb2luKGJhc2UsIHRva2Vucykge1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgYmFzZSBwYXRoIGNvbnRhaW5zIGEgaGFzaFxuICAgICAgICBpZiAoYmFzZS5pbmRleE9mKFwiI1wiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJhc2UgKz0gXCIjXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIGVhY2ggdG9rZW4gdG8gdGhlIGJhc2UgcGF0aFxuICAgICAgICB0b2tlbnMgPSBBcnJheS5pc0FycmF5KHRva2VucykgPyB0b2tlbnMgOiBbdG9rZW5zXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSB0b2tlbiwgYWNjb3JkaW5nIHRvIFJGQyA2OTAxXG4gICAgICAgICAgICBiYXNlICs9IFwiL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KHRva2VuLnJlcGxhY2UodGlsZGVzLCBcIn4wXCIpLnJlcGxhY2Uoc2xhc2hlcywgXCJ+MVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufVxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gcG9pbnRlcidzIHtAbGluayBQb2ludGVyI3ZhbHVlfSBpcyBhIEpTT04gcmVmZXJlbmNlLFxuICogdGhlbiB0aGUgcmVmZXJlbmNlIGlzIHJlc29sdmVkIGFuZCB7QGxpbmsgUG9pbnRlciN2YWx1ZX0gaXMgcmVwbGFjZWQgd2l0aCB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBJbiBhZGRpdGlvbiwge0BsaW5rIFBvaW50ZXIjcGF0aH0gYW5kIHtAbGluayBQb2ludGVyIyRyZWZ9IGFyZSB1cGRhdGVkIHRvIHJlZmxlY3QgdGhlXG4gKiByZXNvbHV0aW9uIHBhdGggb2YgdGhlIG5ldyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gcG9pbnRlclxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBbcGF0aEZyb21Sb290XSAtIHRoZSBwYXRoIG9mIHBsYWNlIHRoYXQgaW5pdGlhdGVkIHJlc29sdmluZ1xuICogQHJldHVybnMgLSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVzb2x1dGlvbiBwYXRoIGNoYW5nZWRcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUlmJFJlZihwb2ludGVyLCBvcHRpb25zLCBwYXRoRnJvbVJvb3QpIHtcbiAgICAvLyBJcyB0aGUgdmFsdWUgYSBKU09OIHJlZmVyZW5jZT8gKGFuZCBhbGxvd2VkPylcbiAgICBpZiAocmVmX2pzXzEuZGVmYXVsdC5pc0FsbG93ZWQkUmVmKHBvaW50ZXIudmFsdWUsIG9wdGlvbnMpKSB7XG4gICAgICAgIGNvbnN0ICRyZWZQYXRoID0gdXJsLnJlc29sdmUocG9pbnRlci5wYXRoLCBwb2ludGVyLnZhbHVlLiRyZWYpO1xuICAgICAgICBpZiAoJHJlZlBhdGggPT09IHBvaW50ZXIucGF0aCAmJiAhaXNSb290UGF0aChwYXRoRnJvbVJvb3QpKSB7XG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgaXMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLCBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgICAgICBwb2ludGVyLmNpcmN1bGFyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gcG9pbnRlci4kcmVmLiRyZWZzLl9yZXNvbHZlKCRyZWZQYXRoLCBwb2ludGVyLnBhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlci5pbmRpcmVjdGlvbnMgKz0gcmVzb2x2ZWQuaW5kaXJlY3Rpb25zICsgMTtcbiAgICAgICAgICAgIGlmIChyZWZfanNfMS5kZWZhdWx0LmlzRXh0ZW5kZWQkUmVmKHBvaW50ZXIudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBKU09OIHJlZmVyZW5jZSBcImV4dGVuZHNcIiB0aGUgcmVzb2x2ZWQgdmFsdWUsIHJhdGhlciB0aGFuIHNpbXBseSBwb2ludGluZyB0byBpdC5cbiAgICAgICAgICAgICAgICAvLyBTbyB0aGUgcmVzb2x2ZWQgcGF0aCBkb2VzIE5PVCBjaGFuZ2UuICBKdXN0IHRoZSB2YWx1ZSBkb2VzLlxuICAgICAgICAgICAgICAgIHBvaW50ZXIudmFsdWUgPSByZWZfanNfMS5kZWZhdWx0LmRlcmVmZXJlbmNlKHBvaW50ZXIudmFsdWUsIHJlc29sdmVkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBwb2ludGVyLiRyZWYgPSByZXNvbHZlZC4kcmVmO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIucGF0aCA9IHJlc29sdmVkLnBhdGg7XG4gICAgICAgICAgICAgICAgcG9pbnRlci52YWx1ZSA9IHJlc29sdmVkLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBvaW50ZXI7XG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCB0b2tlbiB2YWx1ZSBvZiB0aGUge0BsaW5rIFBvaW50ZXIjdmFsdWV9LlxuICpcbiAqIFRoZSB0b2tlbiBpcyBldmFsdWF0ZWQgYWNjb3JkaW5nIHRvIFJGQyA2OTAxLlxuICoge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxI3NlY3Rpb24tNH1cbiAqXG4gKiBAcGFyYW0gcG9pbnRlciAtIFRoZSBKU09OIFBvaW50ZXIgd2hvc2UgdmFsdWUgd2lsbCBiZSBtb2RpZmllZFxuICogQHBhcmFtIHRva2VuIC0gQSBKU09OIFBvaW50ZXIgdG9rZW4gdGhhdCBpbmRpY2F0ZXMgaG93IHRvIG1vZGlmeSBgb2JqYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFzc2lnblxuICogQHJldHVybnMgLSBSZXR1cm5zIHRoZSBhc3NpZ25lZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBzZXRWYWx1ZShwb2ludGVyLCB0b2tlbiwgdmFsdWUpIHtcbiAgICBpZiAocG9pbnRlci52YWx1ZSAmJiB0eXBlb2YgcG9pbnRlci52YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAodG9rZW4gPT09IFwiLVwiICYmIEFycmF5LmlzQXJyYXkocG9pbnRlci52YWx1ZSkpIHtcbiAgICAgICAgICAgIHBvaW50ZXIudmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2ludGVyLnZhbHVlW3Rva2VuXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuSlNPTlBhcnNlckVycm9yKGBFcnJvciBhc3NpZ25pbmcgJHJlZiBwb2ludGVyIFwiJHtwb2ludGVyLnBhdGh9XCIuIFxcbkNhbm5vdCBzZXQgXCIke3Rva2VufVwiIG9mIGEgbm9uLW9iamVjdC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdW53cmFwT3JUaHJvdyh2YWx1ZSkge1xuICAgIGlmICgoMCwgZXJyb3JzX2pzXzEuaXNIYW5kbGVkRXJyb3IpKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaXNSb290UGF0aChwYXRoRnJvbVJvb3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIHBhdGhGcm9tUm9vdCA9PSBcInN0cmluZ1wiICYmIFBvaW50ZXIucGFyc2UocGF0aEZyb21Sb290KS5sZW5ndGggPT0gMDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js ***!
  \****************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst pointer_js_1 = __importStar(__webpack_require__(/*! ./pointer.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nconst url_js_1 = __webpack_require__(/*! ./util/url.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\");\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @class\n */\nclass $Ref {\n    constructor($refs) {\n        /**\n         * List of all errors. Undefined if no errors.\n         */\n        this.errors = [];\n        this.$refs = $refs;\n    }\n    /**\n     * Pushes an error to errors array.\n     *\n     * @param err - The error to be pushed\n     * @returns\n     */\n    addError(err) {\n        if (this.errors === undefined) {\n            this.errors = [];\n        }\n        const existingErrors = this.errors.map(({ footprint }) => footprint);\n        // the path has been almost certainly set at this point,\n        // but just in case something went wrong, normalizeError injects path if necessary\n        // moreover, certain errors might point at the same spot, so filter them out to reduce noise\n        if (\"errors\" in err && Array.isArray(err.errors)) {\n            this.errors.push(...err.errors.map(errors_js_1.normalizeError).filter(({ footprint }) => !existingErrors.includes(footprint)));\n        }\n        else if (!(\"footprint\" in err) || !existingErrors.includes(err.footprint)) {\n            this.errors.push((0, errors_js_1.normalizeError)(err));\n        }\n    }\n    /**\n     * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @returns\n     */\n    exists(path, options) {\n        try {\n            this.resolve(path, options);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    /**\n     * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @returns - Returns the resolved value\n     */\n    get(path, options) {\n        return this.resolve(path, options)?.value;\n    }\n    /**\n     * Resolves the given JSON reference within this {@link $Ref#value}.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @param friendlyPath - The original user-specified path (used for error messages)\n     * @param pathFromRoot - The path of `obj` from the schema root\n     * @returns\n     */\n    resolve(path, options, friendlyPath, pathFromRoot) {\n        const pointer = new pointer_js_1.default(this, path, friendlyPath);\n        try {\n            const resolved = pointer.resolve(this.value, options, pathFromRoot);\n            if (resolved.value === pointer_js_1.nullSymbol) {\n                resolved.value = null;\n            }\n            return resolved;\n        }\n        catch (err) {\n            if (!options || !options.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n                throw err;\n            }\n            if (err.path === null) {\n                err.path = (0, url_js_1.safePointerToPath)((0, url_js_1.getHash)(pathFromRoot));\n            }\n            if (err instanceof errors_js_1.InvalidPointerError) {\n                err.source = decodeURI((0, url_js_1.stripHash)(pathFromRoot));\n            }\n            this.addError(err);\n            return null;\n        }\n    }\n    /**\n     * Sets the value of a nested property within this {@link $Ref#value}.\n     * If the property, or any of its parents don't exist, they will be created.\n     *\n     * @param path - The full path of the property to set, optionally with a JSON pointer in the hash\n     * @param value - The value to assign\n     */\n    set(path, value) {\n        const pointer = new pointer_js_1.default(this, path);\n        this.value = pointer.set(this.value, value);\n        if (this.value === pointer_js_1.nullSymbol) {\n            this.value = null;\n        }\n    }\n    /**\n     * Determines whether the given value is a JSON reference.\n     *\n     * @param value - The value to inspect\n     * @returns\n     */\n    static is$Ref(value) {\n        return (Boolean(value) &&\n            typeof value === \"object\" &&\n            value !== null &&\n            \"$ref\" in value &&\n            typeof value.$ref === \"string\" &&\n            value.$ref.length > 0);\n    }\n    /**\n     * Determines whether the given value is an external JSON reference.\n     *\n     * @param value - The value to inspect\n     * @returns\n     */\n    static isExternal$Ref(value) {\n        return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n    }\n    /**\n     * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n     * For example, if it references an external file, then options.resolve.external must be true.\n     *\n     * @param value - The value to inspect\n     * @param options\n     * @returns\n     */\n    static isAllowed$Ref(value, options) {\n        if (this.is$Ref(value)) {\n            if (value.$ref.substring(0, 2) === \"#/\" || value.$ref === \"#\") {\n                // It's a JSON Pointer reference, which is always allowed\n                return true;\n            }\n            else if (value.$ref[0] !== \"#\" && (!options || options.resolve?.external)) {\n                // It's an external reference, which is allowed by the options\n                return true;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n     * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n     * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n     * value, plus the extra properties.\n     *\n     * @example: {\n       person: {\n         properties: {\n           firstName: { type: string }\n           lastName: { type: string }\n         }\n       }\n       employee: {\n         properties: {\n           $ref: #/person/properties\n           salary: { type: number }\n         }\n       }\n     }\n     *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n     *  property (salary).  The result is a NEW value that looks like this:\n     *\n     *  {\n     *    properties: {\n     *      firstName: { type: string }\n     *      lastName: { type: string }\n     *      salary: { type: number }\n     *    }\n     *  }\n     *\n     * @param value - The value to inspect\n     * @returns\n     */\n    static isExtended$Ref(value) {\n        return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n    }\n    /**\n     * Returns the resolved value of a JSON Reference.\n     * If necessary, the resolved value is merged with the JSON Reference to create a new object\n     *\n     * @example: {\n    person: {\n      properties: {\n        firstName: { type: string }\n        lastName: { type: string }\n      }\n    }\n    employee: {\n      properties: {\n        $ref: #/person/properties\n        salary: { type: number }\n      }\n    }\n    } When \"person\" and \"employee\" are merged, you end up with the following object:\n     *\n     *  {\n     *    properties: {\n     *      firstName: { type: string }\n     *      lastName: { type: string }\n     *      salary: { type: number }\n     *    }\n     *  }\n     *\n     * @param $ref - The JSON reference object (the one with the \"$ref\" property)\n     * @param resolvedValue - The resolved value, which can be any type\n     * @returns - Returns the dereferenced value\n     */\n    static dereference($ref, resolvedValue) {\n        if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n            const merged = {};\n            for (const key of Object.keys($ref)) {\n                if (key !== \"$ref\") {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    merged[key] = $ref[key];\n                }\n            }\n            for (const key of Object.keys(resolvedValue)) {\n                if (!(key in merged)) {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    merged[key] = resolvedValue[key];\n                }\n            }\n            return merged;\n        }\n        else {\n            // Completely replace the original reference with the resolved value\n            return resolvedValue;\n        }\n    }\n}\nexports[\"default\"] = $Ref;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9yZWYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0NBQWtDLG1CQUFPLENBQUMsZ0tBQWM7QUFDeEQsb0JBQW9CLG1CQUFPLENBQUMsd0tBQWtCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLGtLQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixXQUFXO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpQkFBaUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVhLW9saXZlLXdlYi8uL25vZGVfbW9kdWxlcy8ucG5wbS9AYXBpZGV2dG9vbHMranNvbi1zY2hlbWEtcmVmLXBhcnNlckAxMS45LjMvbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3JlZi5qcz8wNjM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwb2ludGVyX2pzXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcG9pbnRlci5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvZXJyb3JzLmpzXCIpO1xuY29uc3QgdXJsX2pzXzEgPSByZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKTtcbi8qKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgc2luZ2xlIEpTT04gcmVmZXJlbmNlIGFuZCBpdHMgcmVzb2x2ZWQgdmFsdWUuXG4gKlxuICogQGNsYXNzXG4gKi9cbmNsYXNzICRSZWYge1xuICAgIGNvbnN0cnVjdG9yKCRyZWZzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGFsbCBlcnJvcnMuIFVuZGVmaW5lZCBpZiBubyBlcnJvcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLiRyZWZzID0gJHJlZnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhbiBlcnJvciB0byBlcnJvcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyIC0gVGhlIGVycm9yIHRvIGJlIHB1c2hlZFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYWRkRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRXJyb3JzID0gdGhpcy5lcnJvcnMubWFwKCh7IGZvb3RwcmludCB9KSA9PiBmb290cHJpbnQpO1xuICAgICAgICAvLyB0aGUgcGF0aCBoYXMgYmVlbiBhbG1vc3QgY2VydGFpbmx5IHNldCBhdCB0aGlzIHBvaW50LFxuICAgICAgICAvLyBidXQganVzdCBpbiBjYXNlIHNvbWV0aGluZyB3ZW50IHdyb25nLCBub3JtYWxpemVFcnJvciBpbmplY3RzIHBhdGggaWYgbmVjZXNzYXJ5XG4gICAgICAgIC8vIG1vcmVvdmVyLCBjZXJ0YWluIGVycm9ycyBtaWdodCBwb2ludCBhdCB0aGUgc2FtZSBzcG90LCBzbyBmaWx0ZXIgdGhlbSBvdXQgdG8gcmVkdWNlIG5vaXNlXG4gICAgICAgIGlmIChcImVycm9yc1wiIGluIGVyciAmJiBBcnJheS5pc0FycmF5KGVyci5lcnJvcnMpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKC4uLmVyci5lcnJvcnMubWFwKGVycm9yc19qc18xLm5vcm1hbGl6ZUVycm9yKS5maWx0ZXIoKHsgZm9vdHByaW50IH0pID0+ICFleGlzdGluZ0Vycm9ycy5pbmNsdWRlcyhmb290cHJpbnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShcImZvb3RwcmludFwiIGluIGVycikgfHwgIWV4aXN0aW5nRXJyb3JzLmluY2x1ZGVzKGVyci5mb290cHJpbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKCgwLCBlcnJvcnNfanNfMS5ub3JtYWxpemVFcnJvcikoZXJyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBKU09OIHJlZmVyZW5jZSBleGlzdHMgd2l0aGluIHRoaXMge0BsaW5rICRSZWYjdmFsdWV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIGJlaW5nIHJlc29sdmVkLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZXhpc3RzKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZShwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gSlNPTiByZWZlcmVuY2Ugd2l0aGluIHRoaXMge0BsaW5rICRSZWYjdmFsdWV9IGFuZCByZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBiZWluZyByZXNvbHZlZCwgb3B0aW9uYWxseSB3aXRoIGEgSlNPTiBwb2ludGVyIGluIHRoZSBoYXNoXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyAtIFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlXG4gICAgICovXG4gICAgZ2V0KHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZShwYXRoLCBvcHRpb25zKT8udmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBnaXZlbiBKU09OIHJlZmVyZW5jZSB3aXRoaW4gdGhpcyB7QGxpbmsgJFJlZiN2YWx1ZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmdWxsIHBhdGggYmVpbmcgcmVzb2x2ZWQsIG9wdGlvbmFsbHkgd2l0aCBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIGZyaWVuZGx5UGF0aCAtIFRoZSBvcmlnaW5hbCB1c2VyLXNwZWNpZmllZCBwYXRoICh1c2VkIGZvciBlcnJvciBtZXNzYWdlcylcbiAgICAgKiBAcGFyYW0gcGF0aEZyb21Sb290IC0gVGhlIHBhdGggb2YgYG9iamAgZnJvbSB0aGUgc2NoZW1hIHJvb3RcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlc29sdmUocGF0aCwgb3B0aW9ucywgZnJpZW5kbHlQYXRoLCBwYXRoRnJvbVJvb3QpIHtcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IG5ldyBwb2ludGVyX2pzXzEuZGVmYXVsdCh0aGlzLCBwYXRoLCBmcmllbmRseVBhdGgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBwb2ludGVyLnJlc29sdmUodGhpcy52YWx1ZSwgb3B0aW9ucywgcGF0aEZyb21Sb290KTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZC52YWx1ZSA9PT0gcG9pbnRlcl9qc18xLm51bGxTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZC52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmNvbnRpbnVlT25FcnJvciB8fCAhKDAsIGVycm9yc19qc18xLmlzSGFuZGxlZEVycm9yKShlcnIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyci5wYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXJyLnBhdGggPSAoMCwgdXJsX2pzXzEuc2FmZVBvaW50ZXJUb1BhdGgpKCgwLCB1cmxfanNfMS5nZXRIYXNoKShwYXRoRnJvbVJvb3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBlcnJvcnNfanNfMS5JbnZhbGlkUG9pbnRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyLnNvdXJjZSA9IGRlY29kZVVSSSgoMCwgdXJsX2pzXzEuc3RyaXBIYXNoKShwYXRoRnJvbVJvb3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGEgbmVzdGVkIHByb3BlcnR5IHdpdGhpbiB0aGlzIHtAbGluayAkUmVmI3ZhbHVlfS5cbiAgICAgKiBJZiB0aGUgcHJvcGVydHksIG9yIGFueSBvZiBpdHMgcGFyZW50cyBkb24ndCBleGlzdCwgdGhleSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmdWxsIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldCwgb3B0aW9uYWxseSB3aXRoIGEgSlNPTiBwb2ludGVyIGluIHRoZSBoYXNoXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFzc2lnblxuICAgICAqL1xuICAgIHNldChwYXRoLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBwb2ludGVyID0gbmV3IHBvaW50ZXJfanNfMS5kZWZhdWx0KHRoaXMsIHBhdGgpO1xuICAgICAgICB0aGlzLnZhbHVlID0gcG9pbnRlci5zZXQodGhpcy52YWx1ZSwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gcG9pbnRlcl9qc18xLm51bGxTeW1ib2wpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBKU09OIHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBpbnNwZWN0XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXMkUmVmKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoQm9vbGVhbih2YWx1ZSkgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIFwiJHJlZlwiIGluIHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUuJHJlZiA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgdmFsdWUuJHJlZi5sZW5ndGggPiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBleHRlcm5hbCBKU09OIHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBpbnNwZWN0XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFeHRlcm5hbCRSZWYodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICRSZWYuaXMkUmVmKHZhbHVlKSAmJiB2YWx1ZS4kcmVmWzBdICE9PSBcIiNcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIEpTT04gcmVmZXJlbmNlLCBhbmQgd2hldGhlciBpdCBpcyBhbGxvd2VkIGJ5IHRoZSBvcHRpb25zLlxuICAgICAqIEZvciBleGFtcGxlLCBpZiBpdCByZWZlcmVuY2VzIGFuIGV4dGVybmFsIGZpbGUsIHRoZW4gb3B0aW9ucy5yZXNvbHZlLmV4dGVybmFsIG11c3QgYmUgdHJ1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBpbnNwZWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBpc0FsbG93ZWQkUmVmKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmlzJFJlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS4kcmVmLnN1YnN0cmluZygwLCAyKSA9PT0gXCIjL1wiIHx8IHZhbHVlLiRyZWYgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIEpTT04gUG9pbnRlciByZWZlcmVuY2UsIHdoaWNoIGlzIGFsd2F5cyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS4kcmVmWzBdICE9PSBcIiNcIiAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5yZXNvbHZlPy5leHRlcm5hbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGFuIGV4dGVybmFsIHJlZmVyZW5jZSwgd2hpY2ggaXMgYWxsb3dlZCBieSB0aGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBKU09OIHJlZmVyZW5jZSB0aGF0IFwiZXh0ZW5kc1wiIGl0cyByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBUaGF0IGlzLCBpdCBoYXMgZXh0cmEgcHJvcGVydGllcyAoaW4gYWRkaXRpb24gdG8gXCIkcmVmXCIpLCBzbyByYXRoZXIgdGhhbiBzaW1wbHkgcG9pbnRpbmcgdG9cbiAgICAgKiBhbiBleGlzdGluZyB2YWx1ZSwgdGhpcyAkcmVmIGFjdHVhbGx5IGNyZWF0ZXMgYSBORVcgdmFsdWUgdGhhdCBpcyBhIHNoYWxsb3cgY29weSBvZiB0aGUgcmVzb2x2ZWRcbiAgICAgKiB2YWx1ZSwgcGx1cyB0aGUgZXh0cmEgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlOiB7XG4gICAgICAgcGVyc29uOiB7XG4gICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgIGZpcnN0TmFtZTogeyB0eXBlOiBzdHJpbmcgfVxuICAgICAgICAgICBsYXN0TmFtZTogeyB0eXBlOiBzdHJpbmcgfVxuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICBlbXBsb3llZToge1xuICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAkcmVmOiAjL3BlcnNvbi9wcm9wZXJ0aWVzXG4gICAgICAgICAgIHNhbGFyeTogeyB0eXBlOiBudW1iZXIgfVxuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfVxuICAgICAqICBJbiB0aGlzIGV4YW1wbGUsIFwiZW1wbG95ZWVcIiBpcyBhbiBleHRlbmRlZCAkcmVmLCBzaW5jZSBpdCBleHRlbmRzIFwicGVyc29uXCIgd2l0aCBhbiBhZGRpdGlvbmFsXG4gICAgICogIHByb3BlcnR5IChzYWxhcnkpLiAgVGhlIHJlc3VsdCBpcyBhIE5FVyB2YWx1ZSB0aGF0IGxvb2tzIGxpa2UgdGhpczpcbiAgICAgKlxuICAgICAqICB7XG4gICAgICogICAgcHJvcGVydGllczoge1xuICAgICAqICAgICAgZmlyc3ROYW1lOiB7IHR5cGU6IHN0cmluZyB9XG4gICAgICogICAgICBsYXN0TmFtZTogeyB0eXBlOiBzdHJpbmcgfVxuICAgICAqICAgICAgc2FsYXJ5OiB7IHR5cGU6IG51bWJlciB9XG4gICAgICogICAgfVxuICAgICAqICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gaW5zcGVjdFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGlzRXh0ZW5kZWQkUmVmKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAkUmVmLmlzJFJlZih2YWx1ZSkgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlIG9mIGEgSlNPTiBSZWZlcmVuY2UuXG4gICAgICogSWYgbmVjZXNzYXJ5LCB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgbWVyZ2VkIHdpdGggdGhlIEpTT04gUmVmZXJlbmNlIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBleGFtcGxlOiB7XG4gICAgcGVyc29uOiB7XG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGZpcnN0TmFtZTogeyB0eXBlOiBzdHJpbmcgfVxuICAgICAgICBsYXN0TmFtZTogeyB0eXBlOiBzdHJpbmcgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbXBsb3llZToge1xuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAkcmVmOiAjL3BlcnNvbi9wcm9wZXJ0aWVzXG4gICAgICAgIHNhbGFyeTogeyB0eXBlOiBudW1iZXIgfVxuICAgICAgfVxuICAgIH1cbiAgICB9IFdoZW4gXCJwZXJzb25cIiBhbmQgXCJlbXBsb3llZVwiIGFyZSBtZXJnZWQsIHlvdSBlbmQgdXAgd2l0aCB0aGUgZm9sbG93aW5nIG9iamVjdDpcbiAgICAgKlxuICAgICAqICB7XG4gICAgICogICAgcHJvcGVydGllczoge1xuICAgICAqICAgICAgZmlyc3ROYW1lOiB7IHR5cGU6IHN0cmluZyB9XG4gICAgICogICAgICBsYXN0TmFtZTogeyB0eXBlOiBzdHJpbmcgfVxuICAgICAqICAgICAgc2FsYXJ5OiB7IHR5cGU6IG51bWJlciB9XG4gICAgICogICAgfVxuICAgICAqICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHJlZiAtIFRoZSBKU09OIHJlZmVyZW5jZSBvYmplY3QgKHRoZSBvbmUgd2l0aCB0aGUgXCIkcmVmXCIgcHJvcGVydHkpXG4gICAgICogQHBhcmFtIHJlc29sdmVkVmFsdWUgLSBUaGUgcmVzb2x2ZWQgdmFsdWUsIHdoaWNoIGNhbiBiZSBhbnkgdHlwZVxuICAgICAqIEByZXR1cm5zIC0gUmV0dXJucyB0aGUgZGVyZWZlcmVuY2VkIHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGRlcmVmZXJlbmNlKCRyZWYsIHJlc29sdmVkVmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkVmFsdWUgJiYgdHlwZW9mIHJlc29sdmVkVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgJFJlZi5pc0V4dGVuZGVkJFJlZigkcmVmKSkge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cygkcmVmKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IFwiJHJlZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMoNzA1Myk6IEVsZW1lbnQgaW1wbGljaXRseSBoYXMgYW4gJ2FueScgdHlwZSBiZWNhdXNlIGV4cHJlLi4uIFJlbW92ZSB0aGlzIGNvbW1lbnQgdG8gc2VlIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSAkcmVmW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmVzb2x2ZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbWVyZ2VkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTKDcwNTMpOiBFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGUgYmVjYXVzZSBleHByZS4uLiBSZW1vdmUgdGhpcyBjb21tZW50IHRvIHNlZSB0aGUgZnVsbCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFtrZXldID0gcmVzb2x2ZWRWYWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDb21wbGV0ZWx5IHJlcGxhY2UgdGhlIG9yaWdpbmFsIHJlZmVyZW5jZSB3aXRoIHRoZSByZXNvbHZlZCB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSAkUmVmO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js ***!
  \*****************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/index.js\");\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst convert_path_to_posix_1 = __importDefault(__webpack_require__(/*! ./util/convert-path-to-posix */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js\"));\n/**\n * When you call the resolve method, the value that gets passed to the callback function (or Promise) is a $Refs object. This same object is accessible via the parser.$refs property of $RefParser objects.\n *\n * This object is a map of JSON References and their resolved values. It also has several convenient helper methods that make it easy for you to navigate and manipulate the JSON References.\n *\n * See https://apitools.dev/json-schema-ref-parser/docs/refs.html\n */\nclass $Refs {\n    /**\n     * Returns the paths/URLs of all the files in your schema (including the main schema file).\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#pathstypes\n     *\n     * @param types (optional) Optionally only return certain types of paths (\"file\", \"http\", etc.)\n     */\n    paths(...types) {\n        const paths = getPaths(this._$refs, types.flat());\n        return paths.map((path) => {\n            return (0, convert_path_to_posix_1.default)(path.decoded);\n        });\n    }\n    /**\n     * Returns a map of paths/URLs and their correspond values.\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#valuestypes\n     *\n     * @param types (optional) Optionally only return values from certain locations (\"file\", \"http\", etc.)\n     */\n    values(...types) {\n        const $refs = this._$refs;\n        const paths = getPaths($refs, types.flat());\n        return paths.reduce((obj, path) => {\n            obj[(0, convert_path_to_posix_1.default)(path.decoded)] = $refs[path.encoded].value;\n            return obj;\n        }, {});\n    }\n    /**\n     * Returns `true` if the given path exists in the schema; otherwise, returns `false`\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#existsref\n     *\n     * @param $ref The JSON Reference path, optionally with a JSON Pointer in the hash\n     */\n    /**\n     * Determines whether the given JSON reference exists.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @param [options]\n     * @returns\n     */\n    exists(path, options) {\n        try {\n            this._resolve(path, \"\", options);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    /**\n     * Resolves the given JSON reference and returns the resolved value.\n     *\n     * @param path - The path being resolved, with a JSON pointer in the hash\n     * @param [options]\n     * @returns - Returns the resolved value\n     */\n    get(path, options) {\n        return this._resolve(path, \"\", options).value;\n    }\n    /**\n     * Sets the value at the given path in the schema. If the property, or any of its parents, don't exist, they will be created.\n     *\n     * @param path The JSON Reference path, optionally with a JSON Pointer in the hash\n     * @param value The value to assign. Can be anything (object, string, number, etc.)\n     */\n    set(path, value) {\n        const absPath = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(absPath);\n        const $ref = this._$refs[withoutHash];\n        if (!$ref) {\n            throw (0, ono_1.ono)(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n        }\n        $ref.set(absPath, value);\n    }\n    /**\n     * Returns the specified {@link $Ref} object, or undefined.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @returns\n     * @protected\n     */\n    _get$Ref(path) {\n        path = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(path);\n        return this._$refs[withoutHash];\n    }\n    /**\n     * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\n     *\n     * @param path  - The file path or URL of the referenced file\n     */\n    _add(path) {\n        const withoutHash = url.stripHash(path);\n        const $ref = new ref_js_1.default(this);\n        $ref.path = withoutHash;\n        this._$refs[withoutHash] = $ref;\n        this._root$Ref = this._root$Ref || $ref;\n        return $ref;\n    }\n    /**\n     * Resolves the given JSON reference.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @param pathFromRoot - The path of `obj` from the schema root\n     * @param [options]\n     * @returns\n     * @protected\n     */\n    _resolve(path, pathFromRoot, options) {\n        const absPath = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(absPath);\n        const $ref = this._$refs[withoutHash];\n        if (!$ref) {\n            throw (0, ono_1.ono)(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n        }\n        return $ref.resolve(absPath, options, path, pathFromRoot);\n    }\n    constructor() {\n        /**\n         * A map of paths/urls to {@link $Ref} objects\n         *\n         * @type {object}\n         * @protected\n         */\n        this._$refs = {};\n        /**\n         * Returns the paths of all the files/URLs that are referenced by the JSON schema,\n         * including the schema itself.\n         *\n         * @param [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n         * @returns\n         */\n        /**\n         * Returns the map of JSON references and their resolved values.\n         *\n         * @param [types] - Only return references of the given types (\"file\", \"http\", etc.)\n         * @returns\n         */\n        /**\n         * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n         *\n         * @returns {object}\n         */\n        this.toJSON = this.values;\n        /**\n         * Indicates whether the schema contains any circular references.\n         *\n         * @type {boolean}\n         */\n        this.circular = false;\n        this._$refs = {};\n        // @ts-ignore\n        this._root$Ref = null;\n    }\n}\nexports[\"default\"] = $Refs;\n/**\n * Returns the encoded and decoded paths keys of the given object.\n *\n * @param $refs - The object whose keys are URL-encoded paths\n * @param [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns\n */\nfunction getPaths($refs, types) {\n    let paths = Object.keys($refs);\n    // Filter the paths by type\n    types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n    if (types.length > 0 && types[0]) {\n        paths = paths.filter((key) => {\n            return types.includes($refs[key].pathType);\n        });\n    }\n    // Decode local filesystem paths\n    return paths.map((path) => {\n        return {\n            encoded: path,\n            decoded: $refs[path].pathType === \"file\" ? url.toFileSystemPath(path, true) : path,\n        };\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9yZWZzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxtQkFBTyxDQUFDLG1IQUFpQjtBQUN2QyxpQ0FBaUMsbUJBQU8sQ0FBQyx3SkFBVTtBQUNuRCx5QkFBeUIsbUJBQU8sQ0FBQyxrS0FBZTtBQUNoRCxnREFBZ0QsbUJBQU8sQ0FBQyxtTUFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEtBQUssUUFBUSxZQUFZO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZLDRCQUE0QixhQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEtBQUssUUFBUSxZQUFZO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVhLW9saXZlLXdlYi8uL25vZGVfbW9kdWxlcy8ucG5wbS9AYXBpZGV2dG9vbHMranNvbi1zY2hlbWEtcmVmLXBhcnNlckAxMS45LjMvbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3JlZnMuanM/M2FiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgb25vXzEgPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3QgcmVmX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVmLmpzXCIpKTtcbmNvbnN0IHVybCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBjb252ZXJ0X3BhdGhfdG9fcG9zaXhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2NvbnZlcnQtcGF0aC10by1wb3NpeFwiKSk7XG4vKipcbiAqIFdoZW4geW91IGNhbGwgdGhlIHJlc29sdmUgbWV0aG9kLCB0aGUgdmFsdWUgdGhhdCBnZXRzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKG9yIFByb21pc2UpIGlzIGEgJFJlZnMgb2JqZWN0LiBUaGlzIHNhbWUgb2JqZWN0IGlzIGFjY2Vzc2libGUgdmlhIHRoZSBwYXJzZXIuJHJlZnMgcHJvcGVydHkgb2YgJFJlZlBhcnNlciBvYmplY3RzLlxuICpcbiAqIFRoaXMgb2JqZWN0IGlzIGEgbWFwIG9mIEpTT04gUmVmZXJlbmNlcyBhbmQgdGhlaXIgcmVzb2x2ZWQgdmFsdWVzLiBJdCBhbHNvIGhhcyBzZXZlcmFsIGNvbnZlbmllbnQgaGVscGVyIG1ldGhvZHMgdGhhdCBtYWtlIGl0IGVhc3kgZm9yIHlvdSB0byBuYXZpZ2F0ZSBhbmQgbWFuaXB1bGF0ZSB0aGUgSlNPTiBSZWZlcmVuY2VzLlxuICpcbiAqIFNlZSBodHRwczovL2FwaXRvb2xzLmRldi9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2RvY3MvcmVmcy5odG1sXG4gKi9cbmNsYXNzICRSZWZzIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXRocy9VUkxzIG9mIGFsbCB0aGUgZmlsZXMgaW4geW91ciBzY2hlbWEgKGluY2x1ZGluZyB0aGUgbWFpbiBzY2hlbWEgZmlsZSkuXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9hcGl0b29scy5kZXYvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kb2NzL3JlZnMuaHRtbCNwYXRoc3R5cGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZXMgKG9wdGlvbmFsKSBPcHRpb25hbGx5IG9ubHkgcmV0dXJuIGNlcnRhaW4gdHlwZXMgb2YgcGF0aHMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAgICAgKi9cbiAgICBwYXRocyguLi50eXBlcykge1xuICAgICAgICBjb25zdCBwYXRocyA9IGdldFBhdGhzKHRoaXMuXyRyZWZzLCB0eXBlcy5mbGF0KCkpO1xuICAgICAgICByZXR1cm4gcGF0aHMubWFwKChwYXRoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvbnZlcnRfcGF0aF90b19wb3NpeF8xLmRlZmF1bHQpKHBhdGguZGVjb2RlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWFwIG9mIHBhdGhzL1VSTHMgYW5kIHRoZWlyIGNvcnJlc3BvbmQgdmFsdWVzLlxuICAgICAqXG4gICAgICogU2VlIGh0dHBzOi8vYXBpdG9vbHMuZGV2L2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZG9jcy9yZWZzLmh0bWwjdmFsdWVzdHlwZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlcyAob3B0aW9uYWwpIE9wdGlvbmFsbHkgb25seSByZXR1cm4gdmFsdWVzIGZyb20gY2VydGFpbiBsb2NhdGlvbnMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAgICAgKi9cbiAgICB2YWx1ZXMoLi4udHlwZXMpIHtcbiAgICAgICAgY29uc3QgJHJlZnMgPSB0aGlzLl8kcmVmcztcbiAgICAgICAgY29uc3QgcGF0aHMgPSBnZXRQYXRocygkcmVmcywgdHlwZXMuZmxhdCgpKTtcbiAgICAgICAgcmV0dXJuIHBhdGhzLnJlZHVjZSgob2JqLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICBvYmpbKDAsIGNvbnZlcnRfcGF0aF90b19wb3NpeF8xLmRlZmF1bHQpKHBhdGguZGVjb2RlZCldID0gJHJlZnNbcGF0aC5lbmNvZGVkXS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBhdGggZXhpc3RzIGluIHRoZSBzY2hlbWE7IG90aGVyd2lzZSwgcmV0dXJucyBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9hcGl0b29scy5kZXYvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kb2NzL3JlZnMuaHRtbCNleGlzdHNyZWZcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkcmVmIFRoZSBKU09OIFJlZmVyZW5jZSBwYXRoLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIFBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIEpTT04gcmVmZXJlbmNlIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggYmVpbmcgcmVzb2x2ZWQsIG9wdGlvbmFsbHkgd2l0aCBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaFxuICAgICAqIEBwYXJhbSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGV4aXN0cyhwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHBhdGgsIFwiXCIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBnaXZlbiBKU09OIHJlZmVyZW5jZSBhbmQgcmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIGJlaW5nIHJlc29sdmVkLCB3aXRoIGEgSlNPTiBwb2ludGVyIGluIHRoZSBoYXNoXG4gICAgICogQHBhcmFtIFtvcHRpb25zXVxuICAgICAqIEByZXR1cm5zIC0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShwYXRoLCBcIlwiLCBvcHRpb25zKS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBhdGggaW4gdGhlIHNjaGVtYS4gSWYgdGhlIHByb3BlcnR5LCBvciBhbnkgb2YgaXRzIHBhcmVudHMsIGRvbid0IGV4aXN0LCB0aGV5IHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBKU09OIFJlZmVyZW5jZSBwYXRoLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIFBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi4gQ2FuIGJlIGFueXRoaW5nIChvYmplY3QsIHN0cmluZywgbnVtYmVyLCBldGMuKVxuICAgICAqL1xuICAgIHNldChwYXRoLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBhYnNQYXRoID0gdXJsLnJlc29sdmUodGhpcy5fcm9vdCRSZWYucGF0aCwgcGF0aCk7XG4gICAgICAgIGNvbnN0IHdpdGhvdXRIYXNoID0gdXJsLnN0cmlwSGFzaChhYnNQYXRoKTtcbiAgICAgICAgY29uc3QgJHJlZiA9IHRoaXMuXyRyZWZzW3dpdGhvdXRIYXNoXTtcbiAgICAgICAgaWYgKCEkcmVmKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgb25vXzEub25vKShgRXJyb3IgcmVzb2x2aW5nICRyZWYgcG9pbnRlciBcIiR7cGF0aH1cIi4gXFxuXCIke3dpdGhvdXRIYXNofVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICAkcmVmLnNldChhYnNQYXRoLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCB7QGxpbmsgJFJlZn0gb2JqZWN0LCBvciB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIGJlaW5nIHJlc29sdmVkLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZ2V0JFJlZihwYXRoKSB7XG4gICAgICAgIHBhdGggPSB1cmwucmVzb2x2ZSh0aGlzLl9yb290JFJlZi5wYXRoLCBwYXRoKTtcbiAgICAgICAgY29uc3Qgd2l0aG91dEhhc2ggPSB1cmwuc3RyaXBIYXNoKHBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fJHJlZnNbd2l0aG91dEhhc2hdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayAkUmVmfSBvYmplY3QgYW5kIGFkZHMgaXQgdG8gdGhpcyB7QGxpbmsgJFJlZnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoICAtIFRoZSBmaWxlIHBhdGggb3IgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICAgKi9cbiAgICBfYWRkKHBhdGgpIHtcbiAgICAgICAgY29uc3Qgd2l0aG91dEhhc2ggPSB1cmwuc3RyaXBIYXNoKHBhdGgpO1xuICAgICAgICBjb25zdCAkcmVmID0gbmV3IHJlZl9qc18xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgICRyZWYucGF0aCA9IHdpdGhvdXRIYXNoO1xuICAgICAgICB0aGlzLl8kcmVmc1t3aXRob3V0SGFzaF0gPSAkcmVmO1xuICAgICAgICB0aGlzLl9yb290JFJlZiA9IHRoaXMuX3Jvb3QkUmVmIHx8ICRyZWY7XG4gICAgICAgIHJldHVybiAkcmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gSlNPTiByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIGJlaW5nIHJlc29sdmVkLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0gcGF0aEZyb21Sb290IC0gVGhlIHBhdGggb2YgYG9iamAgZnJvbSB0aGUgc2NoZW1hIHJvb3RcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdXG4gICAgICogQHJldHVybnNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Jlc29sdmUocGF0aCwgcGF0aEZyb21Sb290LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFic1BhdGggPSB1cmwucmVzb2x2ZSh0aGlzLl9yb290JFJlZi5wYXRoLCBwYXRoKTtcbiAgICAgICAgY29uc3Qgd2l0aG91dEhhc2ggPSB1cmwuc3RyaXBIYXNoKGFic1BhdGgpO1xuICAgICAgICBjb25zdCAkcmVmID0gdGhpcy5fJHJlZnNbd2l0aG91dEhhc2hdO1xuICAgICAgICBpZiAoISRyZWYpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBvbm9fMS5vbm8pKGBFcnJvciByZXNvbHZpbmcgJHJlZiBwb2ludGVyIFwiJHtwYXRofVwiLiBcXG5cIiR7d2l0aG91dEhhc2h9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcmVmLnJlc29sdmUoYWJzUGF0aCwgb3B0aW9ucywgcGF0aCwgcGF0aEZyb21Sb290KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiBwYXRocy91cmxzIHRvIHtAbGluayAkUmVmfSBvYmplY3RzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuXyRyZWZzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwYXRocyBvZiBhbGwgdGhlIGZpbGVzL1VSTHMgdGhhdCBhcmUgcmVmZXJlbmNlZCBieSB0aGUgSlNPTiBzY2hlbWEsXG4gICAgICAgICAqIGluY2x1ZGluZyB0aGUgc2NoZW1hIGl0c2VsZi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIFt0eXBlc10gLSBPbmx5IHJldHVybiBwYXRocyBvZiB0aGUgZ2l2ZW4gdHlwZXMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtYXAgb2YgSlNPTiByZWZlcmVuY2VzIGFuZCB0aGVpciByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBbdHlwZXNdIC0gT25seSByZXR1cm4gcmVmZXJlbmNlcyBvZiB0aGUgZ2l2ZW4gdHlwZXMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgUE9KTyAocGxhaW4gb2xkIEphdmFTY3JpcHQgb2JqZWN0KSBmb3Igc2VyaWFsaXphdGlvbiBhcyBKU09OLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b0pTT04gPSB0aGlzLnZhbHVlcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzY2hlbWEgY29udGFpbnMgYW55IGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaXJjdWxhciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl8kcmVmcyA9IHt9O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuX3Jvb3QkUmVmID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSAkUmVmcztcbi8qKlxuICogUmV0dXJucyB0aGUgZW5jb2RlZCBhbmQgZGVjb2RlZCBwYXRocyBrZXlzIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtICRyZWZzIC0gVGhlIG9iamVjdCB3aG9zZSBrZXlzIGFyZSBVUkwtZW5jb2RlZCBwYXRoc1xuICogQHBhcmFtIFt0eXBlc10gLSBPbmx5IHJldHVybiBwYXRocyBvZiB0aGUgZ2l2ZW4gdHlwZXMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhzKCRyZWZzLCB0eXBlcykge1xuICAgIGxldCBwYXRocyA9IE9iamVjdC5rZXlzKCRyZWZzKTtcbiAgICAvLyBGaWx0ZXIgdGhlIHBhdGhzIGJ5IHR5cGVcbiAgICB0eXBlcyA9IEFycmF5LmlzQXJyYXkodHlwZXNbMF0pID8gdHlwZXNbMF0gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0eXBlcyk7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCA+IDAgJiYgdHlwZXNbMF0pIHtcbiAgICAgICAgcGF0aHMgPSBwYXRocy5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVzLmluY2x1ZGVzKCRyZWZzW2tleV0ucGF0aFR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gRGVjb2RlIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHNcbiAgICByZXR1cm4gcGF0aHMubWFwKChwYXRoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmNvZGVkOiBwYXRoLFxuICAgICAgICAgICAgZGVjb2RlZDogJHJlZnNbcGF0aF0ucGF0aFR5cGUgPT09IFwiZmlsZVwiID8gdXJsLnRvRmlsZVN5c3RlbVBhdGgocGF0aCwgdHJ1ZSkgOiBwYXRoLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js ***!
  \*****************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst pointer_js_1 = __importDefault(__webpack_require__(/*! ./pointer.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst parse_js_1 = __importDefault(__webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @returns\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nfunction resolveExternal(parser, options) {\n    if (!options.resolve?.external) {\n        // Nothing to resolve, so exit early\n        return Promise.resolve();\n    }\n    try {\n        // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n        const promises = crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n        return Promise.all(promises);\n    }\n    catch (e) {\n        return Promise.reject(e);\n    }\n}\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {boolean} external - Whether `obj` was found in an external document.\n * @param $refs\n * @param options\n * @param seen - Internal.\n *\n * @returns\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\nfunction crawl(obj, path, $refs, options, seen, external) {\n    seen || (seen = new Set());\n    let promises = [];\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {\n        seen.add(obj); // Track previously seen objects to avoid infinite recursion\n        if (ref_js_1.default.isExternal$Ref(obj)) {\n            promises.push(resolve$Ref(obj, path, $refs, options));\n        }\n        const keys = Object.keys(obj);\n        for (const key of keys) {\n            const keyPath = pointer_js_1.default.join(path, key);\n            const value = obj[key];\n            promises = promises.concat(crawl(value, keyPath, $refs, options, seen, external));\n        }\n    }\n    return promises;\n}\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param $ref - The JSON Reference to resolve\n * @param path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param $refs\n * @param options\n *\n * @returns\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nasync function resolve$Ref($ref, path, $refs, options) {\n    const shouldResolveOnCwd = options.dereference?.externalReferenceResolution === \"root\";\n    const resolvedPath = url.resolve(shouldResolveOnCwd ? url.cwd() : path, $ref.$ref);\n    const withoutHash = url.stripHash(resolvedPath);\n    // $ref.$ref = url.relative($refs._root$Ref.path, resolvedPath);\n    // Do we already have this $ref?\n    const ref = $refs._$refs[withoutHash];\n    if (ref) {\n        // We've already parsed this $ref, so use the existing value\n        return Promise.resolve(ref.value);\n    }\n    // Parse the $referenced file/url\n    try {\n        const result = await (0, parse_js_1.default)(resolvedPath, $refs, options);\n        // Crawl the parsed value\n        // console.log('Resolving $ref pointers in %s', withoutHash);\n        const promises = crawl(result, withoutHash + \"#\", $refs, options, new Set(), true);\n        return Promise.all(promises);\n    }\n    catch (err) {\n        if (!options?.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n            throw err;\n        }\n        if ($refs._$refs[withoutHash]) {\n            err.source = decodeURI(url.stripHash(path));\n            err.path = url.safePointerToPath(url.getHash(path));\n        }\n        return [];\n    }\n}\nexports[\"default\"] = resolveExternal;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9yZXNvbHZlLWV4dGVybmFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMsd0pBQVU7QUFDbkQscUNBQXFDLG1CQUFPLENBQUMsZ0tBQWM7QUFDM0QsbUNBQW1DLG1CQUFPLENBQUMsNEpBQVk7QUFDdkQseUJBQXlCLG1CQUFPLENBQUMsa0tBQWU7QUFDaEQsb0JBQW9CLG1CQUFPLENBQUMsd0tBQWtCO0FBQzlDO0FBQ0E7QUFDQSxrRkFBa0YsdUJBQXVCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlYS1vbGl2ZS13ZWIvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9yZXNvbHZlLWV4dGVybmFsLmpzP2JhNWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlZi5qc1wiKSk7XG5jb25zdCBwb2ludGVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9pbnRlci5qc1wiKSk7XG5jb25zdCBwYXJzZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcbmNvbnN0IHVybCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvZXJyb3JzLmpzXCIpO1xuLyoqXG4gKiBDcmF3bHMgdGhlIEpTT04gc2NoZW1hLCBmaW5kcyBhbGwgZXh0ZXJuYWwgSlNPTiByZWZlcmVuY2VzLCBhbmQgcmVzb2x2ZXMgdGhlaXIgdmFsdWVzLlxuICogVGhpcyBtZXRob2QgZG9lcyBub3QgbXV0YXRlIHRoZSBKU09OIHNjaGVtYS4gVGhlIHJlc29sdmVkIHZhbHVlcyBhcmUgYWRkZWQgdG8ge0BsaW5rICRSZWZQYXJzZXIjJHJlZnN9LlxuICpcbiAqIE5PVEU6IFdlIG9ubHkgY2FyZSBhYm91dCBFWFRFUk5BTCByZWZlcmVuY2VzIGhlcmUuIElOVEVSTkFMIHJlZmVyZW5jZXMgYXJlIG9ubHkgcmVsZXZhbnQgd2hlbiBkZXJlZmVyZW5jaW5nLlxuICpcbiAqIEByZXR1cm5zXG4gKiBUaGUgcHJvbWlzZSByZXNvbHZlcyBvbmNlIGFsbCBKU09OIHJlZmVyZW5jZXMgaW4gdGhlIHNjaGVtYSBoYXZlIGJlZW4gcmVzb2x2ZWQsXG4gKiBpbmNsdWRpbmcgbmVzdGVkIHJlZmVyZW5jZXMgdGhhdCBhcmUgY29udGFpbmVkIGluIGV4dGVybmFsbHktcmVmZXJlbmNlZCBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUV4dGVybmFsKHBhcnNlciwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5yZXNvbHZlPy5leHRlcm5hbCkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIHJlc29sdmUsIHNvIGV4aXQgZWFybHlcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnUmVzb2x2aW5nICRyZWYgcG9pbnRlcnMgaW4gJXMnLCBwYXJzZXIuJHJlZnMuX3Jvb3QkUmVmLnBhdGgpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IGNyYXdsKHBhcnNlci5zY2hlbWEsIHBhcnNlci4kcmVmcy5fcm9vdCRSZWYucGF0aCArIFwiI1wiLCBwYXJzZXIuJHJlZnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWN1cnNpdmVseSBjcmF3bHMgdGhlIGdpdmVuIHZhbHVlLCBhbmQgcmVzb2x2ZXMgYW55IGV4dGVybmFsIEpTT04gcmVmZXJlbmNlcy5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gVGhlIHZhbHVlIHRvIGNyYXdsLiBJZiBpdCdzIG5vdCBhbiBvYmplY3Qgb3IgYXJyYXksIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiBgb2JqYCwgcG9zc2libHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtIHtib29sZWFufSBleHRlcm5hbCAtIFdoZXRoZXIgYG9iamAgd2FzIGZvdW5kIGluIGFuIGV4dGVybmFsIGRvY3VtZW50LlxuICogQHBhcmFtICRyZWZzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIHNlZW4gLSBJbnRlcm5hbC5cbiAqXG4gKiBAcmV0dXJuc1xuICogUmV0dXJucyBhbiBhcnJheSBvZiBwcm9taXNlcy4gVGhlcmUgd2lsbCBiZSBvbmUgcHJvbWlzZSBmb3IgZWFjaCBKU09OIHJlZmVyZW5jZSBpbiBgb2JqYC5cbiAqIElmIGBvYmpgIGRvZXMgbm90IGNvbnRhaW4gYW55IEpTT04gcmVmZXJlbmNlcywgdGhlbiB0aGUgYXJyYXkgd2lsbCBiZSBlbXB0eS5cbiAqIElmIGFueSBvZiB0aGUgSlNPTiByZWZlcmVuY2VzIHBvaW50IHRvIGZpbGVzIHRoYXQgY29udGFpbiBhZGRpdGlvbmFsIEpTT04gcmVmZXJlbmNlcyxcbiAqIHRoZW4gdGhlIGNvcnJlc3BvbmRpbmcgcHJvbWlzZSB3aWxsIGludGVybmFsbHkgcmVmZXJlbmNlIGFuIGFycmF5IG9mIHByb21pc2VzLlxuICovXG5mdW5jdGlvbiBjcmF3bChvYmosIHBhdGgsICRyZWZzLCBvcHRpb25zLCBzZWVuLCBleHRlcm5hbCkge1xuICAgIHNlZW4gfHwgKHNlZW4gPSBuZXcgU2V0KCkpO1xuICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgJiYgIXNlZW4uaGFzKG9iaikpIHtcbiAgICAgICAgc2Vlbi5hZGQob2JqKTsgLy8gVHJhY2sgcHJldmlvdXNseSBzZWVuIG9iamVjdHMgdG8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIGlmIChyZWZfanNfMS5kZWZhdWx0LmlzRXh0ZXJuYWwkUmVmKG9iaikpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocmVzb2x2ZSRSZWYob2JqLCBwYXRoLCAkcmVmcywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlQYXRoID0gcG9pbnRlcl9qc18xLmRlZmF1bHQuam9pbihwYXRoLCBrZXkpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIHByb21pc2VzID0gcHJvbWlzZXMuY29uY2F0KGNyYXdsKHZhbHVlLCBrZXlQYXRoLCAkcmVmcywgb3B0aW9ucywgc2VlbiwgZXh0ZXJuYWwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZXM7XG59XG4vKipcbiAqIFJlc29sdmVzIHRoZSBnaXZlbiBKU09OIFJlZmVyZW5jZSwgYW5kIHRoZW4gY3Jhd2xzIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKlxuICogQHBhcmFtICRyZWYgLSBUaGUgSlNPTiBSZWZlcmVuY2UgdG8gcmVzb2x2ZVxuICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIG9mIGAkcmVmYCwgcG9zc2libHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtICRyZWZzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zXG4gKiBUaGUgcHJvbWlzZSByZXNvbHZlcyBvbmNlIGFsbCBKU09OIHJlZmVyZW5jZXMgaW4gdGhlIG9iamVjdCBoYXZlIGJlZW4gcmVzb2x2ZWQsXG4gKiBpbmNsdWRpbmcgbmVzdGVkIHJlZmVyZW5jZXMgdGhhdCBhcmUgY29udGFpbmVkIGluIGV4dGVybmFsbHktcmVmZXJlbmNlZCBmaWxlcy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZSRSZWYoJHJlZiwgcGF0aCwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzaG91bGRSZXNvbHZlT25Dd2QgPSBvcHRpb25zLmRlcmVmZXJlbmNlPy5leHRlcm5hbFJlZmVyZW5jZVJlc29sdXRpb24gPT09IFwicm9vdFwiO1xuICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IHVybC5yZXNvbHZlKHNob3VsZFJlc29sdmVPbkN3ZCA/IHVybC5jd2QoKSA6IHBhdGgsICRyZWYuJHJlZik7XG4gICAgY29uc3Qgd2l0aG91dEhhc2ggPSB1cmwuc3RyaXBIYXNoKHJlc29sdmVkUGF0aCk7XG4gICAgLy8gJHJlZi4kcmVmID0gdXJsLnJlbGF0aXZlKCRyZWZzLl9yb290JFJlZi5wYXRoLCByZXNvbHZlZFBhdGgpO1xuICAgIC8vIERvIHdlIGFscmVhZHkgaGF2ZSB0aGlzICRyZWY/XG4gICAgY29uc3QgcmVmID0gJHJlZnMuXyRyZWZzW3dpdGhvdXRIYXNoXTtcbiAgICBpZiAocmVmKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgcGFyc2VkIHRoaXMgJHJlZiwgc28gdXNlIHRoZSBleGlzdGluZyB2YWx1ZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlZi52YWx1ZSk7XG4gICAgfVxuICAgIC8vIFBhcnNlIHRoZSAkcmVmZXJlbmNlZCBmaWxlL3VybFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICgwLCBwYXJzZV9qc18xLmRlZmF1bHQpKHJlc29sdmVkUGF0aCwgJHJlZnMsIG9wdGlvbnMpO1xuICAgICAgICAvLyBDcmF3bCB0aGUgcGFyc2VkIHZhbHVlXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdSZXNvbHZpbmcgJHJlZiBwb2ludGVycyBpbiAlcycsIHdpdGhvdXRIYXNoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBjcmF3bChyZXN1bHQsIHdpdGhvdXRIYXNoICsgXCIjXCIsICRyZWZzLCBvcHRpb25zLCBuZXcgU2V0KCksIHRydWUpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghb3B0aW9ucz8uY29udGludWVPbkVycm9yIHx8ICEoMCwgZXJyb3JzX2pzXzEuaXNIYW5kbGVkRXJyb3IpKGVycikpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJHJlZnMuXyRyZWZzW3dpdGhvdXRIYXNoXSkge1xuICAgICAgICAgICAgZXJyLnNvdXJjZSA9IGRlY29kZVVSSSh1cmwuc3RyaXBIYXNoKHBhdGgpKTtcbiAgICAgICAgICAgIGVyci5wYXRoID0gdXJsLnNhZmVQb2ludGVyVG9QYXRoKHVybC5nZXRIYXNoKHBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gcmVzb2x2ZUV4dGVybmFsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ../util/url.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this resolver will run, in relation to other resolvers.\n     */\n    order: 100,\n    /**\n     * Determines whether this resolver can read a given file reference.\n     * Resolvers that return true will be tried, in order, until one successfully resolves the file.\n     * Resolvers that return false will not be given a chance to resolve the file.\n     */\n    canRead(file) {\n        return url.isFileSystemPath(file.url);\n    },\n    /**\n     * Reads the given file and returns its raw contents as a Buffer.\n     */\n    async read(file) {\n        let path;\n        try {\n            path = url.toFileSystemPath(file.url);\n        }\n        catch (err) {\n            throw new errors_js_1.ResolverError(ono_1.ono.uri(err, `Malformed URI: ${file.url}`), file.url);\n        }\n        try {\n            return await fs_1.default.promises.readFile(path);\n        }\n        catch (err) {\n            throw new errors_js_1.ResolverError((0, ono_1.ono)(err, `Error opening file \"${path}\"`), path);\n        }\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9yZXNvbHZlcnMvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixtQkFBTyxDQUFDLGNBQUk7QUFDekMsY0FBYyxtQkFBTyxDQUFDLG1IQUFpQjtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyxtS0FBZ0I7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMseUtBQW1CO0FBQy9DLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsU0FBUztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLEtBQUs7QUFDaEc7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWEtb2xpdmUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhcGlkZXZ0b29scytqc29uLXNjaGVtYS1yZWYtcGFyc2VyQDExLjkuMy9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVzb2x2ZXJzL2ZpbGUuanM/MmM1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZnNcIikpO1xuY29uc3Qgb25vXzEgPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3QgdXJsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9ycy5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JkZXIgdGhhdCB0aGlzIHJlc29sdmVyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciByZXNvbHZlcnMuXG4gICAgICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyByZXNvbHZlciBjYW4gcmVhZCBhIGdpdmVuIGZpbGUgcmVmZXJlbmNlLlxuICAgICAqIFJlc29sdmVycyB0aGF0IHJldHVybiB0cnVlIHdpbGwgYmUgdHJpZWQsIGluIG9yZGVyLCB1bnRpbCBvbmUgc3VjY2Vzc2Z1bGx5IHJlc29sdmVzIHRoZSBmaWxlLlxuICAgICAqIFJlc29sdmVycyB0aGF0IHJldHVybiBmYWxzZSB3aWxsIG5vdCBiZSBnaXZlbiBhIGNoYW5jZSB0byByZXNvbHZlIHRoZSBmaWxlLlxuICAgICAqL1xuICAgIGNhblJlYWQoZmlsZSkge1xuICAgICAgICByZXR1cm4gdXJsLmlzRmlsZVN5c3RlbVBhdGgoZmlsZS51cmwpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGdpdmVuIGZpbGUgYW5kIHJldHVybnMgaXRzIHJhdyBjb250ZW50cyBhcyBhIEJ1ZmZlci5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkKGZpbGUpIHtcbiAgICAgICAgbGV0IHBhdGg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXRoID0gdXJsLnRvRmlsZVN5c3RlbVBhdGgoZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5SZXNvbHZlckVycm9yKG9ub18xLm9uby51cmkoZXJyLCBgTWFsZm9ybWVkIFVSSTogJHtmaWxlLnVybH1gKSwgZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZnNfMS5kZWZhdWx0LnByb21pc2VzLnJlYWRGaWxlKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5SZXNvbHZlckVycm9yKCgwLCBvbm9fMS5vbm8pKGVyciwgYEVycm9yIG9wZW5pbmcgZmlsZSBcIiR7cGF0aH1cImApLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ../util/url.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this resolver will run, in relation to other resolvers.\n     */\n    order: 200,\n    /**\n     * HTTP headers to send when downloading files.\n     *\n     * @example:\n     * {\n     *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n     *   Accept: \"application/json\"\n     * }\n     */\n    headers: null,\n    /**\n     * HTTP request timeout (in milliseconds).\n     */\n    timeout: 60000, // 60 seconds\n    /**\n     * The maximum number of HTTP redirects to follow.\n     * To disable automatic following of redirects, set this to zero.\n     */\n    redirects: 5,\n    /**\n     * The `withCredentials` option of XMLHttpRequest.\n     * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n     */\n    withCredentials: false,\n    /**\n     * Determines whether this resolver can read a given file reference.\n     * Resolvers that return true will be tried in order, until one successfully resolves the file.\n     * Resolvers that return false will not be given a chance to resolve the file.\n     */\n    canRead(file) {\n        return url.isHttp(file.url);\n    },\n    /**\n     * Reads the given URL and returns its raw contents as a Buffer.\n     */\n    read(file) {\n        const u = url.parse(file.url);\n        if (typeof window !== \"undefined\" && !u.protocol) {\n            // Use the protocol of the current page\n            u.protocol = url.parse(location.href).protocol;\n        }\n        return download(u, this);\n    },\n};\n/**\n * Downloads the given file.\n * @returns\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\nasync function download(u, httpOptions, _redirects) {\n    u = url.parse(u);\n    const redirects = _redirects || [];\n    redirects.push(u.href);\n    try {\n        const res = await get(u, httpOptions);\n        if (res.status >= 400) {\n            throw (0, ono_1.ono)({ status: res.status }, `HTTP ERROR ${res.status}`);\n        }\n        else if (res.status >= 300) {\n            if (!Number.isNaN(httpOptions.redirects) && redirects.length > httpOptions.redirects) {\n                throw new errors_js_1.ResolverError((0, ono_1.ono)({ status: res.status }, `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(\" \\n  \")}`));\n            }\n            else if (!(\"location\" in res.headers) || !res.headers.location) {\n                throw (0, ono_1.ono)({ status: res.status }, `HTTP ${res.status} redirect with no location header`);\n            }\n            else {\n                const redirectTo = url.resolve(u.href, res.headers.location);\n                return download(redirectTo, httpOptions, redirects);\n            }\n        }\n        else {\n            if (res.body) {\n                const buf = await res.arrayBuffer();\n                return Buffer.from(buf);\n            }\n            return Buffer.alloc(0);\n        }\n    }\n    catch (err) {\n        throw new errors_js_1.ResolverError((0, ono_1.ono)(err, `Error downloading ${u.href}`), u.href);\n    }\n}\n/**\n * Sends an HTTP GET request.\n * The promise resolves with the HTTP Response object.\n */\nasync function get(u, httpOptions) {\n    let controller;\n    let timeoutId;\n    if (httpOptions.timeout) {\n        controller = new AbortController();\n        timeoutId = setTimeout(() => controller.abort(), httpOptions.timeout);\n    }\n    const response = await fetch(u, {\n        method: \"GET\",\n        headers: httpOptions.headers || {},\n        credentials: httpOptions.withCredentials ? \"include\" : \"same-origin\",\n        signal: controller ? controller.signal : null,\n    });\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n    return response;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9yZXNvbHZlcnMvaHR0cC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLG1CQUFPLENBQUMsbUhBQWlCO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLG1LQUFnQjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyx5S0FBbUI7QUFDL0Msa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9CQUFvQixnQkFBZ0IsV0FBVztBQUNsRjtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsb0JBQW9CLHVCQUF1QixhQUFhLDhCQUE4Qix3QkFBd0I7QUFDbkw7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0IsVUFBVSxZQUFZO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixPQUFPO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWEtb2xpdmUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhcGlkZXZ0b29scytqc29uLXNjaGVtYS1yZWYtcGFyc2VyQDExLjkuMy9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVzb2x2ZXJzL2h0dHAuanM/NmIwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgb25vXzEgPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3QgdXJsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9ycy5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JkZXIgdGhhdCB0aGlzIHJlc29sdmVyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciByZXNvbHZlcnMuXG4gICAgICovXG4gICAgb3JkZXI6IDIwMCxcbiAgICAvKipcbiAgICAgKiBIVFRQIGhlYWRlcnMgdG8gc2VuZCB3aGVuIGRvd25sb2FkaW5nIGZpbGVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGU6XG4gICAgICoge1xuICAgICAqICAgXCJVc2VyLUFnZW50XCI6IFwiSlNPTiBTY2hlbWEgJFJlZiBQYXJzZXJcIixcbiAgICAgKiAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgKiB9XG4gICAgICovXG4gICAgaGVhZGVyczogbnVsbCxcbiAgICAvKipcbiAgICAgKiBIVFRQIHJlcXVlc3QgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICAgKi9cbiAgICB0aW1lb3V0OiA2MDAwMCwgLy8gNjAgc2Vjb25kc1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBIVFRQIHJlZGlyZWN0cyB0byBmb2xsb3cuXG4gICAgICogVG8gZGlzYWJsZSBhdXRvbWF0aWMgZm9sbG93aW5nIG9mIHJlZGlyZWN0cywgc2V0IHRoaXMgdG8gemVyby5cbiAgICAgKi9cbiAgICByZWRpcmVjdHM6IDUsXG4gICAgLyoqXG4gICAgICogVGhlIGB3aXRoQ3JlZGVudGlhbHNgIG9wdGlvbiBvZiBYTUxIdHRwUmVxdWVzdC5cbiAgICAgKiBTZXQgdGhpcyB0byBgdHJ1ZWAgaWYgeW91J3JlIGRvd25sb2FkaW5nIGZpbGVzIGZyb20gYSBDT1JTLWVuYWJsZWQgc2VydmVyIHRoYXQgcmVxdWlyZXMgYXV0aGVudGljYXRpb25cbiAgICAgKi9cbiAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIHJlc29sdmVyIGNhbiByZWFkIGEgZ2l2ZW4gZmlsZSByZWZlcmVuY2UuXG4gICAgICogUmVzb2x2ZXJzIHRoYXQgcmV0dXJuIHRydWUgd2lsbCBiZSB0cmllZCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSByZXNvbHZlcyB0aGUgZmlsZS5cbiAgICAgKiBSZXNvbHZlcnMgdGhhdCByZXR1cm4gZmFsc2Ugd2lsbCBub3QgYmUgZ2l2ZW4gYSBjaGFuY2UgdG8gcmVzb2x2ZSB0aGUgZmlsZS5cbiAgICAgKi9cbiAgICBjYW5SZWFkKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHVybC5pc0h0dHAoZmlsZS51cmwpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGdpdmVuIFVSTCBhbmQgcmV0dXJucyBpdHMgcmF3IGNvbnRlbnRzIGFzIGEgQnVmZmVyLlxuICAgICAqL1xuICAgIHJlYWQoZmlsZSkge1xuICAgICAgICBjb25zdCB1ID0gdXJsLnBhcnNlKGZpbGUudXJsKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXUucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcHJvdG9jb2wgb2YgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAgICAgdS5wcm90b2NvbCA9IHVybC5wYXJzZShsb2NhdGlvbi5ocmVmKS5wcm90b2NvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG93bmxvYWQodSwgdGhpcyk7XG4gICAgfSxcbn07XG4vKipcbiAqIERvd25sb2FkcyB0aGUgZ2l2ZW4gZmlsZS5cbiAqIEByZXR1cm5zXG4gKiBUaGUgcHJvbWlzZSByZXNvbHZlcyB3aXRoIHRoZSByYXcgZG93bmxvYWRlZCBkYXRhLCBvciByZWplY3RzIGlmIHRoZXJlIGlzIGFuIEhUVFAgZXJyb3IuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKHUsIGh0dHBPcHRpb25zLCBfcmVkaXJlY3RzKSB7XG4gICAgdSA9IHVybC5wYXJzZSh1KTtcbiAgICBjb25zdCByZWRpcmVjdHMgPSBfcmVkaXJlY3RzIHx8IFtdO1xuICAgIHJlZGlyZWN0cy5wdXNoKHUuaHJlZik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZ2V0KHUsIGh0dHBPcHRpb25zKTtcbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgb25vXzEub25vKSh7IHN0YXR1czogcmVzLnN0YXR1cyB9LCBgSFRUUCBFUlJPUiAke3Jlcy5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGh0dHBPcHRpb25zLnJlZGlyZWN0cykgJiYgcmVkaXJlY3RzLmxlbmd0aCA+IGh0dHBPcHRpb25zLnJlZGlyZWN0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5SZXNvbHZlckVycm9yKCgwLCBvbm9fMS5vbm8pKHsgc3RhdHVzOiByZXMuc3RhdHVzIH0sIGBFcnJvciBkb3dubG9hZGluZyAke3JlZGlyZWN0c1swXX0uIFxcblRvbyBtYW55IHJlZGlyZWN0czogXFxuICAke3JlZGlyZWN0cy5qb2luKFwiIFxcbiAgXCIpfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEoXCJsb2NhdGlvblwiIGluIHJlcy5oZWFkZXJzKSB8fCAhcmVzLmhlYWRlcnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgb25vXzEub25vKSh7IHN0YXR1czogcmVzLnN0YXR1cyB9LCBgSFRUUCAke3Jlcy5zdGF0dXN9IHJlZGlyZWN0IHdpdGggbm8gbG9jYXRpb24gaGVhZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWRpcmVjdFRvID0gdXJsLnJlc29sdmUodS5ocmVmLCByZXMuaGVhZGVycy5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvd25sb2FkKHJlZGlyZWN0VG8sIGh0dHBPcHRpb25zLCByZWRpcmVjdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlcy5ib2R5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgcmVzLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1Zik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlJlc29sdmVyRXJyb3IoKDAsIG9ub18xLm9ubykoZXJyLCBgRXJyb3IgZG93bmxvYWRpbmcgJHt1LmhyZWZ9YCksIHUuaHJlZik7XG4gICAgfVxufVxuLyoqXG4gKiBTZW5kcyBhbiBIVFRQIEdFVCByZXF1ZXN0LlxuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgSFRUUCBSZXNwb25zZSBvYmplY3QuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldCh1LCBodHRwT3B0aW9ucykge1xuICAgIGxldCBjb250cm9sbGVyO1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgaWYgKGh0dHBPcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIGh0dHBPcHRpb25zLnRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHUsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiBodHRwT3B0aW9ucy5oZWFkZXJzIHx8IHt9LFxuICAgICAgICBjcmVkZW50aWFsczogaHR0cE9wdGlvbnMud2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlciA/IGNvbnRyb2xsZXIuc2lnbmFsIDogbnVsbCxcbiAgICB9KTtcbiAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js ***!
  \***************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = convertPathToPosix;\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nfunction convertPathToPosix(filePath) {\n    const isExtendedLengthPath = filePath.startsWith(\"\\\\\\\\?\\\\\");\n    if (isExtendedLengthPath) {\n        return filePath;\n    }\n    return filePath.split(path_1.default?.win32?.sep).join(path_1.default?.posix?.sep ?? \"/\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL2NvbnZlcnQtcGF0aC10by1wb3NpeC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFlO0FBQ2YsK0JBQStCLG1CQUFPLENBQUMsa0JBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWEtb2xpdmUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhcGlkZXZ0b29scytqc29uLXNjaGVtYS1yZWYtcGFyc2VyQDExLjkuMy9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9jb252ZXJ0LXBhdGgtdG8tcG9zaXguanM/YjdhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNvbnZlcnRQYXRoVG9Qb3NpeDtcbmNvbnN0IHBhdGhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGF0aFwiKSk7XG5mdW5jdGlvbiBjb252ZXJ0UGF0aFRvUG9zaXgoZmlsZVBhdGgpIHtcbiAgICBjb25zdCBpc0V4dGVuZGVkTGVuZ3RoUGF0aCA9IGZpbGVQYXRoLnN0YXJ0c1dpdGgoXCJcXFxcXFxcXD9cXFxcXCIpO1xuICAgIGlmIChpc0V4dGVuZGVkTGVuZ3RoUGF0aCkge1xuICAgICAgICByZXR1cm4gZmlsZVBhdGg7XG4gICAgfVxuICAgIHJldHVybiBmaWxlUGF0aC5zcGxpdChwYXRoXzEuZGVmYXVsdD8ud2luMzI/LnNlcCkuam9pbihwYXRoXzEuZGVmYXVsdD8ucG9zaXg/LnNlcCA/PyBcIi9cIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidPointerError = exports.TimeoutError = exports.MissingPointerError = exports.UnmatchedResolverError = exports.ResolverError = exports.UnmatchedParserError = exports.ParserError = exports.JSONParserErrorGroup = exports.JSONParserError = void 0;\nexports.isHandledError = isHandledError;\nexports.normalizeError = normalizeError;\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(rsc)/./node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/index.js\");\nconst url_js_1 = __webpack_require__(/*! ./url.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\");\nclass JSONParserError extends Error {\n    constructor(message, source) {\n        super();\n        this.code = \"EUNKNOWN\";\n        this.name = \"JSONParserError\";\n        this.message = message;\n        this.source = source;\n        this.path = null;\n        ono_1.Ono.extend(this);\n    }\n    get footprint() {\n        return `${this.path}+${this.source}+${this.code}+${this.message}`;\n    }\n}\nexports.JSONParserError = JSONParserError;\nclass JSONParserErrorGroup extends Error {\n    constructor(parser) {\n        super();\n        this.files = parser;\n        this.name = \"JSONParserErrorGroup\";\n        this.message = `${this.errors.length} error${this.errors.length > 1 ? \"s\" : \"\"} occurred while reading '${(0, url_js_1.toFileSystemPath)(parser.$refs._root$Ref.path)}'`;\n        ono_1.Ono.extend(this);\n    }\n    static getParserErrors(parser) {\n        const errors = [];\n        for (const $ref of Object.values(parser.$refs._$refs)) {\n            if ($ref.errors) {\n                errors.push(...$ref.errors);\n            }\n        }\n        return errors;\n    }\n    get errors() {\n        return JSONParserErrorGroup.getParserErrors(this.files);\n    }\n}\nexports.JSONParserErrorGroup = JSONParserErrorGroup;\nclass ParserError extends JSONParserError {\n    constructor(message, source) {\n        super(`Error parsing ${source}: ${message}`, source);\n        this.code = \"EPARSER\";\n        this.name = \"ParserError\";\n    }\n}\nexports.ParserError = ParserError;\nclass UnmatchedParserError extends JSONParserError {\n    constructor(source) {\n        super(`Could not find parser for \"${source}\"`, source);\n        this.code = \"EUNMATCHEDPARSER\";\n        this.name = \"UnmatchedParserError\";\n    }\n}\nexports.UnmatchedParserError = UnmatchedParserError;\nclass ResolverError extends JSONParserError {\n    constructor(ex, source) {\n        super(ex.message || `Error reading file \"${source}\"`, source);\n        this.code = \"ERESOLVER\";\n        this.name = \"ResolverError\";\n        if (\"code\" in ex) {\n            this.ioErrorCode = String(ex.code);\n        }\n    }\n}\nexports.ResolverError = ResolverError;\nclass UnmatchedResolverError extends JSONParserError {\n    constructor(source) {\n        super(`Could not find resolver for \"${source}\"`, source);\n        this.code = \"EUNMATCHEDRESOLVER\";\n        this.name = \"UnmatchedResolverError\";\n    }\n}\nexports.UnmatchedResolverError = UnmatchedResolverError;\nclass MissingPointerError extends JSONParserError {\n    constructor(token, path, targetRef, targetFound, parentPath) {\n        super(`Missing $ref pointer \"${(0, url_js_1.getHash)(path)}\". Token \"${token}\" does not exist.`, (0, url_js_1.stripHash)(path));\n        this.code = \"EMISSINGPOINTER\";\n        this.name = \"MissingPointerError\";\n        this.targetToken = token;\n        this.targetRef = targetRef;\n        this.targetFound = targetFound;\n        this.parentPath = parentPath;\n    }\n}\nexports.MissingPointerError = MissingPointerError;\nclass TimeoutError extends JSONParserError {\n    constructor(timeout) {\n        super(`Dereferencing timeout reached: ${timeout}ms`);\n        this.code = \"ETIMEOUT\";\n        this.name = \"TimeoutError\";\n    }\n}\nexports.TimeoutError = TimeoutError;\nclass InvalidPointerError extends JSONParserError {\n    constructor(pointer, path) {\n        super(`Invalid $ref pointer \"${pointer}\". Pointers must begin with \"#/\"`, (0, url_js_1.stripHash)(path));\n        this.code = \"EUNMATCHEDRESOLVER\";\n        this.name = \"InvalidPointerError\";\n    }\n}\nexports.InvalidPointerError = InvalidPointerError;\nfunction isHandledError(err) {\n    return err instanceof JSONParserError || err instanceof JSONParserErrorGroup;\n}\nfunction normalizeError(err) {\n    if (err.path === null) {\n        err.path = [];\n    }\n    return err;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRywyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyxxQkFBcUIsR0FBRyw0QkFBNEIsR0FBRyxtQkFBbUIsR0FBRyw0QkFBNEIsR0FBRyx1QkFBdUI7QUFDdlAsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixjQUFjLG1CQUFPLENBQUMsbUhBQWlCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLDZKQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxHQUFHLFlBQVksR0FBRyxVQUFVLEdBQUcsYUFBYTtBQUN4RTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CLE9BQU8sbUNBQW1DLDBCQUEwQiw0REFBNEQ7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxJQUFJLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEIsWUFBWSxNQUFNO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWEtb2xpdmUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhcGlkZXZ0b29scytqc29uLXNjaGVtYS1yZWYtcGFyc2VyQDExLjkuMy9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9lcnJvcnMuanM/NzhjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW52YWxpZFBvaW50ZXJFcnJvciA9IGV4cG9ydHMuVGltZW91dEVycm9yID0gZXhwb3J0cy5NaXNzaW5nUG9pbnRlckVycm9yID0gZXhwb3J0cy5Vbm1hdGNoZWRSZXNvbHZlckVycm9yID0gZXhwb3J0cy5SZXNvbHZlckVycm9yID0gZXhwb3J0cy5Vbm1hdGNoZWRQYXJzZXJFcnJvciA9IGV4cG9ydHMuUGFyc2VyRXJyb3IgPSBleHBvcnRzLkpTT05QYXJzZXJFcnJvckdyb3VwID0gZXhwb3J0cy5KU09OUGFyc2VyRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmlzSGFuZGxlZEVycm9yID0gaXNIYW5kbGVkRXJyb3I7XG5leHBvcnRzLm5vcm1hbGl6ZUVycm9yID0gbm9ybWFsaXplRXJyb3I7XG5jb25zdCBvbm9fMSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCB1cmxfanNfMSA9IHJlcXVpcmUoXCIuL3VybC5qc1wiKTtcbmNsYXNzIEpTT05QYXJzZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFVU5LTk9XTlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkpTT05QYXJzZXJFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICAgICAgb25vXzEuT25vLmV4dGVuZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGZvb3RwcmludCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucGF0aH0rJHt0aGlzLnNvdXJjZX0rJHt0aGlzLmNvZGV9KyR7dGhpcy5tZXNzYWdlfWA7XG4gICAgfVxufVxuZXhwb3J0cy5KU09OUGFyc2VyRXJyb3IgPSBKU09OUGFyc2VyRXJyb3I7XG5jbGFzcyBKU09OUGFyc2VyRXJyb3JHcm91cCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maWxlcyA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJKU09OUGFyc2VyRXJyb3JHcm91cFwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgJHt0aGlzLmVycm9ycy5sZW5ndGh9IGVycm9yJHt0aGlzLmVycm9ycy5sZW5ndGggPiAxID8gXCJzXCIgOiBcIlwifSBvY2N1cnJlZCB3aGlsZSByZWFkaW5nICckeygwLCB1cmxfanNfMS50b0ZpbGVTeXN0ZW1QYXRoKShwYXJzZXIuJHJlZnMuX3Jvb3QkUmVmLnBhdGgpfSdgO1xuICAgICAgICBvbm9fMS5Pbm8uZXh0ZW5kKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UGFyc2VyRXJyb3JzKHBhcnNlcikge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCAkcmVmIG9mIE9iamVjdC52YWx1ZXMocGFyc2VyLiRyZWZzLl8kcmVmcykpIHtcbiAgICAgICAgICAgIGlmICgkcmVmLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLiRyZWYuZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gSlNPTlBhcnNlckVycm9yR3JvdXAuZ2V0UGFyc2VyRXJyb3JzKHRoaXMuZmlsZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuSlNPTlBhcnNlckVycm9yR3JvdXAgPSBKU09OUGFyc2VyRXJyb3JHcm91cDtcbmNsYXNzIFBhcnNlckVycm9yIGV4dGVuZHMgSlNPTlBhcnNlckVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoYEVycm9yIHBhcnNpbmcgJHtzb3VyY2V9OiAke21lc3NhZ2V9YCwgc291cmNlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFUEFSU0VSXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUGFyc2VyRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLlBhcnNlckVycm9yID0gUGFyc2VyRXJyb3I7XG5jbGFzcyBVbm1hdGNoZWRQYXJzZXJFcnJvciBleHRlbmRzIEpTT05QYXJzZXJFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKGBDb3VsZCBub3QgZmluZCBwYXJzZXIgZm9yIFwiJHtzb3VyY2V9XCJgLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIkVVTk1BVENIRURQQVJTRVJcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJVbm1hdGNoZWRQYXJzZXJFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5tYXRjaGVkUGFyc2VyRXJyb3IgPSBVbm1hdGNoZWRQYXJzZXJFcnJvcjtcbmNsYXNzIFJlc29sdmVyRXJyb3IgZXh0ZW5kcyBKU09OUGFyc2VyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGV4LCBzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoZXgubWVzc2FnZSB8fCBgRXJyb3IgcmVhZGluZyBmaWxlIFwiJHtzb3VyY2V9XCJgLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIkVSRVNPTFZFUlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlc29sdmVyRXJyb3JcIjtcbiAgICAgICAgaWYgKFwiY29kZVwiIGluIGV4KSB7XG4gICAgICAgICAgICB0aGlzLmlvRXJyb3JDb2RlID0gU3RyaW5nKGV4LmNvZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZXNvbHZlckVycm9yID0gUmVzb2x2ZXJFcnJvcjtcbmNsYXNzIFVubWF0Y2hlZFJlc29sdmVyRXJyb3IgZXh0ZW5kcyBKU09OUGFyc2VyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihgQ291bGQgbm90IGZpbmQgcmVzb2x2ZXIgZm9yIFwiJHtzb3VyY2V9XCJgLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIkVVTk1BVENIRURSRVNPTFZFUlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlVubWF0Y2hlZFJlc29sdmVyRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLlVubWF0Y2hlZFJlc29sdmVyRXJyb3IgPSBVbm1hdGNoZWRSZXNvbHZlckVycm9yO1xuY2xhc3MgTWlzc2luZ1BvaW50ZXJFcnJvciBleHRlbmRzIEpTT05QYXJzZXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IodG9rZW4sIHBhdGgsIHRhcmdldFJlZiwgdGFyZ2V0Rm91bmQsIHBhcmVudFBhdGgpIHtcbiAgICAgICAgc3VwZXIoYE1pc3NpbmcgJHJlZiBwb2ludGVyIFwiJHsoMCwgdXJsX2pzXzEuZ2V0SGFzaCkocGF0aCl9XCIuIFRva2VuIFwiJHt0b2tlbn1cIiBkb2VzIG5vdCBleGlzdC5gLCAoMCwgdXJsX2pzXzEuc3RyaXBIYXNoKShwYXRoKSk7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiRU1JU1NJTkdQT0lOVEVSXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTWlzc2luZ1BvaW50ZXJFcnJvclwiO1xuICAgICAgICB0aGlzLnRhcmdldFRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMudGFyZ2V0UmVmID0gdGFyZ2V0UmVmO1xuICAgICAgICB0aGlzLnRhcmdldEZvdW5kID0gdGFyZ2V0Rm91bmQ7XG4gICAgICAgIHRoaXMucGFyZW50UGF0aCA9IHBhcmVudFBhdGg7XG4gICAgfVxufVxuZXhwb3J0cy5NaXNzaW5nUG9pbnRlckVycm9yID0gTWlzc2luZ1BvaW50ZXJFcnJvcjtcbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIEpTT05QYXJzZXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IodGltZW91dCkge1xuICAgICAgICBzdXBlcihgRGVyZWZlcmVuY2luZyB0aW1lb3V0IHJlYWNoZWQ6ICR7dGltZW91dH1tc2ApO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIkVUSU1FT1VUXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiVGltZW91dEVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3I7XG5jbGFzcyBJbnZhbGlkUG9pbnRlckVycm9yIGV4dGVuZHMgSlNPTlBhcnNlckVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2ludGVyLCBwYXRoKSB7XG4gICAgICAgIHN1cGVyKGBJbnZhbGlkICRyZWYgcG9pbnRlciBcIiR7cG9pbnRlcn1cIi4gUG9pbnRlcnMgbXVzdCBiZWdpbiB3aXRoIFwiIy9cImAsICgwLCB1cmxfanNfMS5zdHJpcEhhc2gpKHBhdGgpKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFVU5NQVRDSEVEUkVTT0xWRVJcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJJbnZhbGlkUG9pbnRlckVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkUG9pbnRlckVycm9yID0gSW52YWxpZFBvaW50ZXJFcnJvcjtcbmZ1bmN0aW9uIGlzSGFuZGxlZEVycm9yKGVycikge1xuICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiBKU09OUGFyc2VyRXJyb3IgfHwgZXJyIGluc3RhbmNlb2YgSlNPTlBhcnNlckVycm9yR3JvdXA7XG59XG5mdW5jdGlvbiBub3JtYWxpemVFcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyLnBhdGggPT09IG51bGwpIHtcbiAgICAgICAgZXJyLnBhdGggPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGVycjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isWindows = void 0;\nconst isWindowsConst = /^win/.test(globalThis.process ? globalThis.process.platform : \"\");\nconst isWindows = () => isWindowsConst;\nexports.isWindows = isWindows;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL2lzLXdpbmRvd3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWEtb2xpdmUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhcGlkZXZ0b29scytqc29uLXNjaGVtYS1yZWYtcGFyc2VyQDExLjkuMy9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9pcy13aW5kb3dzLmpzP2EwZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzV2luZG93cyA9IHZvaWQgMDtcbmNvbnN0IGlzV2luZG93c0NvbnN0ID0gL153aW4vLnRlc3QoZ2xvYmFsVGhpcy5wcm9jZXNzID8gZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtIDogXCJcIik7XG5jb25zdCBpc1dpbmRvd3MgPSAoKSA9PiBpc1dpbmRvd3NDb25zdDtcbmV4cG9ydHMuaXNXaW5kb3dzID0gaXNXaW5kb3dzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js ***!
  \***********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = maybe;\nconst next_js_1 = __importDefault(__webpack_require__(/*! ./next.js */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js\"));\nfunction maybe(cb, promise) {\n    if (cb) {\n        promise.then(function (result) {\n            (0, next_js_1.default)(function () {\n                cb(null, result);\n            });\n        }, function (err) {\n            (0, next_js_1.default)(function () {\n                cb(err);\n            });\n        });\n        return undefined;\n    }\n    else {\n        return promise;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL21heWJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWU7QUFDZixrQ0FBa0MsbUJBQU8sQ0FBQywrSkFBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWEtb2xpdmUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhcGlkZXZ0b29scytqc29uLXNjaGVtYS1yZWYtcGFyc2VyQDExLjkuMy9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9tYXliZS5qcz9mOGRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWF5YmU7XG5jb25zdCBuZXh0X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbmV4dC5qc1wiKSk7XG5mdW5jdGlvbiBtYXliZShjYiwgcHJvbWlzZSkge1xuICAgIGlmIChjYikge1xuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgKDAsIG5leHRfanNfMS5kZWZhdWx0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2IobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAoMCwgbmV4dF9qc18xLmRlZmF1bHQpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction makeNext() {\n    if (typeof process === \"object\" && typeof process.nextTick === \"function\") {\n        return process.nextTick;\n    }\n    else if (typeof setImmediate === \"function\") {\n        return setImmediate;\n    }\n    else {\n        return function next(f) {\n            setTimeout(f, 0);\n        };\n    }\n}\nexports[\"default\"] = makeNext();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL25leHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlYS1vbGl2ZS13ZWIvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL25leHQuanM/MDBlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIG1ha2VOZXh0KCkge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KGYpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZiwgMCk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gbWFrZU5leHQoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.all = all;\nexports.filter = filter;\nexports.sort = sort;\nexports.run = run;\n/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @returns\n */\nfunction all(plugins) {\n    return Object.keys(plugins || {})\n        .filter((key) => {\n        return typeof plugins[key] === \"object\";\n    })\n        .map((key) => {\n        plugins[key].name = key;\n        return plugins[key];\n    });\n}\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n */\nfunction filter(plugins, method, file) {\n    return plugins.filter((plugin) => {\n        return !!getResult(plugin, method, file);\n    });\n}\n/**\n * Sorts the given plugins, in place, by their `order` property.\n */\nfunction sort(plugins) {\n    for (const plugin of plugins) {\n        plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n    }\n    return plugins.sort((a, b) => {\n        return a.order - b.order;\n    });\n}\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n */\nasync function run(plugins, method, file, $refs) {\n    let plugin;\n    let lastError;\n    let index = 0;\n    return new Promise((resolve, reject) => {\n        runNextPlugin();\n        function runNextPlugin() {\n            plugin = plugins[index++];\n            if (!plugin) {\n                // There are no more functions, so re-throw the last error\n                return reject(lastError);\n            }\n            try {\n                // console.log('  %s', plugin.name);\n                const result = getResult(plugin, method, file, callback, $refs);\n                if (result && typeof result.then === \"function\") {\n                    // A promise was returned\n                    result.then(onSuccess, onError);\n                }\n                else if (result !== undefined) {\n                    // A synchronous result was returned\n                    onSuccess(result);\n                }\n                else if (index === plugins.length) {\n                    throw new Error(\"No promise has been returned or callback has been called.\");\n                }\n            }\n            catch (e) {\n                onError(e);\n            }\n        }\n        function callback(err, result) {\n            if (err) {\n                onError(err);\n            }\n            else {\n                onSuccess(result);\n            }\n        }\n        function onSuccess(result) {\n            // console.log('    success');\n            resolve({\n                plugin,\n                result,\n            });\n        }\n        function onError(error) {\n            // console.log('    %s', err.message || err);\n            lastError = {\n                plugin,\n                error,\n            };\n            runNextPlugin();\n        }\n    });\n}\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an array, then it will be compared against the file extension.\n */\nfunction getResult(obj, prop, file, callback, $refs) {\n    const value = obj[prop];\n    if (typeof value === \"function\") {\n        return value.apply(obj, [file, callback, $refs]);\n    }\n    if (!callback) {\n        // The synchronous plugin functions (canParse and canRead)\n        // allow a \"shorthand\" syntax, where the user can match\n        // files by RegExp or by file extension.\n        if (value instanceof RegExp) {\n            return value.test(file.url);\n        }\n        else if (typeof value === \"string\") {\n            return value === file.extension;\n        }\n        else if (Array.isArray(value)) {\n            return value.indexOf(file.extension) !== -1;\n        }\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL3BsdWdpbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLGNBQWM7QUFDZCxZQUFZO0FBQ1osV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVhLW9saXZlLXdlYi8uL25vZGVfbW9kdWxlcy8ucG5wbS9AYXBpZGV2dG9vbHMranNvbi1zY2hlbWEtcmVmLXBhcnNlckAxMS45LjMvbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3V0aWwvcGx1Z2lucy5qcz9mYjllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hbGwgPSBhbGw7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmV4cG9ydHMuc29ydCA9IHNvcnQ7XG5leHBvcnRzLnJ1biA9IHJ1bjtcbi8qKlxuICogUmV0dXJucyB0aGUgZ2l2ZW4gcGx1Z2lucyBhcyBhbiBhcnJheSwgcmF0aGVyIHRoYW4gYW4gb2JqZWN0IG1hcC5cbiAqIEFsbCBvdGhlciBtZXRob2RzIGluIHRoaXMgbW9kdWxlIGV4cGVjdCBhbiBhcnJheSBvZiBwbHVnaW5zIHJhdGhlciB0aGFuIGFuIG9iamVjdCBtYXAuXG4gKlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gYWxsKHBsdWdpbnMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGx1Z2lucyB8fCB7fSlcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcGx1Z2luc1trZXldID09PSBcIm9iamVjdFwiO1xuICAgIH0pXG4gICAgICAgIC5tYXAoKGtleSkgPT4ge1xuICAgICAgICBwbHVnaW5zW2tleV0ubmFtZSA9IGtleTtcbiAgICAgICAgcmV0dXJuIHBsdWdpbnNba2V5XTtcbiAgICB9KTtcbn1cbi8qKlxuICogRmlsdGVycyB0aGUgZ2l2ZW4gcGx1Z2lucywgcmV0dXJuaW5nIG9ubHkgdGhlIG9uZXMgcmV0dXJuIGB0cnVlYCBmb3IgdGhlIGdpdmVuIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKHBsdWdpbnMsIG1ldGhvZCwgZmlsZSkge1xuICAgIHJldHVybiBwbHVnaW5zLmZpbHRlcigocGx1Z2luKSA9PiB7XG4gICAgICAgIHJldHVybiAhIWdldFJlc3VsdChwbHVnaW4sIG1ldGhvZCwgZmlsZSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFNvcnRzIHRoZSBnaXZlbiBwbHVnaW5zLCBpbiBwbGFjZSwgYnkgdGhlaXIgYG9yZGVyYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gc29ydChwbHVnaW5zKSB7XG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICBwbHVnaW4ub3JkZXIgPSBwbHVnaW4ub3JkZXIgfHwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW5zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSdW5zIHRoZSBzcGVjaWZpZWQgbWV0aG9kIG9mIHRoZSBnaXZlbiBwbHVnaW5zLCBpbiBvcmRlciwgdW50aWwgb25lIG9mIHRoZW0gcmV0dXJucyBhIHN1Y2Nlc3NmdWwgcmVzdWx0LlxuICogRWFjaCBtZXRob2QgY2FuIHJldHVybiBhIHN5bmNocm9ub3VzIHZhbHVlLCBhIFByb21pc2UsIG9yIGNhbGwgYW4gZXJyb3ItZmlyc3QgY2FsbGJhY2suXG4gKiBJZiB0aGUgcHJvbWlzZSByZXNvbHZlcyBzdWNjZXNzZnVsbHksIG9yIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aG91dCBhbiBlcnJvciwgdGhlbiB0aGUgcmVzdWx0XG4gKiBpcyBpbW1lZGlhdGVseSByZXR1cm5lZCBhbmQgbm8gZnVydGhlciBwbHVnaW5zIGFyZSBjYWxsZWQuXG4gKiBJZiB0aGUgcHJvbWlzZSByZWplY3RzLCBvciB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggYW4gZXJyb3IsIHRoZW4gdGhlIG5leHQgcGx1Z2luIGlzIGNhbGxlZC5cbiAqIElmIEFMTCBwbHVnaW5zIGZhaWwsIHRoZW4gdGhlIGxhc3QgZXJyb3IgaXMgdGhyb3duLlxuICovXG5hc3luYyBmdW5jdGlvbiBydW4ocGx1Z2lucywgbWV0aG9kLCBmaWxlLCAkcmVmcykge1xuICAgIGxldCBwbHVnaW47XG4gICAgbGV0IGxhc3RFcnJvcjtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJ1bk5leHRQbHVnaW4oKTtcbiAgICAgICAgZnVuY3Rpb24gcnVuTmV4dFBsdWdpbigpIHtcbiAgICAgICAgICAgIHBsdWdpbiA9IHBsdWdpbnNbaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoIXBsdWdpbikge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBtb3JlIGZ1bmN0aW9ucywgc28gcmUtdGhyb3cgdGhlIGxhc3QgZXJyb3JcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGxhc3RFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcgICVzJywgcGx1Z2luLm5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldFJlc3VsdChwbHVnaW4sIG1ldGhvZCwgZmlsZSwgY2FsbGJhY2ssICRyZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcHJvbWlzZSB3YXMgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBzeW5jaHJvbm91cyByZXN1bHQgd2FzIHJldHVybmVkXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gcGx1Z2lucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvbWlzZSBoYXMgYmVlbiByZXR1cm5lZCBvciBjYWxsYmFjayBoYXMgYmVlbiBjYWxsZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uU3VjY2VzcyhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyhyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcgICAgc3VjY2VzcycpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcgICAgJXMnLCBlcnIubWVzc2FnZSB8fCBlcnIpO1xuICAgICAgICAgICAgbGFzdEVycm9yID0ge1xuICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBydW5OZXh0UGx1Z2luKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIHByb3BlcnR5LlxuICogSWYgdGhlIHByb3BlcnR5IGlzIGEgZnVuY3Rpb24sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gaXMgcmV0dXJuZWQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBSZWdFeHAsIHRoZW4gaXQgd2lsbCBiZSB0ZXN0ZWQgYWdhaW5zdCB0aGUgZmlsZSBVUkwuXG4gKiBJZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXksIHRoZW4gaXQgd2lsbCBiZSBjb21wYXJlZCBhZ2FpbnN0IHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVzdWx0KG9iaiwgcHJvcCwgZmlsZSwgY2FsbGJhY2ssICRyZWZzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hcHBseShvYmosIFtmaWxlLCBjYWxsYmFjaywgJHJlZnNdKTtcbiAgICB9XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAvLyBUaGUgc3luY2hyb25vdXMgcGx1Z2luIGZ1bmN0aW9ucyAoY2FuUGFyc2UgYW5kIGNhblJlYWQpXG4gICAgICAgIC8vIGFsbG93IGEgXCJzaG9ydGhhbmRcIiBzeW50YXgsIHdoZXJlIHRoZSB1c2VyIGNhbiBtYXRjaFxuICAgICAgICAvLyBmaWxlcyBieSBSZWdFeHAgb3IgYnkgZmlsZSBleHRlbnNpb24uXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRlc3QoZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmaWxlLmV4dGVuc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmluZGV4T2YoZmlsZS5leHRlbnNpb24pICE9PSAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js ***!
  \*********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = void 0;\nexports.resolve = resolve;\nexports.cwd = cwd;\nexports.getProtocol = getProtocol;\nexports.getExtension = getExtension;\nexports.stripQuery = stripQuery;\nexports.getHash = getHash;\nexports.stripHash = stripHash;\nexports.isHttp = isHttp;\nexports.isFileSystemPath = isFileSystemPath;\nexports.fromFileSystemPath = fromFileSystemPath;\nexports.toFileSystemPath = toFileSystemPath;\nexports.safePointerToPath = safePointerToPath;\nexports.relative = relative;\nconst convert_path_to_posix_1 = __importDefault(__webpack_require__(/*! ./convert-path-to-posix */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js\"));\nconst path_1 = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst forwardSlashPattern = /\\//g;\nconst protocolPattern = /^(\\w{2,}):\\/\\//i;\nconst jsonPointerSlash = /~1/g;\nconst jsonPointerTilde = /~0/g;\nconst path_2 = __webpack_require__(/*! path */ \"path\");\nconst is_windows_1 = __webpack_require__(/*! ./is-windows */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js\");\n// RegExp patterns to URL-encode special characters in local filesystem paths\nconst urlEncodePatterns = [\n    [/\\?/g, \"%3F\"],\n    [/#/g, \"%23\"],\n];\n// RegExp patterns to URL-decode special characters for local filesystem paths\nconst urlDecodePatterns = [/%23/g, \"#\", /%24/g, \"$\", /%26/g, \"&\", /%2C/g, \",\", /%40/g, \"@\"];\nconst parse = (u) => new URL(u);\nexports.parse = parse;\n/**\n * Returns resolved target URL relative to a base URL in a manner similar to that of a Web browser resolving an anchor tag HREF.\n *\n * @returns\n */\nfunction resolve(from, to) {\n    // we use a non-existent URL to check if its a relative URL\n    const fromUrl = new URL((0, convert_path_to_posix_1.default)(from), \"https://aaa.nonexistanturl.com\");\n    const resolvedUrl = new URL((0, convert_path_to_posix_1.default)(to), fromUrl);\n    const endSpaces = to.match(/(\\s*)$/)?.[1] || \"\";\n    if (resolvedUrl.hostname === \"aaa.nonexistanturl.com\") {\n        // `from` is a relative URL.\n        const { pathname, search, hash } = resolvedUrl;\n        return pathname + search + hash + endSpaces;\n    }\n    return resolvedUrl.toString() + endSpaces;\n}\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns\n */\nfunction cwd() {\n    if (typeof window !== \"undefined\") {\n        return location.href;\n    }\n    const path = process.cwd();\n    const lastChar = path.slice(-1);\n    if (lastChar === \"/\" || lastChar === \"\\\\\") {\n        return path;\n    }\n    else {\n        return path + \"/\";\n    }\n}\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param path\n * @returns\n */\nfunction getProtocol(path) {\n    const match = protocolPattern.exec(path || \"\");\n    if (match) {\n        return match[1].toLowerCase();\n    }\n    return undefined;\n}\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param path\n * @returns\n */\nfunction getExtension(path) {\n    const lastDot = path.lastIndexOf(\".\");\n    if (lastDot >= 0) {\n        return stripQuery(path.substr(lastDot).toLowerCase());\n    }\n    return \"\";\n}\n/**\n * Removes the query, if any, from the given path.\n *\n * @param path\n * @returns\n */\nfunction stripQuery(path) {\n    const queryIndex = path.indexOf(\"?\");\n    if (queryIndex >= 0) {\n        path = path.substr(0, queryIndex);\n    }\n    return path;\n}\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param path\n * @returns\n */\nfunction getHash(path) {\n    if (!path) {\n        return \"#\";\n    }\n    const hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n        return path.substring(hashIndex);\n    }\n    return \"#\";\n}\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param path\n * @returns\n */\nfunction stripHash(path) {\n    if (!path) {\n        return \"\";\n    }\n    const hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n        path = path.substring(0, hashIndex);\n    }\n    return path;\n}\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param path\n * @returns\n */\nfunction isHttp(path) {\n    const protocol = getProtocol(path);\n    if (protocol === \"http\" || protocol === \"https\") {\n        return true;\n    }\n    else if (protocol === undefined) {\n        // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n        return typeof window !== \"undefined\";\n    }\n    else {\n        // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n        return false;\n    }\n}\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param path\n * @returns\n */\nfunction isFileSystemPath(path) {\n    // @ts-ignore\n    if (typeof window !== \"undefined\" || (typeof process !== \"undefined\" && false)) {\n        // We're running in a browser, so assume that all paths are URLs.\n        // This way, even relative paths will be treated as URLs rather than as filesystem paths\n        return false;\n    }\n    const protocol = getProtocol(path);\n    return protocol === undefined || protocol === \"file\";\n}\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param path\n * @returns\n */\nfunction fromFileSystemPath(path) {\n    // Step 1: On Windows, replace backslashes with forward slashes,\n    // rather than encoding them as \"%5C\"\n    if ((0, is_windows_1.isWindows)()) {\n        const projectDir = cwd();\n        const upperPath = path.toUpperCase();\n        const projectDirPosixPath = (0, convert_path_to_posix_1.default)(projectDir);\n        const posixUpper = projectDirPosixPath.toUpperCase();\n        const hasProjectDir = upperPath.includes(posixUpper);\n        const hasProjectUri = upperPath.includes(posixUpper);\n        const isAbsolutePath = path_1.win32?.isAbsolute(path) ||\n            path.startsWith(\"http://\") ||\n            path.startsWith(\"https://\") ||\n            path.startsWith(\"file://\");\n        if (!(hasProjectDir || hasProjectUri || isAbsolutePath) && !projectDir.startsWith(\"http\")) {\n            path = (0, path_2.join)(projectDir, path);\n        }\n        path = (0, convert_path_to_posix_1.default)(path);\n    }\n    // Step 2: `encodeURI` will take care of MOST characters\n    path = encodeURI(path);\n    // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n    // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n    // but are just normal characters in a filesystem path.\n    for (const pattern of urlEncodePatterns) {\n        path = path.replace(pattern[0], pattern[1]);\n    }\n    return path;\n}\n/**\n * Converts a URL to a local filesystem path.\n */\nfunction toFileSystemPath(path, keepFileProtocol) {\n    // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n    path = decodeURI(path);\n    // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n    // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n    // but are just normal characters in a filesystem path.\n    for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n        path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n    }\n    // Step 3: If it's a \"file://\" URL, then format it consistently\n    // or convert it to a local filesystem path\n    let isFileUrl = path.substr(0, 7).toLowerCase() === \"file://\";\n    if (isFileUrl) {\n        // Strip-off the protocol, and the initial \"/\", if there is one\n        path = path[7] === \"/\" ? path.substr(8) : path.substr(7);\n        // insert a colon (\":\") after the drive letter on Windows\n        if ((0, is_windows_1.isWindows)() && path[1] === \"/\") {\n            path = path[0] + \":\" + path.substr(1);\n        }\n        if (keepFileProtocol) {\n            // Return the consistently-formatted \"file://\" URL\n            path = \"file:///\" + path;\n        }\n        else {\n            // Convert the \"file://\" URL to a local filesystem path.\n            // On Windows, it will start with something like \"C:/\".\n            // On Posix, it will start with \"/\"\n            isFileUrl = false;\n            path = (0, is_windows_1.isWindows)() ? path : \"/\" + path;\n        }\n    }\n    // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n    if ((0, is_windows_1.isWindows)() && !isFileUrl) {\n        // Replace forward slashes with backslashes\n        path = path.replace(forwardSlashPattern, \"\\\\\");\n        // Capitalize the drive letter\n        if (path.substr(1, 2) === \":\\\\\") {\n            path = path[0].toUpperCase() + path.substr(1);\n        }\n    }\n    return path;\n}\n/**\n * Converts a $ref pointer to a valid JSON Path.\n *\n * @param pointer\n * @returns\n */\nfunction safePointerToPath(pointer) {\n    if (pointer.length <= 1 || pointer[0] !== \"#\" || pointer[1] !== \"/\") {\n        return [];\n    }\n    return pointer\n        .slice(2)\n        .split(\"/\")\n        .map((value) => {\n        return decodeURIComponent(value).replace(jsonPointerSlash, \"/\").replace(jsonPointerTilde, \"~\");\n    });\n}\nfunction relative(from, to) {\n    if (!isFileSystemPath(from) || !isFileSystemPath(to)) {\n        return resolve(from, to);\n    }\n    const fromDir = path_1.default.dirname(stripHash(from));\n    const toPath = stripHash(to);\n    const result = path_1.default.relative(fromDir, toPath);\n    return result + getHash(to);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL3VybC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixlQUFlO0FBQ2YsV0FBVztBQUNYLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZixpQkFBaUI7QUFDakIsY0FBYztBQUNkLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QixnQkFBZ0I7QUFDaEIsZ0RBQWdELG1CQUFPLENBQUMsOExBQXlCO0FBQ2pGLDRCQUE0QixtQkFBTyxDQUFDLGtCQUFNO0FBQzFDO0FBQ0EsOEJBQThCLEdBQUc7QUFDakM7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyx3S0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBZTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlYS1vbGl2ZS13ZWIvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFwaWRldnRvb2xzK2pzb24tc2NoZW1hLXJlZi1wYXJzZXJAMTEuOS4zL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL3VybC5qcz9lYzYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlID0gdm9pZCAwO1xuZXhwb3J0cy5yZXNvbHZlID0gcmVzb2x2ZTtcbmV4cG9ydHMuY3dkID0gY3dkO1xuZXhwb3J0cy5nZXRQcm90b2NvbCA9IGdldFByb3RvY29sO1xuZXhwb3J0cy5nZXRFeHRlbnNpb24gPSBnZXRFeHRlbnNpb247XG5leHBvcnRzLnN0cmlwUXVlcnkgPSBzdHJpcFF1ZXJ5O1xuZXhwb3J0cy5nZXRIYXNoID0gZ2V0SGFzaDtcbmV4cG9ydHMuc3RyaXBIYXNoID0gc3RyaXBIYXNoO1xuZXhwb3J0cy5pc0h0dHAgPSBpc0h0dHA7XG5leHBvcnRzLmlzRmlsZVN5c3RlbVBhdGggPSBpc0ZpbGVTeXN0ZW1QYXRoO1xuZXhwb3J0cy5mcm9tRmlsZVN5c3RlbVBhdGggPSBmcm9tRmlsZVN5c3RlbVBhdGg7XG5leHBvcnRzLnRvRmlsZVN5c3RlbVBhdGggPSB0b0ZpbGVTeXN0ZW1QYXRoO1xuZXhwb3J0cy5zYWZlUG9pbnRlclRvUGF0aCA9IHNhZmVQb2ludGVyVG9QYXRoO1xuZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuY29uc3QgY29udmVydF9wYXRoX3RvX3Bvc2l4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29udmVydC1wYXRoLXRvLXBvc2l4XCIpKTtcbmNvbnN0IHBhdGhfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicGF0aFwiKSk7XG5jb25zdCBmb3J3YXJkU2xhc2hQYXR0ZXJuID0gL1xcLy9nO1xuY29uc3QgcHJvdG9jb2xQYXR0ZXJuID0gL14oXFx3ezIsfSk6XFwvXFwvL2k7XG5jb25zdCBqc29uUG9pbnRlclNsYXNoID0gL34xL2c7XG5jb25zdCBqc29uUG9pbnRlclRpbGRlID0gL34wL2c7XG5jb25zdCBwYXRoXzIgPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGlzX3dpbmRvd3NfMSA9IHJlcXVpcmUoXCIuL2lzLXdpbmRvd3NcIik7XG4vLyBSZWdFeHAgcGF0dGVybnMgdG8gVVJMLWVuY29kZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gbG9jYWwgZmlsZXN5c3RlbSBwYXRoc1xuY29uc3QgdXJsRW5jb2RlUGF0dGVybnMgPSBbXG4gICAgWy9cXD8vZywgXCIlM0ZcIl0sXG4gICAgWy8jL2csIFwiJTIzXCJdLFxuXTtcbi8vIFJlZ0V4cCBwYXR0ZXJucyB0byBVUkwtZGVjb2RlIHNwZWNpYWwgY2hhcmFjdGVycyBmb3IgbG9jYWwgZmlsZXN5c3RlbSBwYXRoc1xuY29uc3QgdXJsRGVjb2RlUGF0dGVybnMgPSBbLyUyMy9nLCBcIiNcIiwgLyUyNC9nLCBcIiRcIiwgLyUyNi9nLCBcIiZcIiwgLyUyQy9nLCBcIixcIiwgLyU0MC9nLCBcIkBcIl07XG5jb25zdCBwYXJzZSA9ICh1KSA9PiBuZXcgVVJMKHUpO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLyoqXG4gKiBSZXR1cm5zIHJlc29sdmVkIHRhcmdldCBVUkwgcmVsYXRpdmUgdG8gYSBiYXNlIFVSTCBpbiBhIG1hbm5lciBzaW1pbGFyIHRvIHRoYXQgb2YgYSBXZWIgYnJvd3NlciByZXNvbHZpbmcgYW4gYW5jaG9yIHRhZyBIUkVGLlxuICpcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUoZnJvbSwgdG8pIHtcbiAgICAvLyB3ZSB1c2UgYSBub24tZXhpc3RlbnQgVVJMIHRvIGNoZWNrIGlmIGl0cyBhIHJlbGF0aXZlIFVSTFxuICAgIGNvbnN0IGZyb21VcmwgPSBuZXcgVVJMKCgwLCBjb252ZXJ0X3BhdGhfdG9fcG9zaXhfMS5kZWZhdWx0KShmcm9tKSwgXCJodHRwczovL2FhYS5ub25leGlzdGFudHVybC5jb21cIik7XG4gICAgY29uc3QgcmVzb2x2ZWRVcmwgPSBuZXcgVVJMKCgwLCBjb252ZXJ0X3BhdGhfdG9fcG9zaXhfMS5kZWZhdWx0KSh0byksIGZyb21VcmwpO1xuICAgIGNvbnN0IGVuZFNwYWNlcyA9IHRvLm1hdGNoKC8oXFxzKikkLyk/LlsxXSB8fCBcIlwiO1xuICAgIGlmIChyZXNvbHZlZFVybC5ob3N0bmFtZSA9PT0gXCJhYWEubm9uZXhpc3RhbnR1cmwuY29tXCIpIHtcbiAgICAgICAgLy8gYGZyb21gIGlzIGEgcmVsYXRpdmUgVVJMLlxuICAgICAgICBjb25zdCB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSA9IHJlc29sdmVkVXJsO1xuICAgICAgICByZXR1cm4gcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoICsgZW5kU3BhY2VzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRVcmwudG9TdHJpbmcoKSArIGVuZFNwYWNlcztcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSAoaW4gTm9kZSkgb3IgdGhlIGN1cnJlbnQgcGFnZSBVUkwgKGluIGJyb3dzZXJzKS5cbiAqXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBjd2QoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhyZWY7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBwcm9jZXNzLmN3ZCgpO1xuICAgIGNvbnN0IGxhc3RDaGFyID0gcGF0aC5zbGljZSgtMSk7XG4gICAgaWYgKGxhc3RDaGFyID09PSBcIi9cIiB8fCBsYXN0Q2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aCArIFwiL1wiO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvdG9jb2wgb2YgdGhlIGdpdmVuIFVSTCwgb3IgYHVuZGVmaW5lZGAgaWYgaXQgaGFzIG5vIHByb3RvY29sLlxuICpcbiAqIEBwYXJhbSBwYXRoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRQcm90b2NvbChwYXRoKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhwYXRoIHx8IFwiXCIpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbG93ZXJjYXNlZCBmaWxlIGV4dGVuc2lvbiBvZiB0aGUgZ2l2ZW4gVVJMLFxuICogb3IgYW4gZW1wdHkgc3RyaW5nIGlmIGl0IGhhcyBubyBleHRlbnNpb24uXG4gKlxuICogQHBhcmFtIHBhdGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbihwYXRoKSB7XG4gICAgY29uc3QgbGFzdERvdCA9IHBhdGgubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChsYXN0RG90ID49IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmlwUXVlcnkocGF0aC5zdWJzdHIobGFzdERvdCkudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xufVxuLyoqXG4gKiBSZW1vdmVzIHRoZSBxdWVyeSwgaWYgYW55LCBmcm9tIHRoZSBnaXZlbiBwYXRoLlxuICpcbiAqIEBwYXJhbSBwYXRoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBzdHJpcFF1ZXJ5KHBhdGgpIHtcbiAgICBjb25zdCBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcbiAgICBpZiAocXVlcnlJbmRleCA+PSAwKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBxdWVyeUluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGhhc2ggKFVSTCBmcmFnbWVudCksIG9mIHRoZSBnaXZlbiBwYXRoLlxuICogSWYgdGhlcmUgaXMgbm8gaGFzaCwgdGhlbiB0aGUgcm9vdCBoYXNoIChcIiNcIikgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHBhdGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldEhhc2gocGF0aCkge1xuICAgIGlmICghcGF0aCkge1xuICAgICAgICByZXR1cm4gXCIjXCI7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXRoLnN1YnN0cmluZyhoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gXCIjXCI7XG59XG4vKipcbiAqIFJlbW92ZXMgdGhlIGhhc2ggKFVSTCBmcmFnbWVudCksIGlmIGFueSwgZnJvbSB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gc3RyaXBIYXNoKHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBwYXRoIGlzIGFuIEhUVFAoUykgVVJMLlxuICpcbiAqIEBwYXJhbSBwYXRoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0h0dHAocGF0aCkge1xuICAgIGNvbnN0IHByb3RvY29sID0gZ2V0UHJvdG9jb2wocGF0aCk7XG4gICAgaWYgKHByb3RvY29sID09PSBcImh0dHBcIiB8fCBwcm90b2NvbCA9PT0gXCJodHRwc1wiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm90b2NvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHByb3RvY29sLiAgSWYgd2UncmUgcnVubmluZyBpbiBhIGJyb3dzZXIsIHRoZW4gYXNzdW1lIGl0J3MgSFRUUC5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJdCdzIHNvbWUgb3RoZXIgcHJvdG9jb2wsIHN1Y2ggYXMgXCJmdHA6Ly9cIiwgXCJtb25nb2RiOi8vXCIsIGV0Yy5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBwYXRoIGlzIGEgZmlsZXN5c3RlbSBwYXRoLlxuICogVGhpcyBpbmNsdWRlcyBcImZpbGU6Ly9cIiBVUkxzLlxuICpcbiAqIEBwYXJhbSBwYXRoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0ZpbGVTeXN0ZW1QYXRoKHBhdGgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgfHwgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuYnJvd3NlcikpIHtcbiAgICAgICAgLy8gV2UncmUgcnVubmluZyBpbiBhIGJyb3dzZXIsIHNvIGFzc3VtZSB0aGF0IGFsbCBwYXRocyBhcmUgVVJMcy5cbiAgICAgICAgLy8gVGhpcyB3YXksIGV2ZW4gcmVsYXRpdmUgcGF0aHMgd2lsbCBiZSB0cmVhdGVkIGFzIFVSTHMgcmF0aGVyIHRoYW4gYXMgZmlsZXN5c3RlbSBwYXRoc1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb3RvY29sID0gZ2V0UHJvdG9jb2wocGF0aCk7XG4gICAgcmV0dXJuIHByb3RvY29sID09PSB1bmRlZmluZWQgfHwgcHJvdG9jb2wgPT09IFwiZmlsZVwiO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGZpbGVzeXN0ZW0gcGF0aCB0byBhIHByb3Blcmx5LWVuY29kZWQgVVJMLlxuICpcbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gaGFuZGxlIHNpdHVhdGlvbnMgd2hlcmUgSlNPTiBTY2hlbWEgJFJlZiBQYXJzZXIgaXMgY2FsbGVkXG4gKiB3aXRoIGEgZmlsZXN5c3RlbSBwYXRoIHRoYXQgY29udGFpbnMgY2hhcmFjdGVycyB3aGljaCBhcmUgbm90IGFsbG93ZWQgaW4gVVJMcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGZvbGxvd2luZyBmaWxlc3lzdGVtIHBhdGhzIHdvdWxkIGJlIGNvbnZlcnRlZCB0byB0aGUgZm9sbG93aW5nIFVSTHM6XG4gKlxuICogICAgPFwiIUAjJCVeJiorPT8nPi5qc29uICAgICAgICAgICAgICA9PT4gICAlM0MlMjIhQCUyMyQlMjUlNUUmKis9JTNGXFwnJTNFLmpzb25cbiAqICAgIEM6XFxcXE15IERvY3VtZW50c1xcXFxGaWxlICgxKS5qc29uICAgPT0+ICAgQzovTXklMjBEb2N1bWVudHMvRmlsZSUyMCgxKS5qc29uXG4gKiAgICBmaWxlOi8vUHJvamVjdCAjNDIvZmlsZS5qc29uICAgICAgPT0+ICAgZmlsZTovL1Byb2plY3QlMjAlMjM0Mi9maWxlLmpzb25cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZnJvbUZpbGVTeXN0ZW1QYXRoKHBhdGgpIHtcbiAgICAvLyBTdGVwIDE6IE9uIFdpbmRvd3MsIHJlcGxhY2UgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkIHNsYXNoZXMsXG4gICAgLy8gcmF0aGVyIHRoYW4gZW5jb2RpbmcgdGhlbSBhcyBcIiU1Q1wiXG4gICAgaWYgKCgwLCBpc193aW5kb3dzXzEuaXNXaW5kb3dzKSgpKSB7XG4gICAgICAgIGNvbnN0IHByb2plY3REaXIgPSBjd2QoKTtcbiAgICAgICAgY29uc3QgdXBwZXJQYXRoID0gcGF0aC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBjb25zdCBwcm9qZWN0RGlyUG9zaXhQYXRoID0gKDAsIGNvbnZlcnRfcGF0aF90b19wb3NpeF8xLmRlZmF1bHQpKHByb2plY3REaXIpO1xuICAgICAgICBjb25zdCBwb3NpeFVwcGVyID0gcHJvamVjdERpclBvc2l4UGF0aC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBjb25zdCBoYXNQcm9qZWN0RGlyID0gdXBwZXJQYXRoLmluY2x1ZGVzKHBvc2l4VXBwZXIpO1xuICAgICAgICBjb25zdCBoYXNQcm9qZWN0VXJpID0gdXBwZXJQYXRoLmluY2x1ZGVzKHBvc2l4VXBwZXIpO1xuICAgICAgICBjb25zdCBpc0Fic29sdXRlUGF0aCA9IHBhdGhfMS53aW4zMj8uaXNBYnNvbHV0ZShwYXRoKSB8fFxuICAgICAgICAgICAgcGF0aC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fFxuICAgICAgICAgICAgcGF0aC5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikgfHxcbiAgICAgICAgICAgIHBhdGguc3RhcnRzV2l0aChcImZpbGU6Ly9cIik7XG4gICAgICAgIGlmICghKGhhc1Byb2plY3REaXIgfHwgaGFzUHJvamVjdFVyaSB8fCBpc0Fic29sdXRlUGF0aCkgJiYgIXByb2plY3REaXIuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICAgICAgICAgIHBhdGggPSAoMCwgcGF0aF8yLmpvaW4pKHByb2plY3REaXIsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSAoMCwgY29udmVydF9wYXRoX3RvX3Bvc2l4XzEuZGVmYXVsdCkocGF0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXAgMjogYGVuY29kZVVSSWAgd2lsbCB0YWtlIGNhcmUgb2YgTU9TVCBjaGFyYWN0ZXJzXG4gICAgcGF0aCA9IGVuY29kZVVSSShwYXRoKTtcbiAgICAvLyBTdGVwIDM6IE1hbnVhbGx5IGVuY29kZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBlbmNvZGVkIGJ5IGBlbmNvZGVVUklgLlxuICAgIC8vIFRoaXMgaW5jbHVkZXMgY2hhcmFjdGVycyBzdWNoIGFzIFwiI1wiIGFuZCBcIj9cIiwgd2hpY2ggaGF2ZSBzcGVjaWFsIG1lYW5pbmcgaW4gVVJMcyxcbiAgICAvLyBidXQgYXJlIGp1c3Qgbm9ybWFsIGNoYXJhY3RlcnMgaW4gYSBmaWxlc3lzdGVtIHBhdGguXG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHVybEVuY29kZVBhdHRlcm5zKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UocGF0dGVyblswXSwgcGF0dGVyblsxXSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVSTCB0byBhIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aC5cbiAqL1xuZnVuY3Rpb24gdG9GaWxlU3lzdGVtUGF0aChwYXRoLCBrZWVwRmlsZVByb3RvY29sKSB7XG4gICAgLy8gU3RlcCAxOiBgZGVjb2RlVVJJYCB3aWxsIGRlY29kZSBjaGFyYWN0ZXJzIHN1Y2ggYXMgQ3lyaWxsaWMgY2hhcmFjdGVycywgc3BhY2VzLCBldGMuXG4gICAgcGF0aCA9IGRlY29kZVVSSShwYXRoKTtcbiAgICAvLyBTdGVwIDI6IE1hbnVhbGx5IGRlY29kZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBkZWNvZGVkIGJ5IGBkZWNvZGVVUklgLlxuICAgIC8vIFRoaXMgaW5jbHVkZXMgY2hhcmFjdGVycyBzdWNoIGFzIFwiI1wiIGFuZCBcIj9cIiwgd2hpY2ggaGF2ZSBzcGVjaWFsIG1lYW5pbmcgaW4gVVJMcyxcbiAgICAvLyBidXQgYXJlIGp1c3Qgbm9ybWFsIGNoYXJhY3RlcnMgaW4gYSBmaWxlc3lzdGVtIHBhdGguXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxEZWNvZGVQYXR0ZXJucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHVybERlY29kZVBhdHRlcm5zW2ldLCB1cmxEZWNvZGVQYXR0ZXJuc1tpICsgMV0pO1xuICAgIH1cbiAgICAvLyBTdGVwIDM6IElmIGl0J3MgYSBcImZpbGU6Ly9cIiBVUkwsIHRoZW4gZm9ybWF0IGl0IGNvbnNpc3RlbnRseVxuICAgIC8vIG9yIGNvbnZlcnQgaXQgdG8gYSBsb2NhbCBmaWxlc3lzdGVtIHBhdGhcbiAgICBsZXQgaXNGaWxlVXJsID0gcGF0aC5zdWJzdHIoMCwgNykudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWxlOi8vXCI7XG4gICAgaWYgKGlzRmlsZVVybCkge1xuICAgICAgICAvLyBTdHJpcC1vZmYgdGhlIHByb3RvY29sLCBhbmQgdGhlIGluaXRpYWwgXCIvXCIsIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICBwYXRoID0gcGF0aFs3XSA9PT0gXCIvXCIgPyBwYXRoLnN1YnN0cig4KSA6IHBhdGguc3Vic3RyKDcpO1xuICAgICAgICAvLyBpbnNlcnQgYSBjb2xvbiAoXCI6XCIpIGFmdGVyIHRoZSBkcml2ZSBsZXR0ZXIgb24gV2luZG93c1xuICAgICAgICBpZiAoKDAsIGlzX3dpbmRvd3NfMS5pc1dpbmRvd3MpKCkgJiYgcGF0aFsxXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoWzBdICsgXCI6XCIgKyBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2VlcEZpbGVQcm90b2NvbCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjb25zaXN0ZW50bHktZm9ybWF0dGVkIFwiZmlsZTovL1wiIFVSTFxuICAgICAgICAgICAgcGF0aCA9IFwiZmlsZTovLy9cIiArIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBcImZpbGU6Ly9cIiBVUkwgdG8gYSBsb2NhbCBmaWxlc3lzdGVtIHBhdGguXG4gICAgICAgICAgICAvLyBPbiBXaW5kb3dzLCBpdCB3aWxsIHN0YXJ0IHdpdGggc29tZXRoaW5nIGxpa2UgXCJDOi9cIi5cbiAgICAgICAgICAgIC8vIE9uIFBvc2l4LCBpdCB3aWxsIHN0YXJ0IHdpdGggXCIvXCJcbiAgICAgICAgICAgIGlzRmlsZVVybCA9IGZhbHNlO1xuICAgICAgICAgICAgcGF0aCA9ICgwLCBpc193aW5kb3dzXzEuaXNXaW5kb3dzKSgpID8gcGF0aCA6IFwiL1wiICsgcGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdGVwIDQ6IE5vcm1hbGl6ZSBXaW5kb3dzIHBhdGhzICh1bmxlc3MgaXQncyBhIFwiZmlsZTovL1wiIFVSTClcbiAgICBpZiAoKDAsIGlzX3dpbmRvd3NfMS5pc1dpbmRvd3MpKCkgJiYgIWlzRmlsZVVybCkge1xuICAgICAgICAvLyBSZXBsYWNlIGZvcndhcmQgc2xhc2hlcyB3aXRoIGJhY2tzbGFzaGVzXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoZm9yd2FyZFNsYXNoUGF0dGVybiwgXCJcXFxcXCIpO1xuICAgICAgICAvLyBDYXBpdGFsaXplIHRoZSBkcml2ZSBsZXR0ZXJcbiAgICAgICAgaWYgKHBhdGguc3Vic3RyKDEsIDIpID09PSBcIjpcXFxcXCIpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoWzBdLnRvVXBwZXJDYXNlKCkgKyBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogQ29udmVydHMgYSAkcmVmIHBvaW50ZXIgdG8gYSB2YWxpZCBKU09OIFBhdGguXG4gKlxuICogQHBhcmFtIHBvaW50ZXJcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHNhZmVQb2ludGVyVG9QYXRoKHBvaW50ZXIpIHtcbiAgICBpZiAocG9pbnRlci5sZW5ndGggPD0gMSB8fCBwb2ludGVyWzBdICE9PSBcIiNcIiB8fCBwb2ludGVyWzFdICE9PSBcIi9cIikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBwb2ludGVyXG4gICAgICAgIC5zbGljZSgyKVxuICAgICAgICAuc3BsaXQoXCIvXCIpXG4gICAgICAgIC5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpLnJlcGxhY2UoanNvblBvaW50ZXJTbGFzaCwgXCIvXCIpLnJlcGxhY2UoanNvblBvaW50ZXJUaWxkZSwgXCJ+XCIpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVsYXRpdmUoZnJvbSwgdG8pIHtcbiAgICBpZiAoIWlzRmlsZVN5c3RlbVBhdGgoZnJvbSkgfHwgIWlzRmlsZVN5c3RlbVBhdGgodG8pKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGZyb20sIHRvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpciA9IHBhdGhfMS5kZWZhdWx0LmRpcm5hbWUoc3RyaXBIYXNoKGZyb20pKTtcbiAgICBjb25zdCB0b1BhdGggPSBzdHJpcEhhc2godG8pO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhdGhfMS5kZWZhdWx0LnJlbGF0aXZlKGZyb21EaXIsIHRvUGF0aCk7XG4gICAgcmV0dXJuIHJlc3VsdCArIGdldEhhc2godG8pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\n");

/***/ })

};
;
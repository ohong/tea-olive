"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@openapi-contrib+json-schema-to-openapi-schema@3.0.3";
exports.ids = ["vendor-chunks/@openapi-contrib+json-schema-to-openapi-schema@3.0.3"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@openapi-contrib+json-schema-to-openapi-schema@3.0.3/node_modules/@openapi-contrib/json-schema-to-openapi-schema/dist/index.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@openapi-contrib+json-schema-to-openapi-schema@3.0.3/node_modules/@openapi-contrib/json-schema-to-openapi-schema/dist/index.js ***!
  \***********************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  default: () => src_default\n});\nmodule.exports = __toCommonJS(src_exports);\nvar import_json_schema_walker = __webpack_require__(/*! json-schema-walker */ \"(rsc)/./node_modules/.pnpm/json-schema-walker@2.0.0/node_modules/json-schema-walker/dist/index.js\");\n\n// src/const.ts\nvar allowedKeywords = [\n  \"$ref\",\n  \"definitions\",\n  // From Schema\n  \"title\",\n  \"multipleOf\",\n  \"maximum\",\n  \"exclusiveMaximum\",\n  \"minimum\",\n  \"exclusiveMinimum\",\n  \"maxLength\",\n  \"minLength\",\n  \"pattern\",\n  \"maxItems\",\n  \"minItems\",\n  \"uniqueItems\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"required\",\n  \"enum\",\n  \"type\",\n  \"not\",\n  \"allOf\",\n  \"oneOf\",\n  \"anyOf\",\n  \"items\",\n  \"properties\",\n  \"additionalProperties\",\n  \"description\",\n  \"format\",\n  \"default\",\n  \"nullable\",\n  \"discriminator\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"example\",\n  \"externalDocs\",\n  \"deprecated\",\n  \"xml\"\n];\n\n// src/index.ts\nvar InvalidTypeError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"InvalidTypeError\";\n    this.message = message;\n  }\n};\nvar oasExtensionPrefix = \"x-\";\nvar handleDefinition = async (def, schema) => {\n  if (typeof def !== \"object\") {\n    return def;\n  }\n  const type = def.type;\n  if (type) {\n    const walker = new import_json_schema_walker.Walker();\n    await walker.loadSchema(\n      {\n        definitions: schema[\"definitions\"] || [],\n        ...def,\n        $schema: schema[\"$schema\"]\n      },\n      {\n        dereference: true,\n        cloneSchema: true,\n        dereferenceOptions: {\n          dereference: {\n            circular: \"ignore\"\n          }\n        }\n      }\n    );\n    await walker.walk(convertSchema, walker.vocabularies.DRAFT_07);\n    if (\"definitions\" in walker.rootSchema) {\n      delete walker.rootSchema.definitions;\n    }\n    return walker.rootSchema;\n  }\n  if (Array.isArray(def)) {\n    const typeArr = def;\n    const hasNull = typeArr.includes(\"null\");\n    if (hasNull) {\n      const actualTypes = typeArr.filter((l) => l !== \"null\");\n      return {\n        type: actualTypes.length === 1 ? actualTypes[0] : actualTypes,\n        nullable: true\n        // this is incorrect but thats ok, we are in the inbetween phase here\n      };\n    }\n  }\n  return def;\n};\nvar convert = async (schema, options) => {\n  const walker = new import_json_schema_walker.Walker();\n  const convertDefs = options?.convertUnreferencedDefinitions ?? true;\n  await walker.loadSchema(schema, options);\n  await walker.walk(convertSchema, walker.vocabularies.DRAFT_07);\n  const rootSchema = walker.rootSchema;\n  if (convertDefs && rootSchema?.definitions) {\n    for (const defName in rootSchema.definitions) {\n      const def = rootSchema.definitions[defName];\n      rootSchema.definitions[defName] = await handleDefinition(def, schema);\n    }\n  }\n  return rootSchema;\n};\nfunction stripIllegalKeywords(schema) {\n  if (typeof schema !== \"object\") {\n    return schema;\n  }\n  delete schema[\"$schema\"];\n  delete schema[\"$id\"];\n  if (\"id\" in schema) {\n    delete schema[\"id\"];\n  }\n  return schema;\n}\nfunction convertSchema(schema) {\n  if (!schema) {\n    return schema;\n  }\n  schema = stripIllegalKeywords(schema);\n  schema = convertTypes(schema);\n  schema = rewriteConst(schema);\n  schema = convertDependencies(schema);\n  schema = convertNullable(schema);\n  schema = rewriteIfThenElse(schema);\n  schema = rewriteExclusiveMinMax(schema);\n  schema = convertExamples(schema);\n  if (typeof schema[\"patternProperties\"] === \"object\") {\n    schema = convertPatternProperties(schema);\n  }\n  if (schema.type === \"array\" && typeof schema.items === \"undefined\") {\n    schema.items = {};\n  }\n  schema = convertIllegalKeywordsAsExtensions(schema);\n  return schema;\n}\nvar validTypes = /* @__PURE__ */ new Set([\n  \"null\",\n  \"boolean\",\n  \"object\",\n  \"array\",\n  \"number\",\n  \"string\",\n  \"integer\"\n]);\nfunction validateType(type) {\n  if (typeof type === \"object\" && !Array.isArray(type)) {\n    if (type.$ref) {\n      return;\n    }\n    if (type.properties) {\n      return;\n    }\n  }\n  const types = Array.isArray(type) ? type : [type];\n  types.forEach((type2) => {\n    if (type2 && !validTypes.has(type2))\n      throw new InvalidTypeError('Type \"' + type2 + '\" is not a valid type');\n  });\n}\nfunction convertDependencies(schema) {\n  const deps = schema.dependencies;\n  if (typeof deps !== \"object\") {\n    return schema;\n  }\n  delete schema[\"dependencies\"];\n  if (!Array.isArray(schema.allOf)) {\n    schema.allOf = [];\n  }\n  for (const key in deps) {\n    const foo = {\n      oneOf: [\n        {\n          not: {\n            required: [key]\n          }\n        },\n        {\n          required: [key, deps[key]].flat()\n        }\n      ]\n    };\n    schema.allOf.push(foo);\n  }\n  return schema;\n}\nfunction convertNullable(schema) {\n  for (const key of [\"oneOf\", \"anyOf\"]) {\n    const schemas = schema[key];\n    if (!schemas) continue;\n    if (!Array.isArray(schemas)) {\n      return schema;\n    }\n    const hasNullable = schemas.some((item) => item.type === \"null\");\n    if (!hasNullable) {\n      return schema;\n    }\n    const filtered = schemas.filter((l) => l.type !== \"null\");\n    for (const schemaEntry of filtered) {\n      schemaEntry.nullable = true;\n    }\n    schema[key] = filtered;\n  }\n  return schema;\n}\nfunction convertTypes(schema) {\n  if (typeof schema !== \"object\") {\n    return schema;\n  }\n  if (schema.type === void 0) {\n    return schema;\n  }\n  validateType(schema.type);\n  if (Array.isArray(schema.type)) {\n    if (schema.type.includes(\"null\")) {\n      schema.nullable = true;\n    }\n    const typesWithoutNull = schema.type.filter((type) => type !== \"null\");\n    if (typesWithoutNull.length === 0) {\n      delete schema.type;\n    } else if (typesWithoutNull.length === 1) {\n      schema.type = typesWithoutNull[0];\n    } else {\n      delete schema.type;\n      schema.anyOf = typesWithoutNull.map((type) => ({ type }));\n    }\n  } else if (schema.type === \"null\") {\n    delete schema.type;\n    schema.nullable = true;\n  }\n  return schema;\n}\nfunction convertPatternProperties(schema) {\n  schema[\"x-patternProperties\"] = schema[\"patternProperties\"];\n  delete schema[\"patternProperties\"];\n  schema.additionalProperties ?? (schema.additionalProperties = true);\n  return schema;\n}\nfunction convertIllegalKeywordsAsExtensions(schema) {\n  const keys = Object.keys(schema);\n  keys.filter(\n    (keyword) => !keyword.startsWith(oasExtensionPrefix) && !allowedKeywords.includes(keyword)\n  ).forEach((keyword) => {\n    const key = `${oasExtensionPrefix}${keyword}`;\n    schema[key] = schema[keyword];\n    delete schema[keyword];\n  });\n  return schema;\n}\nfunction convertExamples(schema) {\n  if (schema[\"examples\"] && Array.isArray(schema[\"examples\"])) {\n    schema[\"example\"] = schema[\"examples\"][0];\n    delete schema[\"examples\"];\n  }\n  return schema;\n}\nfunction rewriteConst(schema) {\n  if (Object.hasOwnProperty.call(schema, \"const\")) {\n    schema.enum = [schema.const];\n    delete schema.const;\n  }\n  return schema;\n}\nfunction rewriteIfThenElse(schema) {\n  if (typeof schema !== \"object\") {\n    return schema;\n  }\n  if (\"if\" in schema && schema.if && schema.then) {\n    schema.oneOf = [\n      { allOf: [schema.if, schema.then].filter(Boolean) },\n      { allOf: [{ not: schema.if }, schema.else].filter(Boolean) }\n    ];\n    delete schema.if;\n    delete schema.then;\n    delete schema.else;\n  }\n  return schema;\n}\nfunction rewriteExclusiveMinMax(schema) {\n  if (typeof schema.exclusiveMaximum === \"number\") {\n    schema.maximum = schema.exclusiveMaximum;\n    schema.exclusiveMaximum = true;\n  }\n  if (typeof schema.exclusiveMinimum === \"number\") {\n    schema.minimum = schema.exclusiveMinimum;\n    schema.exclusiveMinimum = true;\n  }\n  return schema;\n}\nvar src_default = convert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW5hcGktY29udHJpYitqc29uLXNjaGVtYS10by1vcGVuYXBpLXNjaGVtYUAzLjAuMy9ub2RlX21vZHVsZXMvQG9wZW5hcGktY29udHJpYi9qc29uLXNjaGVtYS10by1vcGVuYXBpLXNjaGVtYS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsNkhBQW9COztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSx1REFBdUQsTUFBTTtBQUM3RDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUIsRUFBRSxRQUFRO0FBQ2hEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlEQUFpRDtBQUN6RCxRQUFRLFVBQVUsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVhLW9saXZlLXdlYi8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbmFwaS1jb250cmliK2pzb24tc2NoZW1hLXRvLW9wZW5hcGktc2NoZW1hQDMuMC4zL25vZGVfbW9kdWxlcy9Ab3BlbmFwaS1jb250cmliL2pzb24tc2NoZW1hLXRvLW9wZW5hcGktc2NoZW1hL2Rpc3QvaW5kZXguanM/Yjg5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBzcmNfZGVmYXVsdFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzcmNfZXhwb3J0cyk7XG52YXIgaW1wb3J0X2pzb25fc2NoZW1hX3dhbGtlciA9IHJlcXVpcmUoXCJqc29uLXNjaGVtYS13YWxrZXJcIik7XG5cbi8vIHNyYy9jb25zdC50c1xudmFyIGFsbG93ZWRLZXl3b3JkcyA9IFtcbiAgXCIkcmVmXCIsXG4gIFwiZGVmaW5pdGlvbnNcIixcbiAgLy8gRnJvbSBTY2hlbWFcbiAgXCJ0aXRsZVwiLFxuICBcIm11bHRpcGxlT2ZcIixcbiAgXCJtYXhpbXVtXCIsXG4gIFwiZXhjbHVzaXZlTWF4aW11bVwiLFxuICBcIm1pbmltdW1cIixcbiAgXCJleGNsdXNpdmVNaW5pbXVtXCIsXG4gIFwibWF4TGVuZ3RoXCIsXG4gIFwibWluTGVuZ3RoXCIsXG4gIFwicGF0dGVyblwiLFxuICBcIm1heEl0ZW1zXCIsXG4gIFwibWluSXRlbXNcIixcbiAgXCJ1bmlxdWVJdGVtc1wiLFxuICBcIm1heFByb3BlcnRpZXNcIixcbiAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gIFwicmVxdWlyZWRcIixcbiAgXCJlbnVtXCIsXG4gIFwidHlwZVwiLFxuICBcIm5vdFwiLFxuICBcImFsbE9mXCIsXG4gIFwib25lT2ZcIixcbiAgXCJhbnlPZlwiLFxuICBcIml0ZW1zXCIsXG4gIFwicHJvcGVydGllc1wiLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gIFwiZGVzY3JpcHRpb25cIixcbiAgXCJmb3JtYXRcIixcbiAgXCJkZWZhdWx0XCIsXG4gIFwibnVsbGFibGVcIixcbiAgXCJkaXNjcmltaW5hdG9yXCIsXG4gIFwicmVhZE9ubHlcIixcbiAgXCJ3cml0ZU9ubHlcIixcbiAgXCJleGFtcGxlXCIsXG4gIFwiZXh0ZXJuYWxEb2NzXCIsXG4gIFwiZGVwcmVjYXRlZFwiLFxuICBcInhtbFwiXG5dO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBJbnZhbGlkVHlwZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkludmFsaWRUeXBlRXJyb3JcIjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG59O1xudmFyIG9hc0V4dGVuc2lvblByZWZpeCA9IFwieC1cIjtcbnZhciBoYW5kbGVEZWZpbml0aW9uID0gYXN5bmMgKGRlZiwgc2NoZW1hKSA9PiB7XG4gIGlmICh0eXBlb2YgZGVmICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGRlZjtcbiAgfVxuICBjb25zdCB0eXBlID0gZGVmLnR5cGU7XG4gIGlmICh0eXBlKSB7XG4gICAgY29uc3Qgd2Fsa2VyID0gbmV3IGltcG9ydF9qc29uX3NjaGVtYV93YWxrZXIuV2Fsa2VyKCk7XG4gICAgYXdhaXQgd2Fsa2VyLmxvYWRTY2hlbWEoXG4gICAgICB7XG4gICAgICAgIGRlZmluaXRpb25zOiBzY2hlbWFbXCJkZWZpbml0aW9uc1wiXSB8fCBbXSxcbiAgICAgICAgLi4uZGVmLFxuICAgICAgICAkc2NoZW1hOiBzY2hlbWFbXCIkc2NoZW1hXCJdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBkZXJlZmVyZW5jZTogdHJ1ZSxcbiAgICAgICAgY2xvbmVTY2hlbWE6IHRydWUsXG4gICAgICAgIGRlcmVmZXJlbmNlT3B0aW9uczoge1xuICAgICAgICAgIGRlcmVmZXJlbmNlOiB7XG4gICAgICAgICAgICBjaXJjdWxhcjogXCJpZ25vcmVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgYXdhaXQgd2Fsa2VyLndhbGsoY29udmVydFNjaGVtYSwgd2Fsa2VyLnZvY2FidWxhcmllcy5EUkFGVF8wNyk7XG4gICAgaWYgKFwiZGVmaW5pdGlvbnNcIiBpbiB3YWxrZXIucm9vdFNjaGVtYSkge1xuICAgICAgZGVsZXRlIHdhbGtlci5yb290U2NoZW1hLmRlZmluaXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gd2Fsa2VyLnJvb3RTY2hlbWE7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmKSkge1xuICAgIGNvbnN0IHR5cGVBcnIgPSBkZWY7XG4gICAgY29uc3QgaGFzTnVsbCA9IHR5cGVBcnIuaW5jbHVkZXMoXCJudWxsXCIpO1xuICAgIGlmIChoYXNOdWxsKSB7XG4gICAgICBjb25zdCBhY3R1YWxUeXBlcyA9IHR5cGVBcnIuZmlsdGVyKChsKSA9PiBsICE9PSBcIm51bGxcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBhY3R1YWxUeXBlcy5sZW5ndGggPT09IDEgPyBhY3R1YWxUeXBlc1swXSA6IGFjdHVhbFR5cGVzLFxuICAgICAgICBudWxsYWJsZTogdHJ1ZVxuICAgICAgICAvLyB0aGlzIGlzIGluY29ycmVjdCBidXQgdGhhdHMgb2ssIHdlIGFyZSBpbiB0aGUgaW5iZXR3ZWVuIHBoYXNlIGhlcmVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWY7XG59O1xudmFyIGNvbnZlcnQgPSBhc3luYyAoc2NoZW1hLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHdhbGtlciA9IG5ldyBpbXBvcnRfanNvbl9zY2hlbWFfd2Fsa2VyLldhbGtlcigpO1xuICBjb25zdCBjb252ZXJ0RGVmcyA9IG9wdGlvbnM/LmNvbnZlcnRVbnJlZmVyZW5jZWREZWZpbml0aW9ucyA/PyB0cnVlO1xuICBhd2FpdCB3YWxrZXIubG9hZFNjaGVtYShzY2hlbWEsIG9wdGlvbnMpO1xuICBhd2FpdCB3YWxrZXIud2Fsayhjb252ZXJ0U2NoZW1hLCB3YWxrZXIudm9jYWJ1bGFyaWVzLkRSQUZUXzA3KTtcbiAgY29uc3Qgcm9vdFNjaGVtYSA9IHdhbGtlci5yb290U2NoZW1hO1xuICBpZiAoY29udmVydERlZnMgJiYgcm9vdFNjaGVtYT8uZGVmaW5pdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGRlZk5hbWUgaW4gcm9vdFNjaGVtYS5kZWZpbml0aW9ucykge1xuICAgICAgY29uc3QgZGVmID0gcm9vdFNjaGVtYS5kZWZpbml0aW9uc1tkZWZOYW1lXTtcbiAgICAgIHJvb3RTY2hlbWEuZGVmaW5pdGlvbnNbZGVmTmFtZV0gPSBhd2FpdCBoYW5kbGVEZWZpbml0aW9uKGRlZiwgc2NoZW1hKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3RTY2hlbWE7XG59O1xuZnVuY3Rpb24gc3RyaXBJbGxlZ2FsS2V5d29yZHMoc2NoZW1hKSB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICBkZWxldGUgc2NoZW1hW1wiJHNjaGVtYVwiXTtcbiAgZGVsZXRlIHNjaGVtYVtcIiRpZFwiXTtcbiAgaWYgKFwiaWRcIiBpbiBzY2hlbWEpIHtcbiAgICBkZWxldGUgc2NoZW1hW1wiaWRcIl07XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTY2hlbWEoc2NoZW1hKSB7XG4gIGlmICghc2NoZW1hKSB7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICBzY2hlbWEgPSBzdHJpcElsbGVnYWxLZXl3b3JkcyhzY2hlbWEpO1xuICBzY2hlbWEgPSBjb252ZXJ0VHlwZXMoc2NoZW1hKTtcbiAgc2NoZW1hID0gcmV3cml0ZUNvbnN0KHNjaGVtYSk7XG4gIHNjaGVtYSA9IGNvbnZlcnREZXBlbmRlbmNpZXMoc2NoZW1hKTtcbiAgc2NoZW1hID0gY29udmVydE51bGxhYmxlKHNjaGVtYSk7XG4gIHNjaGVtYSA9IHJld3JpdGVJZlRoZW5FbHNlKHNjaGVtYSk7XG4gIHNjaGVtYSA9IHJld3JpdGVFeGNsdXNpdmVNaW5NYXgoc2NoZW1hKTtcbiAgc2NoZW1hID0gY29udmVydEV4YW1wbGVzKHNjaGVtYSk7XG4gIGlmICh0eXBlb2Ygc2NoZW1hW1wicGF0dGVyblByb3BlcnRpZXNcIl0gPT09IFwib2JqZWN0XCIpIHtcbiAgICBzY2hlbWEgPSBjb252ZXJ0UGF0dGVyblByb3BlcnRpZXMoc2NoZW1hKTtcbiAgfVxuICBpZiAoc2NoZW1hLnR5cGUgPT09IFwiYXJyYXlcIiAmJiB0eXBlb2Ygc2NoZW1hLml0ZW1zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZW1hLml0ZW1zID0ge307XG4gIH1cbiAgc2NoZW1hID0gY29udmVydElsbGVnYWxLZXl3b3Jkc0FzRXh0ZW5zaW9ucyhzY2hlbWEpO1xuICByZXR1cm4gc2NoZW1hO1xufVxudmFyIHZhbGlkVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwibnVsbFwiLFxuICBcImJvb2xlYW5cIixcbiAgXCJvYmplY3RcIixcbiAgXCJhcnJheVwiLFxuICBcIm51bWJlclwiLFxuICBcInN0cmluZ1wiLFxuICBcImludGVnZXJcIlxuXSk7XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICBpZiAodHlwZS4kcmVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlLnByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgdHlwZXMgPSBBcnJheS5pc0FycmF5KHR5cGUpID8gdHlwZSA6IFt0eXBlXTtcbiAgdHlwZXMuZm9yRWFjaCgodHlwZTIpID0+IHtcbiAgICBpZiAodHlwZTIgJiYgIXZhbGlkVHlwZXMuaGFzKHR5cGUyKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHlwZUVycm9yKCdUeXBlIFwiJyArIHR5cGUyICsgJ1wiIGlzIG5vdCBhIHZhbGlkIHR5cGUnKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGVwZW5kZW5jaWVzKHNjaGVtYSkge1xuICBjb25zdCBkZXBzID0gc2NoZW1hLmRlcGVuZGVuY2llcztcbiAgaWYgKHR5cGVvZiBkZXBzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICBkZWxldGUgc2NoZW1hW1wiZGVwZW5kZW5jaWVzXCJdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hLmFsbE9mKSkge1xuICAgIHNjaGVtYS5hbGxPZiA9IFtdO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGRlcHMpIHtcbiAgICBjb25zdCBmb28gPSB7XG4gICAgICBvbmVPZjogW1xuICAgICAgICB7XG4gICAgICAgICAgbm90OiB7XG4gICAgICAgICAgICByZXF1aXJlZDogW2tleV1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByZXF1aXJlZDogW2tleSwgZGVwc1trZXldXS5mbGF0KClcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gICAgc2NoZW1hLmFsbE9mLnB1c2goZm9vKTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuZnVuY3Rpb24gY29udmVydE51bGxhYmxlKHNjaGVtYSkge1xuICBmb3IgKGNvbnN0IGtleSBvZiBbXCJvbmVPZlwiLCBcImFueU9mXCJdKSB7XG4gICAgY29uc3Qgc2NoZW1hcyA9IHNjaGVtYVtrZXldO1xuICAgIGlmICghc2NoZW1hcykgY29udGludWU7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKSB7XG4gICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICBjb25zdCBoYXNOdWxsYWJsZSA9IHNjaGVtYXMuc29tZSgoaXRlbSkgPT4gaXRlbS50eXBlID09PSBcIm51bGxcIik7XG4gICAgaWYgKCFoYXNOdWxsYWJsZSkge1xuICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyZWQgPSBzY2hlbWFzLmZpbHRlcigobCkgPT4gbC50eXBlICE9PSBcIm51bGxcIik7XG4gICAgZm9yIChjb25zdCBzY2hlbWFFbnRyeSBvZiBmaWx0ZXJlZCkge1xuICAgICAgc2NoZW1hRW50cnkubnVsbGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBzY2hlbWFba2V5XSA9IGZpbHRlcmVkO1xuICB9XG4gIHJldHVybiBzY2hlbWE7XG59XG5mdW5jdGlvbiBjb252ZXJ0VHlwZXMoc2NoZW1hKSB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICBpZiAoc2NoZW1hLnR5cGUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbiAgdmFsaWRhdGVUeXBlKHNjaGVtYS50eXBlKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpKSB7XG4gICAgaWYgKHNjaGVtYS50eXBlLmluY2x1ZGVzKFwibnVsbFwiKSkge1xuICAgICAgc2NoZW1hLm51bGxhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZXNXaXRob3V0TnVsbCA9IHNjaGVtYS50eXBlLmZpbHRlcigodHlwZSkgPT4gdHlwZSAhPT0gXCJudWxsXCIpO1xuICAgIGlmICh0eXBlc1dpdGhvdXROdWxsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHNjaGVtYS50eXBlO1xuICAgIH0gZWxzZSBpZiAodHlwZXNXaXRob3V0TnVsbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNjaGVtYS50eXBlID0gdHlwZXNXaXRob3V0TnVsbFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHNjaGVtYS50eXBlO1xuICAgICAgc2NoZW1hLmFueU9mID0gdHlwZXNXaXRob3V0TnVsbC5tYXAoKHR5cGUpID0+ICh7IHR5cGUgfSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzY2hlbWEudHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICBkZWxldGUgc2NoZW1hLnR5cGU7XG4gICAgc2NoZW1hLm51bGxhYmxlID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuZnVuY3Rpb24gY29udmVydFBhdHRlcm5Qcm9wZXJ0aWVzKHNjaGVtYSkge1xuICBzY2hlbWFbXCJ4LXBhdHRlcm5Qcm9wZXJ0aWVzXCJdID0gc2NoZW1hW1wicGF0dGVyblByb3BlcnRpZXNcIl07XG4gIGRlbGV0ZSBzY2hlbWFbXCJwYXR0ZXJuUHJvcGVydGllc1wiXTtcbiAgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID8/IChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPSB0cnVlKTtcbiAgcmV0dXJuIHNjaGVtYTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRJbGxlZ2FsS2V5d29yZHNBc0V4dGVuc2lvbnMoc2NoZW1hKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICBrZXlzLmZpbHRlcihcbiAgICAoa2V5d29yZCkgPT4gIWtleXdvcmQuc3RhcnRzV2l0aChvYXNFeHRlbnNpb25QcmVmaXgpICYmICFhbGxvd2VkS2V5d29yZHMuaW5jbHVkZXMoa2V5d29yZClcbiAgKS5mb3JFYWNoKChrZXl3b3JkKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gYCR7b2FzRXh0ZW5zaW9uUHJlZml4fSR7a2V5d29yZH1gO1xuICAgIHNjaGVtYVtrZXldID0gc2NoZW1hW2tleXdvcmRdO1xuICAgIGRlbGV0ZSBzY2hlbWFba2V5d29yZF07XG4gIH0pO1xuICByZXR1cm4gc2NoZW1hO1xufVxuZnVuY3Rpb24gY29udmVydEV4YW1wbGVzKHNjaGVtYSkge1xuICBpZiAoc2NoZW1hW1wiZXhhbXBsZXNcIl0gJiYgQXJyYXkuaXNBcnJheShzY2hlbWFbXCJleGFtcGxlc1wiXSkpIHtcbiAgICBzY2hlbWFbXCJleGFtcGxlXCJdID0gc2NoZW1hW1wiZXhhbXBsZXNcIl1bMF07XG4gICAgZGVsZXRlIHNjaGVtYVtcImV4YW1wbGVzXCJdO1xuICB9XG4gIHJldHVybiBzY2hlbWE7XG59XG5mdW5jdGlvbiByZXdyaXRlQ29uc3Qoc2NoZW1hKSB7XG4gIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsIFwiY29uc3RcIikpIHtcbiAgICBzY2hlbWEuZW51bSA9IFtzY2hlbWEuY29uc3RdO1xuICAgIGRlbGV0ZSBzY2hlbWEuY29uc3Q7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cbmZ1bmN0aW9uIHJld3JpdGVJZlRoZW5FbHNlKHNjaGVtYSkge1xuICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbiAgaWYgKFwiaWZcIiBpbiBzY2hlbWEgJiYgc2NoZW1hLmlmICYmIHNjaGVtYS50aGVuKSB7XG4gICAgc2NoZW1hLm9uZU9mID0gW1xuICAgICAgeyBhbGxPZjogW3NjaGVtYS5pZiwgc2NoZW1hLnRoZW5dLmZpbHRlcihCb29sZWFuKSB9LFxuICAgICAgeyBhbGxPZjogW3sgbm90OiBzY2hlbWEuaWYgfSwgc2NoZW1hLmVsc2VdLmZpbHRlcihCb29sZWFuKSB9XG4gICAgXTtcbiAgICBkZWxldGUgc2NoZW1hLmlmO1xuICAgIGRlbGV0ZSBzY2hlbWEudGhlbjtcbiAgICBkZWxldGUgc2NoZW1hLmVsc2U7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cbmZ1bmN0aW9uIHJld3JpdGVFeGNsdXNpdmVNaW5NYXgoc2NoZW1hKSB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICBzY2hlbWEubWF4aW11bSA9IHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtO1xuICAgIHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgc2NoZW1hLm1pbmltdW0gPSBzY2hlbWEuZXhjbHVzaXZlTWluaW11bTtcbiAgICBzY2hlbWEuZXhjbHVzaXZlTWluaW11bSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cbnZhciBzcmNfZGVmYXVsdCA9IGNvbnZlcnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@openapi-contrib+json-schema-to-openapi-schema@3.0.3/node_modules/@openapi-contrib/json-schema-to-openapi-schema/dist/index.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-schema-walker@2.0.0";
exports.ids = ["vendor-chunks/json-schema-walker@2.0.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/json-schema-walker@2.0.0/node_modules/json-schema-walker/dist/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/json-schema-walker@2.0.0/node_modules/json-schema-walker/dist/index.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Walker = void 0;\nconst clone_1 = __importDefault(__webpack_require__(/*! clone */ \"(rsc)/./node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js\"));\nconst json_schema_ref_parser_1 = __importDefault(__webpack_require__(/*! @apidevtools/json-schema-ref-parser */ \"(rsc)/./node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/index.js\"));\nconst visited = Symbol(\"visited\");\nconst NEXT_SCHEMA_KEYWORD = Symbol(\"NEXT_SCHEMA_KEYWORD\");\nconst NEXT_LDO_KEYWORD = Symbol(\"NEXT_LDO_KEYWORD\");\n/**\n * This is a hotfix and really only a partial solution as it does not cover all cases.\n *\n * But it's the best we can do until we find or build a better library to handle references.\n *\n * original source https://github.com/asyncapi/modelina/pull/829/files\n */\nconst handleRootReference = (input) => {\n    //Because of https://github.com/APIDevTools/json-schema-ref-parser/issues/201 the tool cannot handle root references.\n    //This really is a bad patch to fix an underlying problem, but until a full library is available, this is best we can do.\n    const hasRootRef = input.$ref !== undefined;\n    if (hasRootRef) {\n        //When we encounter it, manually try to resolve the reference in the definitions section\n        const hasDefinitionSection = input.definitions !== undefined;\n        if (hasDefinitionSection) {\n            const definitionLink = \"#/definitions/\";\n            const referenceLink = input.$ref.slice(0, definitionLink.length);\n            const referenceIsLocal = referenceLink === definitionLink;\n            if (referenceIsLocal) {\n                const definitionName = input.$ref.slice(definitionLink.length);\n                const definition = input.definitions[String(definitionName)];\n                const definitionExist = definition !== undefined;\n                if (definitionExist) {\n                    delete input.$ref;\n                    return { ...definition, ...input };\n                }\n            }\n        }\n    }\n    return input;\n};\nclass Walker {\n    constructor() {\n        this.loadSchema = async (schema, options) => {\n            const { cloneSchema = true, dereference = false, dereferenceOptions } = options || {};\n            this.rootSchema = cloneSchema ? (0, clone_1.default)(schema) : schema;\n            if (dereference) {\n                const parser = new json_schema_ref_parser_1.default();\n                this.rootSchema = (await parser.dereference(handleRootReference(schema), dereferenceOptions || {}));\n            }\n        };\n        this.walk = async (processor, vocabulary) => {\n            this.vocabulary = vocabulary ?? this.vocabularies.DRAFT_07;\n            this.walker = processor;\n            this.walker(this.rootSchema);\n            await this.subschemaWalk(this.rootSchema);\n            // clean up the symbols we injected to check for circular references\n            this.cleanupVisited(this.rootSchema);\n        };\n        this.cleanupVisited = (schema) => {\n            for (const entry of Object.values(schema)) {\n                if (entry && typeof entry === \"object\" && entry[visited]) {\n                    delete entry[visited];\n                    this.cleanupVisited(entry);\n                }\n            }\n        };\n        this.isValidSubSchema = (schema) => (schema instanceof Object && !Array.isArray(schema)) || typeof schema === \"boolean\";\n        this.applyUserProcessor = (schema, key) => {\n            const schemaElement = schema[key];\n            if (typeof schemaElement !== \"object\") {\n                return;\n            }\n            schemaElement[visited] = true;\n            this.walker(schemaElement);\n            this.subschemaWalk(schemaElement);\n        };\n        this.subschemaWalk = (schema) => {\n            for (const keyword in schema) {\n                try {\n                    this.processSchemaKey(schema, keyword);\n                }\n                catch (e) {\n                    if (e !== NEXT_SCHEMA_KEYWORD) {\n                        throw e;\n                    }\n                }\n            }\n        };\n        // These are the processors\n        this.processSchemaKey = (schema, keyword) => {\n            if (!schema[keyword] || typeof schema[keyword] !== \"object\") {\n                return;\n            }\n            const processorFunction = this.vocabulary[keyword];\n            if (!processorFunction) {\n                return;\n            }\n            schema[keyword][visited] = true;\n            processorFunction(schema, keyword);\n        };\n        this.processObjectOfSchemas = (schema, keyword) => {\n            for (const prop of Object.getOwnPropertyNames(schema[keyword])) {\n                const schemaElem = schema[keyword][prop];\n                if (typeof schemaElem === \"object\" && schemaElem) {\n                    this.applyUserProcessor(schema[keyword], prop);\n                }\n            }\n        };\n        this.processArrayOfSchemas = (schema, keyword) => {\n            for (const prop of Object.getOwnPropertyNames(schema[keyword])) {\n                const schemaElem = schema[keyword][prop];\n                if (schemaElem && typeof schemaElem === \"object\") {\n                    this.applyUserProcessor(schema[keyword], prop);\n                }\n            }\n            for (let i = 0; i < schema[keyword].length; i++) {\n                this.applyUserProcessor(schema[keyword], i);\n            }\n        };\n        this.processSingleOrArrayOfSchemas = (schema, keyword) => {\n            if (this.isValidSubSchema(schema[keyword])) {\n                this.processSingleSchema(schema, keyword);\n            }\n            else {\n                this.processArrayOfSchemas(schema, keyword);\n            }\n        };\n        this.processSingleSchema = (schema, keyword) => {\n            this.applyUserProcessor(schema, keyword);\n        };\n        /**\n         * Loop over the links and apply the callbacks, while\n         * handling LDO keyword deletions by catching NEXT_LDO_KEYWORD.\n         */\n        this.getProcessLinks = (ldoVocabulary) => {\n            return (schema, keyword) => {\n                for (const ldo of schema.links) {\n                    for (const key in ldo) {\n                        try {\n                            ldoVocabulary[keyword]?.(schema, key);\n                        }\n                        catch (e) {\n                            if (e !== NEXT_LDO_KEYWORD) {\n                                throw e;\n                            }\n                        }\n                    }\n                }\n            };\n        };\n        // vocabulary initialization\n        this.initVocabulary = () => {\n            const DRAFT_04 = {\n                properties: this.processObjectOfSchemas,\n                patternProperties: this.processObjectOfSchemas,\n                additionalProperties: this.processSingleSchema,\n                dependencies: this.processObjectOfSchemas,\n                items: this.processSingleOrArrayOfSchemas,\n                additionalItems: this.processSingleSchema,\n                allOf: this.processArrayOfSchemas,\n                anyOf: this.processArrayOfSchemas,\n                oneOf: this.processArrayOfSchemas,\n                not: this.processSingleSchema,\n                if: this.processSingleSchema,\n                then: this.processSingleSchema,\n                else: this.processSingleSchema,\n            };\n            /**\n             * LDO keywords call _apply directly as they have a different\n             * mapping from the schema keyword into the path that _apply\n             * expects.  This is done in the function returned from\n             * _getProcessLinks();\n             */\n            const DRAFT_04_HYPER_LDO = {\n                schema: this.applyUserProcessor,\n                targetSchema: this.applyUserProcessor,\n            };\n            const DRAFT_04_HYPER = {\n                ...DRAFT_04,\n                links: this.getProcessLinks(DRAFT_04_HYPER_LDO),\n            };\n            const DRAFT_06 = {\n                ...DRAFT_04,\n                propertyNames: this.processObjectOfSchemas,\n            };\n            const DRAFT_06_HYPER_LDO = {\n                hrefSchema: this.applyUserProcessor,\n                targetSchema: this.applyUserProcessor,\n                submissionSchema: this.applyUserProcessor,\n            };\n            const DRAFT_06_HYPER = {\n                ...DRAFT_06,\n                links: this.getProcessLinks(DRAFT_06_HYPER_LDO),\n            };\n            const DRAFT_07 = { ...DRAFT_06 };\n            const DRAFT_07_HYPER_LDO = {\n                ...DRAFT_06_HYPER_LDO,\n                headerSchema: this.applyUserProcessor,\n            };\n            const DRAFT_07_HYPER = {\n                ...DRAFT_07,\n                links: this.getProcessLinks(DRAFT_07_HYPER_LDO),\n            };\n            const CLOUDFLARE_DOCA = {\n                ...DRAFT_04,\n                links: this.getProcessLinks({\n                    ...DRAFT_04_HYPER_LDO,\n                    ...DRAFT_07_HYPER_LDO,\n                }),\n            };\n            this.vocabularies = {\n                DRAFT_04,\n                DRAFT_04_HYPER,\n                DRAFT_04_HYPER_LDO,\n                DRAFT_06,\n                DRAFT_06_HYPER,\n                DRAFT_06_HYPER_LDO,\n                DRAFT_07,\n                DRAFT_07_HYPER,\n                DRAFT_07_HYPER_LDO,\n                CLOUDFLARE_DOCA,\n            };\n        };\n        this.initVocabulary();\n    }\n}\nexports.Walker = Walker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vanNvbi1zY2hlbWEtd2Fsa2VyQDIuMC4wL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS13YWxrZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxnQ0FBZ0MsbUJBQU8sQ0FBQyxpRkFBTztBQUMvQyxpREFBaUQsbUJBQU8sQ0FBQyxxTEFBcUM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4REFBOEQ7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsaUhBQWlIO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZWEtb2xpdmUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2pzb24tc2NoZW1hLXdhbGtlckAyLjAuMC9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtd2Fsa2VyL2Rpc3QvaW5kZXguanM/OWUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2Fsa2VyID0gdm9pZCAwO1xuY29uc3QgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xvbmVcIikpO1xuY29uc3QganNvbl9zY2hlbWFfcmVmX3BhcnNlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlclwiKSk7XG5jb25zdCB2aXNpdGVkID0gU3ltYm9sKFwidmlzaXRlZFwiKTtcbmNvbnN0IE5FWFRfU0NIRU1BX0tFWVdPUkQgPSBTeW1ib2woXCJORVhUX1NDSEVNQV9LRVlXT1JEXCIpO1xuY29uc3QgTkVYVF9MRE9fS0VZV09SRCA9IFN5bWJvbChcIk5FWFRfTERPX0tFWVdPUkRcIik7XG4vKipcbiAqIFRoaXMgaXMgYSBob3RmaXggYW5kIHJlYWxseSBvbmx5IGEgcGFydGlhbCBzb2x1dGlvbiBhcyBpdCBkb2VzIG5vdCBjb3ZlciBhbGwgY2FzZXMuXG4gKlxuICogQnV0IGl0J3MgdGhlIGJlc3Qgd2UgY2FuIGRvIHVudGlsIHdlIGZpbmQgb3IgYnVpbGQgYSBiZXR0ZXIgbGlicmFyeSB0byBoYW5kbGUgcmVmZXJlbmNlcy5cbiAqXG4gKiBvcmlnaW5hbCBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL2FzeW5jYXBpL21vZGVsaW5hL3B1bGwvODI5L2ZpbGVzXG4gKi9cbmNvbnN0IGhhbmRsZVJvb3RSZWZlcmVuY2UgPSAoaW5wdXQpID0+IHtcbiAgICAvL0JlY2F1c2Ugb2YgaHR0cHM6Ly9naXRodWIuY29tL0FQSURldlRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvaXNzdWVzLzIwMSB0aGUgdG9vbCBjYW5ub3QgaGFuZGxlIHJvb3QgcmVmZXJlbmNlcy5cbiAgICAvL1RoaXMgcmVhbGx5IGlzIGEgYmFkIHBhdGNoIHRvIGZpeCBhbiB1bmRlcmx5aW5nIHByb2JsZW0sIGJ1dCB1bnRpbCBhIGZ1bGwgbGlicmFyeSBpcyBhdmFpbGFibGUsIHRoaXMgaXMgYmVzdCB3ZSBjYW4gZG8uXG4gICAgY29uc3QgaGFzUm9vdFJlZiA9IGlucHV0LiRyZWYgIT09IHVuZGVmaW5lZDtcbiAgICBpZiAoaGFzUm9vdFJlZikge1xuICAgICAgICAvL1doZW4gd2UgZW5jb3VudGVyIGl0LCBtYW51YWxseSB0cnkgdG8gcmVzb2x2ZSB0aGUgcmVmZXJlbmNlIGluIHRoZSBkZWZpbml0aW9ucyBzZWN0aW9uXG4gICAgICAgIGNvbnN0IGhhc0RlZmluaXRpb25TZWN0aW9uID0gaW5wdXQuZGVmaW5pdGlvbnMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGhhc0RlZmluaXRpb25TZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uTGluayA9IFwiIy9kZWZpbml0aW9ucy9cIjtcbiAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZUxpbmsgPSBpbnB1dC4kcmVmLnNsaWNlKDAsIGRlZmluaXRpb25MaW5rLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2VJc0xvY2FsID0gcmVmZXJlbmNlTGluayA9PT0gZGVmaW5pdGlvbkxpbms7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlSXNMb2NhbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25OYW1lID0gaW5wdXQuJHJlZi5zbGljZShkZWZpbml0aW9uTGluay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBpbnB1dC5kZWZpbml0aW9uc1tTdHJpbmcoZGVmaW5pdGlvbk5hbWUpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uRXhpc3QgPSBkZWZpbml0aW9uICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb25FeGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaW5wdXQuJHJlZjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uZGVmaW5pdGlvbiwgLi4uaW5wdXQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xufTtcbmNsYXNzIFdhbGtlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubG9hZFNjaGVtYSA9IGFzeW5jIChzY2hlbWEsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2xvbmVTY2hlbWEgPSB0cnVlLCBkZXJlZmVyZW5jZSA9IGZhbHNlLCBkZXJlZmVyZW5jZU9wdGlvbnMgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB0aGlzLnJvb3RTY2hlbWEgPSBjbG9uZVNjaGVtYSA/ICgwLCBjbG9uZV8xLmRlZmF1bHQpKHNjaGVtYSkgOiBzY2hlbWE7XG4gICAgICAgICAgICBpZiAoZGVyZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcganNvbl9zY2hlbWFfcmVmX3BhcnNlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RTY2hlbWEgPSAoYXdhaXQgcGFyc2VyLmRlcmVmZXJlbmNlKGhhbmRsZVJvb3RSZWZlcmVuY2Uoc2NoZW1hKSwgZGVyZWZlcmVuY2VPcHRpb25zIHx8IHt9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2FsayA9IGFzeW5jIChwcm9jZXNzb3IsIHZvY2FidWxhcnkpID0+IHtcbiAgICAgICAgICAgIHRoaXMudm9jYWJ1bGFyeSA9IHZvY2FidWxhcnkgPz8gdGhpcy52b2NhYnVsYXJpZXMuRFJBRlRfMDc7XG4gICAgICAgICAgICB0aGlzLndhbGtlciA9IHByb2Nlc3NvcjtcbiAgICAgICAgICAgIHRoaXMud2Fsa2VyKHRoaXMucm9vdFNjaGVtYSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN1YnNjaGVtYVdhbGsodGhpcy5yb290U2NoZW1hKTtcbiAgICAgICAgICAgIC8vIGNsZWFuIHVwIHRoZSBzeW1ib2xzIHdlIGluamVjdGVkIHRvIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgICAgICB0aGlzLmNsZWFudXBWaXNpdGVkKHRoaXMucm9vdFNjaGVtYSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYW51cFZpc2l0ZWQgPSAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIE9iamVjdC52YWx1ZXMoc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeSAmJiB0eXBlb2YgZW50cnkgPT09IFwib2JqZWN0XCIgJiYgZW50cnlbdmlzaXRlZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVudHJ5W3Zpc2l0ZWRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBWaXNpdGVkKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNWYWxpZFN1YlNjaGVtYSA9IChzY2hlbWEpID0+IChzY2hlbWEgaW5zdGFuY2VvZiBPYmplY3QgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkgfHwgdHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCI7XG4gICAgICAgIHRoaXMuYXBwbHlVc2VyUHJvY2Vzc29yID0gKHNjaGVtYSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWFFbGVtZW50ID0gc2NoZW1hW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUVsZW1lbnQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2hlbWFFbGVtZW50W3Zpc2l0ZWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMud2Fsa2VyKHNjaGVtYUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY2hlbWFXYWxrKHNjaGVtYUVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1YnNjaGVtYVdhbGsgPSAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzU2NoZW1hS2V5KHNjaGVtYSwga2V5d29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlICE9PSBORVhUX1NDSEVNQV9LRVlXT1JEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIHByb2Nlc3NvcnNcbiAgICAgICAgdGhpcy5wcm9jZXNzU2NoZW1hS2V5ID0gKHNjaGVtYSwga2V5d29yZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzY2hlbWFba2V5d29yZF0gfHwgdHlwZW9mIHNjaGVtYVtrZXl3b3JkXSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvckZ1bmN0aW9uID0gdGhpcy52b2NhYnVsYXJ5W2tleXdvcmRdO1xuICAgICAgICAgICAgaWYgKCFwcm9jZXNzb3JGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjaGVtYVtrZXl3b3JkXVt2aXNpdGVkXSA9IHRydWU7XG4gICAgICAgICAgICBwcm9jZXNzb3JGdW5jdGlvbihzY2hlbWEsIGtleXdvcmQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3NPYmplY3RPZlNjaGVtYXMgPSAoc2NoZW1hLCBrZXl3b3JkKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc2NoZW1hW2tleXdvcmRdKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYUVsZW0gPSBzY2hlbWFba2V5d29yZF1bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFFbGVtID09PSBcIm9iamVjdFwiICYmIHNjaGVtYUVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseVVzZXJQcm9jZXNzb3Ioc2NoZW1hW2tleXdvcmRdLCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc0FycmF5T2ZTY2hlbWFzID0gKHNjaGVtYSwga2V5d29yZCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNjaGVtYVtrZXl3b3JkXSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFFbGVtID0gc2NoZW1hW2tleXdvcmRdW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWFFbGVtICYmIHR5cGVvZiBzY2hlbWFFbGVtID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlVc2VyUHJvY2Vzc29yKHNjaGVtYVtrZXl3b3JkXSwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWFba2V5d29yZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VXNlclByb2Nlc3NvcihzY2hlbWFba2V5d29yZF0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3NTaW5nbGVPckFycmF5T2ZTY2hlbWFzID0gKHNjaGVtYSwga2V5d29yZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFN1YlNjaGVtYShzY2hlbWFba2V5d29yZF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzU2luZ2xlU2NoZW1hKHNjaGVtYSwga2V5d29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NBcnJheU9mU2NoZW1hcyhzY2hlbWEsIGtleXdvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3NTaW5nbGVTY2hlbWEgPSAoc2NoZW1hLCBrZXl3b3JkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5VXNlclByb2Nlc3NvcihzY2hlbWEsIGtleXdvcmQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9vcCBvdmVyIHRoZSBsaW5rcyBhbmQgYXBwbHkgdGhlIGNhbGxiYWNrcywgd2hpbGVcbiAgICAgICAgICogaGFuZGxpbmcgTERPIGtleXdvcmQgZGVsZXRpb25zIGJ5IGNhdGNoaW5nIE5FWFRfTERPX0tFWVdPUkQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFByb2Nlc3NMaW5rcyA9IChsZG9Wb2NhYnVsYXJ5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHNjaGVtYSwga2V5d29yZCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGRvIG9mIHNjaGVtYS5saW5rcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBsZG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGRvVm9jYWJ1bGFyeVtrZXl3b3JkXT8uKHNjaGVtYSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgIT09IE5FWFRfTERPX0tFWVdPUkQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvLyB2b2NhYnVsYXJ5IGluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuaW5pdFZvY2FidWxhcnkgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBEUkFGVF8wNCA9IHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB0aGlzLnByb2Nlc3NPYmplY3RPZlNjaGVtYXMsXG4gICAgICAgICAgICAgICAgcGF0dGVyblByb3BlcnRpZXM6IHRoaXMucHJvY2Vzc09iamVjdE9mU2NoZW1hcyxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogdGhpcy5wcm9jZXNzU2luZ2xlU2NoZW1hLFxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llczogdGhpcy5wcm9jZXNzT2JqZWN0T2ZTY2hlbWFzLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiB0aGlzLnByb2Nlc3NTaW5nbGVPckFycmF5T2ZTY2hlbWFzLFxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxJdGVtczogdGhpcy5wcm9jZXNzU2luZ2xlU2NoZW1hLFxuICAgICAgICAgICAgICAgIGFsbE9mOiB0aGlzLnByb2Nlc3NBcnJheU9mU2NoZW1hcyxcbiAgICAgICAgICAgICAgICBhbnlPZjogdGhpcy5wcm9jZXNzQXJyYXlPZlNjaGVtYXMsXG4gICAgICAgICAgICAgICAgb25lT2Y6IHRoaXMucHJvY2Vzc0FycmF5T2ZTY2hlbWFzLFxuICAgICAgICAgICAgICAgIG5vdDogdGhpcy5wcm9jZXNzU2luZ2xlU2NoZW1hLFxuICAgICAgICAgICAgICAgIGlmOiB0aGlzLnByb2Nlc3NTaW5nbGVTY2hlbWEsXG4gICAgICAgICAgICAgICAgdGhlbjogdGhpcy5wcm9jZXNzU2luZ2xlU2NoZW1hLFxuICAgICAgICAgICAgICAgIGVsc2U6IHRoaXMucHJvY2Vzc1NpbmdsZVNjaGVtYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExETyBrZXl3b3JkcyBjYWxsIF9hcHBseSBkaXJlY3RseSBhcyB0aGV5IGhhdmUgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAqIG1hcHBpbmcgZnJvbSB0aGUgc2NoZW1hIGtleXdvcmQgaW50byB0aGUgcGF0aCB0aGF0IF9hcHBseVxuICAgICAgICAgICAgICogZXhwZWN0cy4gIFRoaXMgaXMgZG9uZSBpbiB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgZnJvbVxuICAgICAgICAgICAgICogX2dldFByb2Nlc3NMaW5rcygpO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBEUkFGVF8wNF9IWVBFUl9MRE8gPSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiB0aGlzLmFwcGx5VXNlclByb2Nlc3NvcixcbiAgICAgICAgICAgICAgICB0YXJnZXRTY2hlbWE6IHRoaXMuYXBwbHlVc2VyUHJvY2Vzc29yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IERSQUZUXzA0X0hZUEVSID0ge1xuICAgICAgICAgICAgICAgIC4uLkRSQUZUXzA0LFxuICAgICAgICAgICAgICAgIGxpbmtzOiB0aGlzLmdldFByb2Nlc3NMaW5rcyhEUkFGVF8wNF9IWVBFUl9MRE8pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IERSQUZUXzA2ID0ge1xuICAgICAgICAgICAgICAgIC4uLkRSQUZUXzA0LFxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZXM6IHRoaXMucHJvY2Vzc09iamVjdE9mU2NoZW1hcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBEUkFGVF8wNl9IWVBFUl9MRE8gPSB7XG4gICAgICAgICAgICAgICAgaHJlZlNjaGVtYTogdGhpcy5hcHBseVVzZXJQcm9jZXNzb3IsXG4gICAgICAgICAgICAgICAgdGFyZ2V0U2NoZW1hOiB0aGlzLmFwcGx5VXNlclByb2Nlc3NvcixcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uU2NoZW1hOiB0aGlzLmFwcGx5VXNlclByb2Nlc3NvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBEUkFGVF8wNl9IWVBFUiA9IHtcbiAgICAgICAgICAgICAgICAuLi5EUkFGVF8wNixcbiAgICAgICAgICAgICAgICBsaW5rczogdGhpcy5nZXRQcm9jZXNzTGlua3MoRFJBRlRfMDZfSFlQRVJfTERPKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBEUkFGVF8wNyA9IHsgLi4uRFJBRlRfMDYgfTtcbiAgICAgICAgICAgIGNvbnN0IERSQUZUXzA3X0hZUEVSX0xETyA9IHtcbiAgICAgICAgICAgICAgICAuLi5EUkFGVF8wNl9IWVBFUl9MRE8sXG4gICAgICAgICAgICAgICAgaGVhZGVyU2NoZW1hOiB0aGlzLmFwcGx5VXNlclByb2Nlc3NvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBEUkFGVF8wN19IWVBFUiA9IHtcbiAgICAgICAgICAgICAgICAuLi5EUkFGVF8wNyxcbiAgICAgICAgICAgICAgICBsaW5rczogdGhpcy5nZXRQcm9jZXNzTGlua3MoRFJBRlRfMDdfSFlQRVJfTERPKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBDTE9VREZMQVJFX0RPQ0EgPSB7XG4gICAgICAgICAgICAgICAgLi4uRFJBRlRfMDQsXG4gICAgICAgICAgICAgICAgbGlua3M6IHRoaXMuZ2V0UHJvY2Vzc0xpbmtzKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uRFJBRlRfMDRfSFlQRVJfTERPLFxuICAgICAgICAgICAgICAgICAgICAuLi5EUkFGVF8wN19IWVBFUl9MRE8sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy52b2NhYnVsYXJpZXMgPSB7XG4gICAgICAgICAgICAgICAgRFJBRlRfMDQsXG4gICAgICAgICAgICAgICAgRFJBRlRfMDRfSFlQRVIsXG4gICAgICAgICAgICAgICAgRFJBRlRfMDRfSFlQRVJfTERPLFxuICAgICAgICAgICAgICAgIERSQUZUXzA2LFxuICAgICAgICAgICAgICAgIERSQUZUXzA2X0hZUEVSLFxuICAgICAgICAgICAgICAgIERSQUZUXzA2X0hZUEVSX0xETyxcbiAgICAgICAgICAgICAgICBEUkFGVF8wNyxcbiAgICAgICAgICAgICAgICBEUkFGVF8wN19IWVBFUixcbiAgICAgICAgICAgICAgICBEUkFGVF8wN19IWVBFUl9MRE8sXG4gICAgICAgICAgICAgICAgQ0xPVURGTEFSRV9ET0NBLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0Vm9jYWJ1bGFyeSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2Fsa2VyID0gV2Fsa2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/json-schema-walker@2.0.0/node_modules/json-schema-walker/dist/index.js\n");

/***/ })

};
;
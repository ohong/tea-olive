/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fohong%2FLibrary%2FMobile%20Documents%2Fcom~apple~CloudDocs%2Fdev%2Ftea-olive%2Fweb%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fohong%2FLibrary%2FMobile%20Documents%2Fcom~apple~CloudDocs%2Fdev%2Ftea-olive%2Fweb%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.tsx */ \"(app-pages-browser)/./src/app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMzJfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGb2hvbmclMkZMaWJyYXJ5JTJGTW9iaWxlJTIwRG9jdW1lbnRzJTJGY29tfmFwcGxlfkNsb3VkRG9jcyUyRmRldiUyRnRlYS1vbGl2ZSUyRndlYiUyRnNyYyUyRmFwcCUyRnBhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsOEpBQWlJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZDM0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9vaG9uZy9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvY29tfmFwcGxlfkNsb3VkRG9jcy9kZXYvdGVhLW9saXZlL3dlYi9zcmMvYXBwL3BhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fohong%2FLibrary%2FMobile%20Documents%2Fcom~apple~CloudDocs%2Fdev%2Ftea-olive%2Fweb%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@hashbrownai+core@0.3.0/node_modules/@hashbrownai/core/index.esm.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@hashbrownai+core@0.3.0/node_modules/@hashbrownai/core/index.esm.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chat: function() { return /* binding */ public_api; },\n/* harmony export */   decodeFrames: function() { return /* binding */ decodeFrames; },\n/* harmony export */   encodeFrame: function() { return /* binding */ encodeFrame; },\n/* harmony export */   fryHashbrown: function() { return /* binding */ fryHashbrown; },\n/* harmony export */   prompt: function() { return /* binding */ prompt; },\n/* harmony export */   s: function() { return /* binding */ public_api$1; },\n/* harmony export */   \"ɵcreateRuntimeFunctionImpl\": function() { return /* binding */ createRuntimeFunctionImpl; },\n/* harmony export */   \"ɵcreateRuntimeImpl\": function() { return /* binding */ createRuntimeImpl; },\n/* harmony export */   \"ɵdeepEqual\": function() { return /* binding */ deepEqual; },\n/* harmony export */   \"ɵtypes\": function() { return /* binding */ types; },\n/* harmony export */   \"ɵui\": function() { return /* binding */ index; }\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * Decode a ReadableStream\\<Uint8Array\\> of length-prefixed JSON frames into a stream of T.\n *\n * Frame format: [4-byte BE length][UTF-8 JSON payload]\n *\n * @public\n * @param stream - ReadableStream producing Uint8Array chunks\n * @param options - decoding options\n * @typeParam T - The type of the parsed JSON objects\n * @returns - A stream of parsed JSON objects of type T\n */\nfunction decodeFrames(stream, options) {\n  return __asyncGenerator(this, arguments, function* decodeFrames_1() {\n    const {\n      signal\n    } = options;\n    const reader = stream.getReader();\n    const textDecoder = new TextDecoder();\n    let buffer = new Uint8Array(0);\n    signal.addEventListener('abort', () => {\n      reader.cancel().catch(() => {\n        // ignore\n      });\n    }, {\n      once: true\n    });\n    if (signal.aborted) {\n      yield __await(reader.cancel());\n      return yield __await(void 0);\n    }\n    try {\n      while (true) {\n        if (signal.aborted) {\n          throw new Error('Decoding aborted');\n        }\n        const {\n          value: chunk,\n          done\n        } = yield __await(reader.read());\n        if (done) break;\n        const newBuffer = new Uint8Array(buffer.length + chunk.length);\n        newBuffer.set(buffer);\n        newBuffer.set(chunk, buffer.length);\n        buffer = newBuffer;\n        let offset = 0;\n        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n        while (buffer.length - offset >= 4) {\n          const length = view.getUint32(offset, /* Big Endian */false);\n          if (buffer.length - offset < 4 + length) {\n            break;\n          }\n          const start = offset + 4;\n          const end = start + length;\n          try {\n            const payloadBytes = buffer.subarray(start, end);\n            const json = textDecoder.decode(payloadBytes);\n            const frame = JSON.parse(json);\n            yield yield __await(frame);\n            if (frame.type === 'finish') {\n              return yield __await(void 0);\n            }\n          } catch (err) {\n            throw new Error(`Invalid JSON payload: ${err.message}`);\n          }\n          offset = end;\n        }\n        if (offset > 0) {\n          buffer = buffer.subarray(offset);\n        }\n      }\n      if (buffer.length > 0) {\n        throw new Error(`Stream ended with ${buffer.length} leftover bytes`);\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  });\n}\n\n/**\n * Encodes a frame into a binary format.\n *\n * @public\n * @param frame - The frame to encode.\n * @returns The encoded frame.\n */\nfunction encodeFrame(frame) {\n  const encoder = new TextEncoder();\n  const jsonBytes = encoder.encode(JSON.stringify(frame));\n  const len = jsonBytes.length;\n  const out = new Uint8Array(4 + len);\n  const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setUint32(0, len, /* Big Endian */false);\n  out.set(jsonBytes, 4);\n  return out;\n}\n\n/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Synchronous “trampoline” scheduler.\n *\n * All work executes in the same macrotask, but stack-safe:\n * tasks scheduled from inside other tasks are queued\n * and processed after the current one finishes.\n */\nclass TrampolineScheduler {\n  constructor() {\n    this.nextId = 0;\n    this.queue = new Map();\n    this.active = false;\n  }\n  flush() {\n    if (this.active) return;\n    this.active = true;\n    while (this.queue.size) {\n      const entry = this.queue.entries().next().value;\n      if (!entry) break;\n      const [id, task] = entry;\n      this.queue.delete(id);\n      try {\n        task();\n      } catch (err) {\n        // Surface errors asynchronously so one failure\n        // doesn’t prevent later tasks from running\n        setTimeout(() => {\n          throw err;\n        }, 0);\n      }\n    }\n    this.active = false;\n  }\n  scheduleTask(fn) {\n    const id = ++this.nextId;\n    this.queue.set(id, fn);\n    this.flush();\n    return id;\n  }\n  cancelTask(id) {\n    this.queue.delete(id);\n  }\n}\n/**\n * Creates a payload projector function that returns its argument.\n *\n * @typeParam T - The payload type.\n * @returns Function that returns the provided payload.\n */\nfunction props() {\n  return payload => payload;\n}\n/**\n * Creates an action creator with no payload.\n *\n * @returns Function that produces an action with only a type.\n */\nfunction emptyProps() {\n  return () => {};\n}\n/**\n * Generates a group of action creator functions with a common type prefix.\n *\n * @typeParam GroupName - The modifier for action types (e.g., feature name).\n * @typeParam T - An object whose values are payload creator functions.\n * @param name - The group prefix name.\n * @param group - An object mapping action names to payload functions.\n * @returns A set of action creators.\n */\nfunction createActionGroup(name, group) {\n  return Object.fromEntries(Object.entries(group).map(([key, value]) => [key, Object.assign(typeof value === 'function' ? payload => ({\n    type: `[${name}] ${key}`,\n    payload\n  }) : () => ({\n    type: `[${name}] ${key}`\n  }), {\n    type: `[${name}] ${key}`\n  })]));\n}\n/**\n * ================================\n * ===         Reducers         ===\n * ================================\n */\n/**\n * Creates a reducer function that responds to specified action types.\n *\n * @typeParam State - The type of the slice of state.\n * @typeParam Actions - An array of ActionCreator types to handle.\n * @param params - One or more action creators followed by a reducer handler.\n * @returns A reducer function.\n */\nfunction on(...params) {\n  const actionFns = params.slice(0, -1);\n  const reducerFn = params[params.length - 1];\n  return (state, action) => {\n    const shouldReduceState = actionFns.some(param => param.type === action.type);\n    if (!shouldReduceState) {\n      return state;\n    }\n    return reducerFn(state, action);\n  };\n}\n/**\n * Combines multiple reducer functions into a single root reducer.\n *\n * @typeParam State - The combined state shape.\n * @param initialState - The initial state when undefined is passed.\n * @param reducers - One or more reducer functions.\n * @returns The root reducer.\n */\nfunction createReducer(initialState, ...reducers) {\n  return (state, action) => {\n    return reducers.reduce((acc, reducer) => reducer(acc, action), state === undefined ? initialState : state);\n  };\n}\n/**\n * Creates an effect function that can subscribe to store actions and return a cleanup function.\n *\n * @param effectFn - Function that receives the store and returns a teardown callback.\n * @returns The provided effect function.\n */\nfunction createEffect(effectFn) {\n  return effectFn;\n}\nfunction select(...params) {\n  let inputs = params.slice(0, -1);\n  let selectFn = params[params.length - 1];\n  let config;\n  if (typeof selectFn !== 'function') {\n    config = selectFn;\n    selectFn = params[params.length - 2];\n    inputs = params.slice(0, -2);\n  }\n  let lastInputValues = [];\n  let lastOutput;\n  return state => {\n    const inputValues = inputs.map(input => input(state));\n    if (inputValues.some((value, index) => {\n      const isMismatched = value !== lastInputValues[index];\n      if (isMismatched && config && config.debugName) {\n        console.log('Select Argument Mismatch:', config.debugName, `input[${index}]`, 'last:', lastInputValues[index], 'now:', value);\n      }\n      return isMismatched;\n    })) {\n      lastInputValues = inputValues;\n      lastOutput = selectFn(...inputValues);\n    }\n    return lastOutput;\n  };\n}\n/**\n * ================================\n * ===         Store            ===\n * ================================\n */\n/**\n * Creates a store with reducers and effects.\n * @typeParam Reducers - An object mapping keys to reducer functions.\n * @typeParam State - The resulting state shape inferred from Reducers.\n * @param config - Configuration object.\n * @returns The initialized store instance.\n */\nfunction createStore(config) {\n  const scheduler = new TrampolineScheduler();\n  const devtools = config.debugName ? connectToChromeExtension({\n    name: config.debugName\n  }) : undefined;\n  const reducerFnEntries = Object.entries(config.reducers);\n  const reducerFn = function (state, action) {\n    return reducerFnEntries.reduce((acc, [key, value]) => {\n      return Object.assign(Object.assign({}, acc), {\n        [key]: value(acc === null || acc === void 0 ? void 0 : acc[key], action)\n      });\n    }, state);\n  };\n  const whenCallbackFnMap = new Map();\n  const selectCallbackFns = [];\n  let state = reducerFn(undefined, {\n    type: '@@init'\n  });\n  function dispatch(action) {\n    scheduler.scheduleTask(() => {\n      var _a, _b, _c;\n      state = reducerFn(state, action);\n      const whenCallbackFns = (_a = whenCallbackFnMap.get(action.type)) !== null && _a !== void 0 ? _a : [];\n      whenCallbackFns.forEach(callback => callback(action));\n      selectCallbackFns.forEach(callback => callback());\n      devtools === null || devtools === void 0 ? void 0 : devtools.send(action, (_c = (_b = config.projectStateForDevtools) === null || _b === void 0 ? void 0 : _b.call(config, state)) !== null && _c !== void 0 ? _c : state);\n    });\n  }\n  function when(...params) {\n    const actionFns = params.slice(0, -1);\n    const callbackFn = params[params.length - 1];\n    actionFns.forEach(actionFn => {\n      var _a;\n      if (!whenCallbackFnMap.has(actionFn.type)) {\n        whenCallbackFnMap.set(actionFn.type, []);\n      }\n      (_a = whenCallbackFnMap.get(actionFn.type)) === null || _a === void 0 ? void 0 : _a.push(callbackFn);\n    });\n    return () => {\n      actionFns.forEach(actionFn => {\n        var _a;\n        const callbacks = (_a = whenCallbackFnMap.get(actionFn.type)) !== null && _a !== void 0 ? _a : [];\n        whenCallbackFnMap.set(actionFn.type, callbacks.filter(cb => cb !== callbackFn));\n      });\n    };\n  }\n  function whenOnce(...params) {\n    const actionFns = params.slice(0, -1);\n    const callbackFn = params[params.length - 1];\n    const cleanupFn = when(...actionFns, action => {\n      callbackFn(action);\n      cleanupFn();\n    });\n    return cleanupFn;\n  }\n  function read(selector) {\n    return selector(state);\n  }\n  function select(selector, onChange) {\n    let currentValue = read(selector);\n    onChange(currentValue);\n    const callback = () => {\n      const newValue = read(selector);\n      if (newValue !== currentValue) {\n        currentValue = newValue;\n        onChange(newValue);\n      }\n    };\n    selectCallbackFns.push(callback);\n    return () => {\n      selectCallbackFns.splice(selectCallbackFns.indexOf(callback), 1);\n    };\n  }\n  function createSignal(selector) {\n    return Object.assign(() => read(selector), {\n      subscribe: onChange => select(selector, onChange)\n    });\n  }\n  function runEffects() {\n    var _a, _b;\n    devtools === null || devtools === void 0 ? void 0 : devtools.init((_b = (_a = config.projectStateForDevtools) === null || _a === void 0 ? void 0 : _a.call(config, state)) !== null && _b !== void 0 ? _b : state);\n    const cleanupFns = config.effects.map(effect => effect(store));\n    return () => {\n      cleanupFns.forEach(fn => fn());\n      devtools === null || devtools === void 0 ? void 0 : devtools.unsubscribe();\n    };\n  }\n  const store = {\n    dispatch,\n    read,\n    select,\n    when: when,\n    whenOnce: whenOnce,\n    createSignal,\n    runEffects\n  };\n  return store;\n}\n/**\n * Creates an EntityAdapter for performing immutable updates on entity collections.\n * @typeParam Entity - The entity type.\n * @param config - Configuration with a selectId function.\n * @returns Adapter with CRUD methods for entity state.\n */\nfunction createEntityAdapter(config) {\n  const {\n    selectId\n  } = config;\n  function updateOne(state, changes) {\n    return Object.assign(Object.assign({}, state), {\n      entities: Object.assign(Object.assign({}, state.entities), {\n        [changes.id]: Object.assign(Object.assign({}, state.entities[changes.id]), changes.updates)\n      })\n    });\n  }\n  function updateMany(state, changes) {\n    return changes.reduce((acc, change) => updateOne(acc, change), state);\n  }\n  function addOne(state, entity) {\n    return Object.assign(Object.assign({}, state), {\n      ids: [...state.ids, selectId(entity)],\n      entities: Object.assign(Object.assign({}, state.entities), {\n        [selectId(entity)]: entity\n      })\n    });\n  }\n  function addMany(state, entities) {\n    return entities.reduce((acc, entity) => addOne(acc, entity), state);\n  }\n  function removeOne(state, idToRemove) {\n    const updatedEntities = Object.assign({}, state.entities);\n    delete updatedEntities[idToRemove];\n    return Object.assign(Object.assign({}, state), {\n      ids: state.ids.filter(id => id !== idToRemove),\n      entities: updatedEntities\n    });\n  }\n  function removeMany(state, ids) {\n    return Object.assign(Object.assign({}, state), {\n      ids: state.ids.filter(id => !ids.includes(id)),\n      entities: Object.fromEntries(Object.entries(state.entities).filter(([id]) => !ids.includes(id)))\n    });\n  }\n  return {\n    updateOne,\n    updateMany,\n    addOne,\n    addMany,\n    removeOne,\n    removeMany\n  };\n}\nfunction connectToChromeExtension(options) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const extension = window.__REDUX_DEVTOOLS_EXTENSION__;\n  if (!extension) {\n    return;\n  }\n  return extension.connect({\n    name: options.name\n  });\n}\n\nvar devActions = createActionGroup('dev', {\n  init: props(),\n  setMessages: props(),\n  sendMessage: props(),\n  resendMessages: props,\n  updateOptions: props(),\n  stopMessageGeneration: props()\n});\n\nvar apiActions = createActionGroup('api', {\n  generateMessageStart: emptyProps(),\n  generateMessageChunk: props(),\n  generateMessageSuccess: props(),\n  generateMessageError: props(),\n  generateMessageExhaustedRetries: props()\n});\n\nvar internalActions = createActionGroup('internal', {\n  sizzle: emptyProps(),\n  runToolCallsSuccess: props(),\n  runToolCallsError: props(),\n  skippedToolCalls: emptyProps()\n});\n\n/**\n * Skillet is an LLM-optimized streaming JSON Parser - perfectly suited for streaming hot and fresh JSON.\n *\n * Portions of this code are derived from Zod (MIT License) (https://github.com/colinhacks/zod).\n * See the LICENSE file in the project root for full license text.\n *\n * @license MIT\n * @author LiveLoveApp, LLC\n * @see https://github.com/liveloveapp/hashbrown\n * @see https://github.com/colinhacks/zod\n */\n/**\n * @internal\n */\nconst internal = '~schema';\nconst PRIMITIVE_WRAPPER_FIELD_NAME = '__wrappedPrimitive';\n/**\n * @internal\n */\nconst HashbrownTypeCtor = ({\n  name,\n  initializer,\n  toJsonSchemaImpl,\n  parseJsonSchemaImpl,\n  toTypeScriptImpl,\n  validateImpl,\n  toStreamingImpl\n}) => {\n  class Class {\n    constructor(definition) {\n      Class.init(this, definition);\n      this.toJsonSchemaImpl = toJsonSchemaImpl;\n      this.parseJsonSchemaImpl = parseJsonSchemaImpl;\n      this.toTypeScriptImpl = toTypeScriptImpl;\n      this.validateImpl = validateImpl;\n      this.toStreamingImpl = toStreamingImpl;\n    }\n    static init(instance, definition) {\n      var _a;\n      (_a = instance[internal]) !== null && _a !== void 0 ? _a : instance[internal] = {\n        definition: {\n          description: '',\n          streaming: false\n        }\n      };\n      initializer(instance, definition);\n      instance[internal].definition = definition;\n    }\n    toJsonSchema() {\n      return this.toJsonSchemaImpl(this);\n    }\n    parseJsonSchema(object, path = []) {\n      return this.parseJsonSchemaImpl(this, object, path);\n    }\n    toTypeScript(pathSeen = new Set()) {\n      return this.toTypeScriptImpl(this, pathSeen);\n    }\n    validate(object, path = []) {\n      return this.validateImpl(this, this[internal].definition, object, path);\n    }\n    toStreaming(object, path = []) {\n      return this.toStreamingImpl(this, this[internal].definition, object, path);\n    }\n  }\n  Object.defineProperty(Class, 'name', {\n    value: name\n  });\n  return Class;\n};\nconst HashbrownType = HashbrownTypeCtor({\n  name: 'HashbrownType',\n  initializer: (inst, def) => {\n    inst !== null && inst !== void 0 ? inst : inst = {};\n    inst[internal].definition = def;\n  },\n  toJsonSchemaImpl: () => {\n    return;\n  },\n  parseJsonSchemaImpl: () => {\n    return;\n  },\n  toTypeScriptImpl: () => {\n    return '';\n  },\n  validateImpl: () => {\n    return;\n  },\n  toStreamingImpl: () => {\n    return;\n  }\n});\nconst StringType = HashbrownTypeCtor({\n  name: 'String',\n  initializer: (inst, def) => {\n    HashbrownType.init(inst, def);\n  },\n  toJsonSchemaImpl: schema => {\n    return {\n      type: 'string',\n      description: schema[internal].definition.description\n    };\n  },\n  parseJsonSchemaImpl: (schema, object, path) => {\n    // Is this a wrapped primitive?\n    if (object != null && typeof object === 'object' && Object.keys(object).includes(PRIMITIVE_WRAPPER_FIELD_NAME)) {\n      object = object[PRIMITIVE_WRAPPER_FIELD_NAME];\n    }\n    if (typeof object !== 'string') throw new Error(`Expected a string at: ${path.join('.')}, got ${object}`);\n    return object;\n  },\n  toTypeScriptImpl: schema => {\n    return `/* ${schema[internal].definition.description} */ string`;\n  },\n  validateImpl: (schema, definition, object, path) => {\n    if (typeof object !== 'string') {\n      throw new Error(`Expected a string at: ${path.join('.')}, got ${typeof object}`);\n    }\n    return;\n  },\n  toStreamingImpl: (schema, definition, object, path) => {\n    return object;\n  }\n});\n/**\n * @public\n */\nfunction isStringType(type) {\n  return type[internal].definition.type === 'string';\n}\n/**\n * @public\n */\nfunction string$1(description) {\n  return new StringType({\n    type: 'string',\n    description,\n    streaming: false\n  });\n}\nconst LiteralType = HashbrownTypeCtor({\n  name: 'Literal',\n  initializer: (inst, def) => {\n    HashbrownType.init(inst, def);\n  },\n  toJsonSchemaImpl: schema => {\n    const isString = typeof schema[internal].definition.value === 'string';\n    const isNumber = typeof schema[internal].definition.value === 'number';\n    typeof schema[internal].definition.value === 'boolean';\n    return {\n      type: isString ? 'string' : isNumber ? 'number' : 'boolean',\n      const: schema[internal].definition.value,\n      description: schema[internal].definition.description\n    };\n  },\n  parseJsonSchemaImpl: (schema, object, path) => {\n    // Is this a wrapped primitive?\n    if (object != null && typeof object === 'object' && Object.keys(object).includes(PRIMITIVE_WRAPPER_FIELD_NAME)) {\n      object = object[PRIMITIVE_WRAPPER_FIELD_NAME];\n    }\n    const isString = typeof object === 'string';\n    const isNumber = typeof object === 'number';\n    const isBoolean = typeof object === 'boolean';\n    if (!isString && !isNumber && !isBoolean) throw new Error(`Expected a string, number, or boolean at: ${path.join('.')}, got ${object}, received ${schema[internal].definition.value}`);\n    return object;\n  },\n  toTypeScriptImpl: schema => {\n    return JSON.stringify(schema[internal].definition.value);\n  },\n  validateImpl: (schema, definition, object, path) => {\n    if (definition.value !== object) {\n      throw new Error(`Expected the literal value ${JSON.stringify(definition.value)} at: ${path.join('.')}, but got ${JSON.stringify(object)}`);\n    }\n  },\n  toStreamingImpl: (schema, definition, object, path) => {\n    return object;\n  }\n});\n/**\n * @public\n */\nfunction isLiteralType(type) {\n  return type[internal].definition.type === 'literal';\n}\n/**\n * @public\n */\nfunction literal(value) {\n  return new LiteralType({\n    type: 'literal',\n    description: `${value}`,\n    value,\n    streaming: false\n  });\n}\nconst NumberType = HashbrownTypeCtor({\n  name: 'Number',\n  initializer: (inst, def) => {\n    HashbrownType.init(inst, def);\n  },\n  toJsonSchemaImpl: schema => {\n    return {\n      type: 'number',\n      description: schema[internal].definition.description\n    };\n  },\n  parseJsonSchemaImpl: (schema, object, path) => {\n    // Is this a wrapped primitive?\n    if (object != null && typeof object === 'object' && Object.keys(object).includes(PRIMITIVE_WRAPPER_FIELD_NAME)) {\n      object = object[PRIMITIVE_WRAPPER_FIELD_NAME];\n    }\n    if (typeof object !== 'number') throw new Error(`Expected a number at: ${path.join('.')}`);\n    return object;\n  },\n  toTypeScriptImpl: schema => {\n    return `/* ${schema[internal].definition.description} */ number`;\n  },\n  validateImpl: (schema, definition, object, path) => {\n    if (typeof object !== 'number') {\n      throw new Error(`Expected a number at: ${path.join('.')}`);\n    }\n  },\n  toStreamingImpl: (schema, definition, object, path) => {\n    return object;\n  }\n});\n/**\n * @public\n */\nfunction isNumberType(type) {\n  return type[internal].definition.type === 'number';\n}\n/**\n * @public\n */\nfunction number(description) {\n  return new NumberType({\n    type: 'number',\n    description,\n    streaming: false\n  });\n}\nconst BooleanType = HashbrownTypeCtor({\n  name: 'Boolean',\n  initializer: (inst, def) => {\n    HashbrownType.init(inst, def);\n  },\n  toJsonSchemaImpl: schema => {\n    return {\n      type: 'boolean',\n      description: schema[internal].definition.description\n    };\n  },\n  parseJsonSchemaImpl: (schema, object, path) => {\n    // Is this a wrapped primitive?\n    if (object != null && typeof object === 'object' && Object.keys(object).includes(PRIMITIVE_WRAPPER_FIELD_NAME)) {\n      object = object[PRIMITIVE_WRAPPER_FIELD_NAME];\n    }\n    if (typeof object !== 'boolean') throw new Error(`Expected a boolean at: ${path.join('.')}`);\n    return object;\n  },\n  toTypeScriptImpl: schema => {\n    return `/* ${schema[internal].definition.description} */ boolean`;\n  },\n  validateImpl: (schema, definition, object, path) => {\n    if (typeof object !== 'boolean') throw new Error(`Expected a boolean at: ${path.join('.')}`);\n  },\n  toStreamingImpl: (schema, definition, object, path) => {\n    return object;\n  }\n});\n/**\n * @public\n */\nfunction isBooleanType(type) {\n  return type[internal].definition.type === 'boolean';\n}\n/**\n * @public\n */\nfunction boolean(description) {\n  return new BooleanType({\n    type: 'boolean',\n    description,\n    streaming: false\n  });\n}\nconst IntegerType = HashbrownTypeCtor({\n  name: 'Integer',\n  initializer: (inst, def) => {\n    HashbrownType.init(inst, def);\n  },\n  toJsonSchemaImpl: schema => {\n    return {\n      type: 'integer',\n      description: schema[internal].definition.description\n    };\n  },\n  parseJsonSchemaImpl: (schema, object, path) => {\n    // Is this a wrapped primitive?\n    if (object != null && typeof object === 'object' && Object.keys(object).includes(PRIMITIVE_WRAPPER_FIELD_NAME)) {\n      object = object[PRIMITIVE_WRAPPER_FIELD_NAME];\n    }\n    if (typeof object !== 'number') throw new Error(`Expected a number at: ${path.join('.')}`);\n    if (!Number.isInteger(object)) throw new Error(`Expected an integer at: ${path.join('.')}`);\n    return object;\n  },\n  toTypeScriptImpl: schema => {\n    return `/* ${schema[internal].definition.description} */ integer`;\n  },\n  validateImpl: (schema, definition, object, path) => {\n    if (typeof object !== 'number') throw new Error(`Expected a number at: ${path.join('.')}`);\n    if (!Number.isInteger(object)) throw new Error(`Expected an integer at: ${path.join('.')}`);\n  },\n  toStreamingImpl: (schema, definition, object, path) => {\n    return object;\n  }\n});\n/**\n * @public\n */\nfunction isIntegerType(type) {\n  return type[internal].definition.type === 'integer';\n}\n/**\n * @public\n */\nfunction integer(description) {\n  return new IntegerType({\n    type: 'integer',\n    description,\n    streaming: false\n  });\n}\nconst ObjectType = HashbrownTypeCtor({\n  name: 'Object',\n  initializer: (inst, def) => {\n    HashbrownType.init(inst, def);\n  },\n  toJsonSchemaImpl: schema => {\n    return {\n      type: 'object',\n      // Properties is populated externally because we need to find loops\n      properties: {},\n      required: Object.keys(schema[internal].definition.shape),\n      additionalProperties: false,\n      description: schema[internal].definition.description\n    };\n  },\n  parseJsonSchemaImpl: (schema, object, path) => {\n    if (typeof object !== 'object' || object === null) throw new Error(`Expected an object at: ${path.join('.')}`);\n    const {\n      shape\n    } = schema[internal].definition;\n    Object.entries(shape).forEach(([key, child]) => {\n      // AnyOf unwrapping can change the desired form of the result object, so\n      // update the object as we parse\n      object[key] = child.parseJsonSchema(object[key], [...path, key]);\n    });\n    return object;\n  },\n  toTypeScriptImpl: (schema, pathSeen) => {\n    if (pathSeen.has(schema)) {\n      const desc = schema[internal].definition.description || '<anonymous>';\n      throw new Error(`Cycle detected in schema at \"${desc}\"`);\n    }\n    pathSeen.add(schema);\n    const depth = pathSeen.size - 1;\n    const entries = Object.entries(schema[internal].definition.shape);\n    const lines = entries.map(([key, child]) => {\n      // clone pathSeen for each branch\n      return `${' '.repeat(depth + 2)}${key}: ${child.toTypeScript(new Set(pathSeen))};`;\n    });\n    return `/* ${schema[internal].definition.description} */ {\n${lines.join('\\n')}\n${' '.repeat(depth)}}`;\n  },\n  validateImpl: (schema, definition, object, path) => {\n    if (typeof object !== 'object' || object === null) throw new Error(`Expected an object at: ${path.join('.')}`);\n    const {\n      shape\n    } = definition;\n    Object.entries(shape).forEach(([key, child]) => {\n      child.validate(object[key], [...path, key]);\n    });\n    return object;\n  },\n  toStreamingImpl: (schema, definition, object, path) => {\n    const {\n      shape\n    } = definition;\n    const entries = Object.entries(shape);\n    return Object.fromEntries(entries.map(([key, value]) => {\n      return [key, value.toStreaming(object[key], [...path, key])];\n    }));\n  }\n});\n/**\n * @public\n */\nfunction isObjectType(type) {\n  return type[internal].definition.type === 'object';\n}\n/**\n * @public\n */\nfunction object$1(description, shape) {\n  return new ObjectType({\n    type: 'object',\n    description,\n    streaming: false,\n    shape\n  });\n}\nconst ArrayType = HashbrownTypeCtor({\n  name: 'Array',\n  initializer: (inst, def) => {\n    HashbrownType.init(inst, def);\n  },\n  toJsonSchemaImpl: schema => {\n    return {\n      type: 'array',\n      // items is populated externally since we find loops and duplicated sections\n      // through the whole schema\n      items: [],\n      description: schema[internal].definition.description\n    };\n  },\n  parseJsonSchemaImpl: (schema, object, path) => {\n    // Is this a wrapped primitive?\n    if (object != null && typeof object === 'object' && Object.keys(object).includes(PRIMITIVE_WRAPPER_FIELD_NAME)) {\n      object = object[PRIMITIVE_WRAPPER_FIELD_NAME];\n    }\n    if (!Array.isArray(object)) throw new Error(`Expected an array at: ${path.join('.')}`);\n    // AnyOf unwrapping can change the desired form of the result object, so\n    // update the object as we parse\n    object.forEach(item => {\n      item = schema[internal].definition.element.parseJsonSchema(item, path);\n    });\n    return object;\n  },\n  toTypeScriptImpl: (schema, pathSeen) => {\n    if (pathSeen.has(schema)) {\n      const desc = schema[internal].definition.description || '<anonymous>';\n      throw new Error(`Cycle detected in schema at \"${desc}\"`);\n    }\n    pathSeen.add(schema);\n    return `/* ${schema[internal].definition.description} */ Array<${schema[internal].definition.element.toTypeScript(new Set(pathSeen))}>`;\n  },\n  validateImpl: (schema, definition, object, path) => {\n    if (!Array.isArray(object)) throw new Error(`Expected an array at: ${path.join('.')}`);\n    object.forEach(item => {\n      definition.element.validate(item, path);\n    });\n  },\n  toStreamingImpl: (schema, definition, object, path) => {\n    return object.map(item => {\n      return definition.element.toStreaming(item, path);\n    });\n  }\n});\n/**\n * @public\n */\nfunction isArrayType(type) {\n  return type[internal].definition.type === 'array';\n}\n/**\n * @public\n */\nfunction array$1(description, item) {\n  return new ArrayType({\n    type: 'array',\n    description,\n    streaming: false,\n    element: item\n  });\n}\nconst AnyOfType = HashbrownTypeCtor({\n  name: 'AnyOfType',\n  initializer: (inst, def) => {\n    HashbrownType.init(inst, def);\n  },\n  toJsonSchemaImpl: schema => {\n    return {\n      anyOf: []\n    };\n  },\n  parseJsonSchemaImpl: (schema, object, path) => {\n    const options = schema[internal].definition.options;\n    let parsedObject = undefined;\n    const buildDiscriminatorMap = options => {\n      const map = {};\n      for (const opt of options) {\n        if (!isObjectType(opt)) {\n          return null;\n        }\n        const shape = opt[internal].definition.shape;\n        const literalEntries = Object.entries(shape).filter(([, v]) => isLiteralType(v));\n        // Require exactly one literal for clear discrimination\n        if (literalEntries.length !== 1) {\n          return null;\n        }\n        const [literalKey, litSchema] = literalEntries[0];\n        const literalValue = litSchema[internal].definition.value;\n        if (typeof literalValue !== 'string') {\n          // Only support string-based discriminators for wrapper keys\n          return null;\n        }\n        if (Object.prototype.hasOwnProperty.call(map, literalValue)) {\n          // Ambiguous (duplicate) discriminator value\n          return null;\n        }\n        map[literalValue] = {\n          schema: opt,\n          literalKey,\n          literalValue\n        };\n      }\n      return Object.keys(map).length === options.length ? map : null;\n    };\n    const discriminatorMap = buildDiscriminatorMap(options);\n    for (let i = 0; i < options.length; i++) {\n      try {\n        if (needsDiscriminatorWrapperInAnyOf(options[i]) && discriminatorMap) {\n          const discriminatorEntry = Object.entries(discriminatorMap).find(([, v]) => v.schema === options[i]);\n          if (!discriminatorEntry) {\n            throw new Error(`No discriminator key found for option ${options[i]}`);\n          }\n          const {\n            literalKey,\n            literalValue,\n            schema\n          } = discriminatorEntry[1];\n          const extractedObject = object[literalValue];\n          extractedObject[literalKey] = literalValue;\n          parsedObject = schema.parseJsonSchema(extractedObject);\n        } else if (needsDiscriminatorWrapperInAnyOf(options[i])) {\n          if (typeof object !== 'object' || object === null) {\n            throw new Error(`Expected an object at: ${path.join('.')}`);\n          }\n          const anyOfKeys = Object.keys(object);\n          if (anyOfKeys.length !== 1) {\n            throw new Error(`Malformed anyOf wrapper at ${path.join('.')}`);\n          }\n          const anyOfIndex = anyOfKeys[0];\n          if (anyOfIndex !== i.toString()) {\n            throw new Error(`Unexpected discriminator value ${anyOfIndex} for option ${i}`);\n          }\n          parsedObject = options[i].parseJsonSchema(object[anyOfIndex]);\n        } else {\n          parsedObject = options[i].parseJsonSchema(object);\n        }\n        break;\n      } catch (e) {\n        // console.log(e);\n        // Parsing failed, but that is not unexpected due to the looping.\n        // Just try the next option.\n        continue;\n      }\n    }\n    if (parsedObject == null) {\n      throw new Error(`All options in anyOf failed parsing at: ${path.join('.')}`);\n    }\n    return parsedObject;\n  },\n  toTypeScriptImpl: (schema, pathSeen) => {\n    if (pathSeen.has(schema)) {\n      const desc = schema[internal].definition.description || '<anonymous>';\n      throw new Error(`Cycle detected in schema at \"${desc}\"`);\n    }\n    pathSeen.add(schema);\n    return `/* ${schema[internal].definition.description} */ (${schema[internal].definition.options.map(opt => opt.toTypeScript(new Set(pathSeen))).join(' | ')})`;\n  },\n  validateImpl: (schema, definition, object, path) => {\n    const {\n      options\n    } = definition;\n    let foundMatch = false;\n    for (let i = 0; i < options.length; i++) {\n      try {\n        options[i].validate(object);\n        foundMatch = true;\n        break;\n      } catch (e) {\n        // console.log(e);\n        // Parsing failed, but that is not unexpected due to the looping.\n        // Just try the next option.\n        continue;\n      }\n    }\n    if (!foundMatch) {\n      throw new Error(`All options in anyOf failed parsing at: ${path.join('.')}`);\n    }\n  },\n  toStreamingImpl: (schema, definition, object, path) => {\n    const matchingOption = definition.options.find(opt => {\n      try {\n        opt.validate(object);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    });\n    const buildDiscriminatorMap = options => {\n      const map = {};\n      for (const opt of options) {\n        if (!isObjectType(opt)) {\n          return null;\n        }\n        const shape = opt[internal].definition.shape;\n        const literalEntries = Object.entries(shape).filter(([, v]) => isLiteralType(v));\n        // Require exactly one literal for clear discrimination\n        if (literalEntries.length !== 1) {\n          return null;\n        }\n        const [literalKey, litSchema] = literalEntries[0];\n        const literalValue = litSchema[internal].definition.value;\n        if (typeof literalValue !== 'string') {\n          // Only support string-based discriminators for wrapper keys\n          return null;\n        }\n        if (Object.prototype.hasOwnProperty.call(map, literalValue)) {\n          // Ambiguous (duplicate) discriminator value\n          return null;\n        }\n        map[literalValue] = {\n          schema: opt,\n          literalKey,\n          literalValue\n        };\n      }\n      return Object.keys(map).length === options.length ? map : null;\n    };\n    const discriminatorMap = buildDiscriminatorMap(definition.options);\n    if (!matchingOption) {\n      throw new Error(`No matching option found in anyOf at: ${path.join('.')}`);\n    }\n    if (needsDiscriminatorWrapperInAnyOf(matchingOption) && discriminatorMap) {\n      const discriminatorEntry = Object.entries(discriminatorMap).find(([, v]) => v.schema === matchingOption);\n      if (!discriminatorEntry) {\n        throw new Error(`No discriminator key found for option ${matchingOption}`);\n      }\n      const {\n        literalKey,\n        literalValue,\n        schema\n      } = discriminatorEntry[1];\n      const streamingObject = schema.toStreaming(object, path);\n      delete streamingObject[literalKey];\n      return {\n        [literalValue]: streamingObject\n      };\n    } else if (needsDiscriminatorWrapperInAnyOf(matchingOption) && !discriminatorMap) {\n      const indexOfMatchingOption = definition.options.indexOf(matchingOption);\n      return {\n        [indexOfMatchingOption.toString()]: matchingOption.toStreaming(object, path)\n      };\n    }\n    return matchingOption.toStreaming(object, path);\n  }\n});\n/**\n * @public\n */\nfunction isAnyOfType(type) {\n  return type[internal].definition.type === 'any-of';\n}\n/**\n * @public\n */\nfunction anyOf(options) {\n  return new AnyOfType({\n    type: 'any-of',\n    description: 'any-of',\n    options,\n    streaming: false\n  });\n}\nconst EnumType = HashbrownTypeCtor({\n  name: 'Enum',\n  initializer: (inst, def) => {\n    HashbrownType.init(inst, def);\n  },\n  toJsonSchemaImpl: schema => {\n    return {\n      type: 'string',\n      enum: schema[internal].definition.entries,\n      description: schema[internal].definition.description\n    };\n  },\n  parseJsonSchemaImpl: (schema, object, path) => {\n    // Is this a wrapped primitive?\n    if (object != null && typeof object === 'object' && Object.keys(object).includes(PRIMITIVE_WRAPPER_FIELD_NAME)) {\n      object = object[PRIMITIVE_WRAPPER_FIELD_NAME];\n    }\n    if (typeof object !== 'string') throw new Error(`Expected a string at: ${path.join('.')}`);\n    if (!schema[internal].definition.entries.includes(object)) throw new Error(`Expected an enum value at: ${path.join('.')}`);\n    return object;\n  },\n  toTypeScriptImpl: schema => {\n    return schema[internal].definition.entries.map(e => `\"${e}\"`).join(' | ');\n  },\n  validateImpl: (schema, definition, object, path) => {\n    if (typeof object !== 'string') throw new Error(`Expected a string at: ${path.join('.')}`);\n    if (!definition.entries.includes(object)) throw new Error(`Expected an enum value at: ${path.join('.')}`);\n  },\n  toStreamingImpl: (schema, definition, object, path) => {\n    return object;\n  }\n});\n/**\n * @public\n */\nfunction isEnumType(type) {\n  return type[internal].definition.type === 'enum';\n}\n/**\n * @public\n */\nfunction enumeration(description, entries) {\n  return new EnumType({\n    type: 'enum',\n    description,\n    entries,\n    streaming: false\n  });\n}\nconst NullType = HashbrownTypeCtor({\n  name: 'Null',\n  initializer: (inst, def) => {\n    HashbrownType.init(inst, def);\n  },\n  toJsonSchemaImpl: schema => {\n    return {\n      type: 'null',\n      const: schema[internal].definition.value,\n      description: schema[internal].definition.description\n    };\n  },\n  parseJsonSchemaImpl: (schema, object, path) => {\n    // Is this a wrapped primitive?\n    if (object != null && typeof object === 'object' && Object.keys(object).includes(PRIMITIVE_WRAPPER_FIELD_NAME)) {\n      object = object[PRIMITIVE_WRAPPER_FIELD_NAME];\n    }\n    if (object !== null) throw new Error(`Expected a null at: ${path.join('.')}`);\n    return object;\n  },\n  toTypeScriptImpl: schema => {\n    return `/* ${schema[internal].definition.description} */ null`;\n  },\n  validateImpl: (schema, definition, object, path) => {\n    if (object !== null) throw new Error(`Expected a null at: ${path.join('.')}`);\n  },\n  toStreamingImpl: (schema, definition, object, path) => {\n    return object;\n  }\n});\n/**\n * @public\n */\nfunction isNullType(type) {\n  return type[internal].definition.type === 'null';\n}\n/**\n * @public\n */\nfunction nullish() {\n  return new NullType({\n    type: 'null',\n    description: '',\n    streaming: false\n  });\n}\n/**\n * --------------------------------------\n * --------------------------------------\n *           Streaming Helpers\n * --------------------------------------\n * --------------------------------------\n */\nfunction needsDiscriminatorWrapperInAnyOf(schema) {\n  if (isAnyOfType(schema) || isArrayType(schema) || isObjectType(schema) || isStringType(schema) && isStreaming(schema)) {\n    return true;\n  }\n  return false;\n}\nfunction isStreaming(schema) {\n  return schema[internal].definition.streaming;\n}\n/**\n * @public\n */\nfunction isHashbrownType(type) {\n  return type[internal] !== undefined;\n}\n\n/**\n * @public\n */\nfunction getDescription(schema) {\n  return schema[internal].definition.description;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * @public\n */\nfunction string(description) {\n  return new StringType({\n    type: 'string',\n    description,\n    streaming: true\n  });\n}\n/**\n * @public\n */\nfunction object(description, shape) {\n  return new ObjectType({\n    type: 'object',\n    description,\n    streaming: true,\n    shape\n  });\n}\n/**\n * @public\n */\nfunction array(description, item) {\n  return new ArrayType({\n    type: 'array',\n    description,\n    streaming: true,\n    element: item\n  });\n}\n\nvar streaming = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    array: array,\n    object: object,\n    string: string\n});\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Convert an arbitrary description into a camelCase identifier.\n *\n * - Strips out any non-alphanumeric characters\n * - Splits on whitespace\n * - Lowercases all words, then uppercases the first letter of each subsequent word\n * - Prefixes with `_` if the result would start with a digit\n */\nfunction descriptionToCamelCase(description) {\n  const cleaned = description.replace(/[^a-zA-Z0-9]+/g, ' ').trim();\n  const words = cleaned.split(/\\s+/).map(w => w.toLowerCase());\n  if (words.length === 0) return '';\n  const [first, ...rest] = words;\n  const core = first + rest.map(w => w[0].toUpperCase() + w.slice(1)).join('');\n  return /^\\d/.test(core) ? `_${core}` : core;\n}\n/**\n * Walks the HashbrownType graph, finds any sub-schemas seen more than once\n * (excluding the root), assigns each a unique name, and emits a draft-07 JSON Schema\n * with a $defs section.  Cycles always become $refs.\n *\n * @public\n */\nfunction toJsonSchema(schema) {\n  const rootNode = schema;\n  // 1) Collect repeated nodes\n  const seen = new Set();\n  const repeats = new Set();\n  (function visit(n, path) {\n    if (seen.has(n)) {\n      repeats.add(n);\n      return;\n    }\n    seen.add(n);\n    if (isObjectType(n)) {\n      Object.values(n[internal].definition.shape).forEach(child => visit(child, [...path, n]));\n    } else if (isArrayType(n)) {\n      visit(n[internal].definition.element, [...path, n]);\n    } else if (isAnyOfType(n)) {\n      n[internal].definition.options.forEach(opt => visit(opt, [...path, n]));\n    }\n  })(rootNode, []);\n  // never put the root itself into $defs\n  repeats.delete(rootNode);\n  // 2) Assign each repeated node a unique camelCase name\n  const defNameMap = new Map();\n  const usedNames = new Set();\n  let anon = 1;\n  for (const node of repeats) {\n    const desc = node[internal].definition.description || `def${anon++}`;\n    let name = descriptionToCamelCase(desc) || `def${anon++}`;\n    if (usedNames.has(name)) {\n      let i = 1;\n      while (usedNames.has(`${name}${i}`)) i++;\n      name = `${name}${i}`;\n    }\n    usedNames.add(name);\n    defNameMap.set(node, name);\n  }\n  /**\n   * Recursive printer.\n   *\n   * @param n - current node\n   * @param isRoot - true only for the very top-level schema\n   * @param inDef - if non-null, we're printing $defs[inDef] — any other def becomes $ref\n   * @param pathSeen - tracks the chain of inlined nodes to catch cycles\n   */\n  function printNode(n, isRoot = false, inDef = null, pathSeen = new Set(),\n  // If provided, omit this property when printing an object. Used for\n  // anyOf literal-based envelopes where the literal is redundant.\n  omitObjectProp) {\n    // a) cycle back to the root\n    if (!isRoot && n === rootNode) {\n      return {\n        $ref: '#'\n      };\n    }\n    // b) any other shared def becomes a $ref\n    if (defNameMap.has(n) && n !== inDef) {\n      const nm = defNameMap.get(n);\n      return {\n        $ref: `#/$defs/${nm}`\n      };\n    }\n    // c) catch self-cycles or mutual cycles in inline portions\n    if (pathSeen.has(n)) {\n      // if it’s named, ref it; otherwise point at root\n      if (defNameMap.has(n)) {\n        const nm = defNameMap.get(n);\n        return {\n          $ref: `#/$defs/${nm}`\n        };\n      } else {\n        return {\n          $ref: '#'\n        };\n      }\n    }\n    // d) inline this node\n    pathSeen.add(n);\n    let result;\n    if (isObjectType(n)) {\n      // Sort props so that streaming ones are at the end\n      const shapeWithStreamingAtEnd = Object.entries(n[internal].definition.shape)\n      // If we're omitting a prop due to envelope discrimination, remove it\n      .filter(([key]) => omitObjectProp ? key !== omitObjectProp : true).sort((a, b) => {\n        if (!isStreaming(a[1]) && isStreaming(b[1])) {\n          return -1;\n        }\n        if (isStreaming(a[1]) && !isStreaming(b[1])) {\n          return 1;\n        }\n        return 0;\n      });\n      const props = {};\n      for (const [k, child] of shapeWithStreamingAtEnd) {\n        props[k] = printNode(child, false, inDef, pathSeen);\n      }\n      result = n.toJsonSchema();\n      result.properties = props;\n      // Ensure required keys do not include any omitted discriminator prop\n      result.required = Object.keys(props);\n    } else if (isArrayType(n)) {\n      result = n.toJsonSchema();\n      result.items = printNode(n[internal].definition.element, false, inDef, pathSeen);\n      if (isRoot) {\n        result = {\n          type: 'object',\n          additionalProperties: false,\n          required: [PRIMITIVE_WRAPPER_FIELD_NAME],\n          properties: {\n            [PRIMITIVE_WRAPPER_FIELD_NAME]: result\n          }\n        };\n      }\n    } else if (isAnyOfType(n)) {\n      result = n.toJsonSchema();\n      const buildDiscriminatorMap = options => {\n        const map = {};\n        for (const opt of options) {\n          if (!isObjectType(opt)) {\n            return null;\n          }\n          const shape = opt[internal].definition.shape;\n          const literalEntries = Object.entries(shape).filter(([, v]) => isLiteralType(v));\n          // Require exactly one literal for clear discrimination\n          if (literalEntries.length !== 1) {\n            return null;\n          }\n          const [literalKey, litSchema] = literalEntries[0];\n          const literalValue = litSchema[internal].definition.value;\n          if (typeof literalValue !== 'string') {\n            // Only support string-based discriminators for wrapper keys\n            return null;\n          }\n          if (Object.prototype.hasOwnProperty.call(map, literalValue)) {\n            // Ambiguous (duplicate) discriminator value\n            return null;\n          }\n          map[literalValue] = {\n            schema: opt,\n            literalKey,\n            literalValue\n          };\n        }\n        return Object.keys(map).length === options.length ? map : null;\n      };\n      const options = n[internal].definition.options;\n      const literalDiscriminatorMap = buildDiscriminatorMap(options);\n      if (literalDiscriminatorMap) {\n        // Emit wrappers keyed by the literal value\n        result.anyOf = options.map(opt => {\n          // Find this option's literal value by scanning its shape\n          const shape = opt[internal].definition.shape;\n          const [literalKey, litSchema] = Object.entries(shape).find(([, v]) => isLiteralType(v));\n          const literalValue = litSchema[internal].definition.value;\n          return {\n            type: 'object',\n            additionalProperties: false,\n            required: [literalValue],\n            properties: {\n              // When printing the option object, omit the discriminator literal\n              // key from the inner schema because it is already conveyed by\n              // the envelope key (literalValue)\n              [literalValue]: printNode(opt, false, inDef, pathSeen, literalKey)\n            }\n          };\n        });\n      } else {\n        // Fallback to previous behavior: index-based wrappers for complex options\n        result.anyOf = options.map((opt, index) => {\n          if (needsDiscriminatorWrapperInAnyOf(opt)) {\n            const indexAsStr = `${index}`;\n            return {\n              type: 'object',\n              additionalProperties: false,\n              required: [indexAsStr],\n              properties: {\n                [indexAsStr]: printNode(opt, false, inDef, pathSeen)\n              }\n            };\n          } else {\n            return printNode(opt, false, inDef, pathSeen);\n          }\n        });\n      }\n    } else {\n      result = n.toJsonSchema();\n      if (isRoot) {\n        result = {\n          type: 'object',\n          additionalProperties: false,\n          required: [PRIMITIVE_WRAPPER_FIELD_NAME],\n          properties: {\n            [PRIMITIVE_WRAPPER_FIELD_NAME]: result\n          }\n        };\n      }\n    }\n    pathSeen.delete(n);\n    return result;\n  }\n  // 3) Build the $defs section\n  const defs = {};\n  for (const [node, name] of defNameMap.entries()) {\n    // isRoot=false, inDef=node, fresh pathSeen\n    defs[name] = printNode(node, false, node, new Set());\n  }\n  // 4) Print the root schema\n  const rootPrinted = printNode(rootNode, true, null, new Set());\n  // 5) Assemble and return\n  return Object.assign(Object.assign({\n    $schema: 'http://json-schema.org/draft-07/schema#'\n  }, rootPrinted), Object.keys(defs).length > 0 ? {\n    $defs: defs\n  } : {});\n}\n\nvar public_api$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    AnyOfType: AnyOfType,\n    ArrayType: ArrayType,\n    BooleanType: BooleanType,\n    ConstStringType: LiteralType,\n    EnumType: EnumType,\n    HashbrownType: HashbrownType,\n    IntegerType: IntegerType,\n    NullType: NullType,\n    NumberType: NumberType,\n    ObjectType: ObjectType,\n    StringType: StringType,\n    anyOf: anyOf,\n    array: array$1,\n    boolean: boolean,\n    enumeration: enumeration,\n    getDescription: getDescription,\n    integer: integer,\n    isAnyOfType: isAnyOfType,\n    isArrayType: isArrayType,\n    isBooleanType: isBooleanType,\n    isEnumType: isEnumType,\n    isHashbrownType: isHashbrownType,\n    isIntegerType: isIntegerType,\n    isLiteralType: isLiteralType,\n    isNullType: isNullType,\n    isNumberType: isNumberType,\n    isObjectType: isObjectType,\n    isStringType: isStringType,\n    literal: literal,\n    nullish: nullish,\n    number: number,\n    object: object$1,\n    streaming: streaming,\n    string: string$1,\n    toJsonSchema: toJsonSchema\n});\n\nfunction sleep(timeout, abortSignal) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield new Promise(resolve => {\n      const timeoutId = setTimeout(resolve, timeout);\n      if (abortSignal) {\n        abortSignal.addEventListener('abort', () => {\n          clearTimeout(timeoutId);\n        });\n      }\n    });\n  });\n}\nfunction switchAsync(fn, outerSignal) {\n  let abortController;\n  if (outerSignal) {\n    outerSignal.addEventListener('abort', () => {\n      if (abortController) {\n        abortController.abort('cancelled');\n      }\n    });\n  }\n  return () => {\n    if (abortController) {\n      abortController.abort('cancelled');\n    }\n    const controller = new AbortController();\n    abortController = controller;\n    return fn(controller.signal).finally(() => {\n      if (abortController === controller) {\n        abortController = undefined;\n      }\n    });\n  };\n}\n\nvar api_models = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nvar internal_models = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nconst TRACE_LEVEL = 0;\nconst DEBUG_LEVEL = 1;\nconst INFO_LEVEL = 2;\nconst WARN_LEVEL = 3;\nconst ERROR_LEVEL = 4;\nconst NONE_LEVEL = 5;\nclass Logger {\n  constructor(logPathsEnabled) {\n    var _a;\n    this.logPathsEnabled = {};\n    this.logPathsEnabled = logPathsEnabled;\n    this.allLevel = (_a = logPathsEnabled['all']) !== null && _a !== void 0 ? _a : NONE_LEVEL;\n  }\n  for(loggerName) {\n    return {\n      trace: args => {\n        if (this.allLevel <= TRACE_LEVEL || this.logPathsEnabled[loggerName] && this.logPathsEnabled[loggerName] <= TRACE_LEVEL) {\n          console.trace(args);\n        }\n      },\n      debug: args => {\n        if (this.allLevel <= DEBUG_LEVEL || this.logPathsEnabled[loggerName] && this.logPathsEnabled[loggerName] <= DEBUG_LEVEL) {\n          console.log(args);\n        }\n      },\n      info: args => {\n        if (this.allLevel <= INFO_LEVEL || this.logPathsEnabled[loggerName] && this.logPathsEnabled[loggerName] <= INFO_LEVEL) {\n          console.info(args);\n        }\n      },\n      warn: args => {\n        if (this.allLevel <= WARN_LEVEL || this.logPathsEnabled[loggerName] && this.logPathsEnabled[loggerName] <= ERROR_LEVEL) {\n          console.warn(args);\n        }\n      },\n      error: args => {\n        if (this.allLevel <= ERROR_LEVEL || this.logPathsEnabled[loggerName] && this.logPathsEnabled[loggerName] <= TRACE_LEVEL) {\n          console.error(args);\n        }\n      }\n    };\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Skillet is an LLM-optimized streaming JSON Parser - perfectly suited for streaming hot and fresh JSON.\n *\n * Portions of this code are derived from partial-json (MIT License) (https://github.com/promplate/partial-json-parser-js).\n * See the LICENSE file in the project root for full license text.\n *\n * @license MIT\n * @author LiveLoveApp, LLC\n * @see https://github.com/liveloveapp/hashbrown\n * @see https://github.com/promplate/partial-json-parser-js\n */\nconst LOG_SETTINGS = {\n  all: NONE_LEVEL\n};\nclass PartialJSON extends Error {}\nclass MalformedJSON extends Error {}\nclass IncompleteNonStreamingObject extends Error {}\nclass UnexpectedStreamingType extends Error {}\nfunction shouldBeWrappedPrimitive(schema) {\n  if (isAnyOfType(schema) || isObjectType(schema)) {\n    return false;\n  }\n  return true;\n}\nconst buildDiscriminatorMap = options => {\n  const map = {};\n  for (const opt of options) {\n    if (!isObjectType(opt)) {\n      return null;\n    }\n    const shape = opt[internal].definition.shape;\n    // Find literal properties on this object option\n    const literalEntries = Object.entries(shape).filter(([, v]) => isLiteralType(v));\n    // Must have exactly one literal for unambiguous discrimination\n    if (literalEntries.length !== 1) {\n      return null;\n    }\n    const [literalKey, literalSchema] = literalEntries[0];\n    const literalValue = literalSchema[internal].definition.value;\n    if (typeof literalValue !== 'string') {\n      // Only support string discriminators\n      return null;\n    }\n    if (Object.prototype.hasOwnProperty.call(map, literalValue)) {\n      // Duplicate discriminator value -> ambiguous\n      return null;\n    }\n    map[literalValue] = {\n      schema: opt,\n      literalKey,\n      literalValue\n    };\n  }\n  return Object.keys(map).length === options.length ? map : null;\n};\nfunction parseJSON(jsonString, schema, assumeFinishedMessage) {\n  if (typeof jsonString !== 'string') {\n    throw new TypeError(`expecting str, got ${typeof jsonString}`);\n  }\n  if (!jsonString.trim()) {\n    return '';\n  }\n  return _parseJSON(jsonString.trim(), schema, assumeFinishedMessage);\n}\nconst _parseJSON = (jsonString, schema, assumeFinishedMessage) => {\n  const logger = new Logger(LOG_SETTINGS);\n  logger.for('_parseJSON').info('In _parseJson');\n  // Since each parse run is effectively starting over, this string should indicate\n  // how far we can expect to get this time\n  logger.for('_parseJSON').info(jsonString);\n  const length = jsonString.length;\n  let index = 0;\n  // Track current object/array so we can move up and down the document stack as we go\n  const containerStack = [schema];\n  const markPartialJSON = msg => {\n    throw new PartialJSON(`${msg} at position ${index}`);\n  };\n  const throwMalformedError = msg => {\n    throw new MalformedJSON(`${msg} at position ${index}`);\n  };\n  const parseAny = (currentKey, allowsIncomplete, insideArray, literalKey) => {\n    skipBlank();\n    logger.for('parseAny').info(`Remaining string: ${jsonString.slice(index)}`);\n    const currentLastContainer = containerStack[containerStack.length - 1];\n    logger.for('parseAny').debug('Current last container:');\n    logger.for('parseAny').debug(currentLastContainer);\n    if (index >= length) markPartialJSON('Unexpected end of input');\n    if (jsonString[index] === '\"') {\n      return parseStr(allowsIncomplete);\n    }\n    if (jsonString[index] === '{') {\n      /*\n        If the top-level schema is a primitive that should be object-wrapped, we\n        assume a wrapped primitive is starting\n               If the current container is an array, we assume an anyOf wrapper is starting.\n        \n        Else, we parse as a regular object.\n      */\n      if (Array.isArray(currentLastContainer)) {\n        return parseAnyOf(currentKey);\n      } else if (shouldBeWrappedPrimitive(currentLastContainer)) {\n        return parseWrappedPrimitive();\n      } else {\n        return parseObj(currentKey, insideArray, literalKey);\n      }\n    }\n    if (jsonString[index] === '[') {\n      return parseArr(currentKey, allowsIncomplete);\n    }\n    if (jsonString.substring(index, index + 4) === 'null') {\n      index += 4;\n      return null;\n    }\n    if (jsonString.substring(index, index + 4) === 'true') {\n      index += 4;\n      return true;\n    }\n    if (jsonString.substring(index, index + 5) === 'false') {\n      index += 5;\n      return false;\n    }\n    return parseNum();\n  };\n  const parseStr = allowsIncomplete => {\n    if (containerStack.length === 1) {\n      // String literal at top level, so see if the the schema allows streaming\n      allowsIncomplete = isStreaming(schema);\n    }\n    const start = index;\n    // Is the next character a string?\n    // parseAny checks before calling parseStr, but functions parsing\n    // key names (i.e. parseObj) do not, and we need to detect potentially\n    // malformed JSON immediately following a comma\n    if (jsonString[start] !== '\"') {\n      throwMalformedError('String expected but not started');\n    }\n    let escape = false;\n    index++; // skip initial quote\n    while (index < length && (jsonString[index] !== '\"' || escape && jsonString[index - 1] === '\\\\')) {\n      escape = jsonString[index] === '\\\\' ? !escape : false;\n      index++;\n    }\n    if (jsonString.charAt(index) == '\"') {\n      try {\n        return JSON.parse(jsonString.substring(start, ++index - Number(escape)));\n      } catch (e) {\n        throwMalformedError(String(e));\n      }\n    } else if (allowsIncomplete) {\n      try {\n        return JSON.parse(jsonString.substring(start, index - Number(escape)) + '\"');\n      } catch (_a) {\n        // SyntaxError: Invalid escape sequence\n        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('\\\\')) + '\"');\n      }\n    }\n    markPartialJSON('Unterminated string literal');\n  };\n  const handleIncompleteWrappedPrimitive = val => {\n    if (val == null) {\n      throw new IncompleteNonStreamingObject('Incomplete wrapped primitive object found');\n    }\n    return val;\n  };\n  const parseWrappedPrimitive = () => {\n    logger.for('parseWrappedPrimitive').info(`Parsing wrapped primitive object`);\n    index++; // skip initial brace\n    skipBlank();\n    let value = undefined;\n    try {\n      while (jsonString[index] !== '}') {\n        skipBlank();\n        if (index >= length) {\n          return handleIncompleteWrappedPrimitive(value);\n        }\n        const key = parseStr(false);\n        if (key !== PRIMITIVE_WRAPPER_FIELD_NAME) {\n          // How did we get here if this isn't really a wrapped primitive?\n          throwMalformedError(`Wrapped primitive has unexpected key name: ${key}`);\n        }\n        skipBlank();\n        index++; // skip colon\n        try {\n          logger.for('parseWrappedPrimitive').debug(`Handling key: ${key}`);\n          const matchingSchema = containerStack[containerStack.length - 1];\n          logger.for('parseWrappedPrimitive').debug('Found top-level schema:');\n          logger.for('parseWrappedPrimitive').debug(matchingSchema);\n          // This isn't a real object, so don't pass the key name\n          value = parseAny('', isStreaming(matchingSchema), false, undefined);\n          logger.for('parseWrappedPrimitive').debug('Value:');\n          logger.for('parseWrappedPrimitive').debug(value);\n        } catch (e) {\n          logger.for('parseWrappedPrimitive').error(e);\n          return handleIncompleteWrappedPrimitive(value);\n        }\n        skipBlank();\n        if (jsonString[index] === ',') index++; // skip comma\n      }\n    } catch (e) {\n      logger.for('parseWrappedPrimitive').error(e);\n      return handleIncompleteWrappedPrimitive(value);\n    }\n    index++; // skip final brace\n    const completedContainer = containerStack.pop();\n    logger.for('parseWrappedPrimitive').info(`Completed wrapped primitive container: ${completedContainer === null || completedContainer === void 0 ? void 0 : completedContainer[internal].definition.description}`);\n    return value;\n  };\n  const handleIncompleteAnyOf = val => {\n    if (val == null) {\n      throw new IncompleteNonStreamingObject('Incomplete anyOf object found');\n    }\n    return val;\n  };\n  const parseAnyOf = parentKey => {\n    var _a;\n    logger.for('parseAnyOf').info(`Parsing anyOf with parent: ${parentKey}`);\n    index++; // skip initial brace\n    skipBlank();\n    let value = undefined;\n    let currentContainerStackIndex = containerStack.length - 1;\n    const optionsForMap = (_a = containerStack[currentContainerStackIndex]) !== null && _a !== void 0 ? _a : [];\n    const literalDiscriminatorMap = Array.isArray(optionsForMap) ? buildDiscriminatorMap(optionsForMap) : null;\n    const getMatchingSchemaForDiscriminator = key => {\n      if (literalDiscriminatorMap && key in literalDiscriminatorMap) {\n        return literalDiscriminatorMap[key];\n      }\n      // Fallback to numeric discriminator\n      const numericIndex = parseInt(key);\n      if (Array.isArray(optionsForMap)) {\n        const schema = optionsForMap[numericIndex];\n        return schema ? {\n          schema\n        } : undefined;\n      }\n      return undefined;\n    };\n    try {\n      while (jsonString[index] !== '}') {\n        skipBlank();\n        if (index >= length) {\n          return handleIncompleteAnyOf(value);\n        }\n        const key = parseStr(false);\n        skipBlank();\n        index++; // skip colon\n        try {\n          logger.for('parseAnyOf').debug(`Handling discriminator: ${key}`);\n          const matching = getMatchingSchemaForDiscriminator(key);\n          logger.for('parseAnyOf').debug(`Found matching schema in current container for ${key}: ${!!(matching && matching.schema)}`);\n          if (matching === null || matching === void 0 ? void 0 : matching.schema) {\n            logger.for('parseAnyOf').debug('Adding schema for discriminator');\n            logger.for('parseAnyOf').debug(matching.schema);\n            // If the matching schema is itself an anyOf, we need to push its options array\n            // to the schema stack instead of the schema\n            if (isAnyOfType(matching.schema)) {\n              containerStack.push(matching.schema[internal].definition.options);\n            } else {\n              containerStack.push(object$1(`AnyOf Wrapper for ${key}`, {\n                [key]: matching.schema\n              }));\n            }\n            currentContainerStackIndex = containerStack.length - 1;\n            value = parseAny(key, true, false, matching === null || matching === void 0 ? void 0 : matching.literalKey);\n            // If we matched via literal discriminator and the inner object doesn't\n            // include the literal field, inject it so the parsed result conforms\n            // to the declared schema.\n            if (literalDiscriminatorMap && matching.literalKey && matching.literalValue && value != null && typeof value === 'object' && !(matching.literalKey in value)) {\n              value[matching.literalKey] = matching.literalValue;\n            }\n            logger.for('parseAnyOf').debug('Value:');\n            logger.for('parseAnyOf').debug(value);\n          } else {\n            throwMalformedError(`No schema found for discriminator: ${key}`);\n          }\n        } catch (e) {\n          logger.for('parseAnyOf').error(e);\n          return handleIncompleteAnyOf(value);\n        }\n        skipBlank();\n        if (jsonString[index] === ',') index++; // skip comma\n      }\n    } catch (e) {\n      logger.for('parseAnyOf').error(e);\n      return handleIncompleteAnyOf(value);\n    }\n    index++; // skip final brace\n    const completedContainer = containerStack.pop();\n    if (Array.isArray(completedContainer)) {\n      logger.for('parseAnyOf').debug(`Completed nested anyOf container`);\n    } else {\n      logger.for('parseAnyOf').debug(`Completed anyOf container: ${completedContainer === null || completedContainer === void 0 ? void 0 : completedContainer[internal].definition.description}`);\n    }\n    return value;\n  };\n  const handleIncompleteObject = (currentContainerStackIndex, obj, literalKey) => {\n    const currentContainer = containerStack[currentContainerStackIndex];\n    if (isStreaming(currentContainer)) {\n      logger.for('parseObj').debug('Index >= length: returning partial object');\n      return obj;\n    }\n    logger.for('parseObj').debug('Index >= length: opting not to return partial obj if non-streaming properties are missing');\n    // Are all non-streaming fields present?\n    if (Object.entries(currentContainer[internal].definition.shape).every(([key, subSchema]) => {\n      logger.for('parseObj').debug(`key ${key} is streaming: ${isStreaming(subSchema)} and present: ${key in obj}`);\n      if (key === literalKey) {\n        // A literal key extracted from an anyOf to be a discriminator won't be in the\n        // object until after it is finished parsing, so skip checking for it.\n        logger.for('parseObj').debug(`key ${key} is an extracted discriminator, so it will not be present`);\n        return true;\n      }\n      // if this key is streaming and not present, add an \"empty\" value\n      if (isStreaming(subSchema)) {\n        if (!(key in obj)) {\n          if (isStringType(subSchema) || isLiteralType(subSchema) || isEnumType(subSchema)) {\n            obj[key] = '';\n          } else if (isArrayType(subSchema)) {\n            obj[key] = [];\n          } else if (isObjectType(subSchema)) {\n            obj[key] = {};\n          } else {\n            throw new UnexpectedStreamingType('Unexpected schema type for a streaming prop');\n          }\n        }\n        return true;\n      }\n      if (key in obj) {\n        return true;\n      }\n      // If the key schema is an anyOf and includes nullish, default to null\n      if (isAnyOfType(subSchema)) {\n        const options = subSchema[internal].definition.options;\n        if (options.some(opt => isNullType(opt))) {\n          obj[key] = null;\n          return true;\n        }\n      }\n      return false;\n    })) {\n      return obj;\n    }\n    throw new IncompleteNonStreamingObject('Incomplete but non-streaming object found');\n  };\n  const parseObj = (parentKey, insideArray, literalKey) => {\n    var _a, _b;\n    logger.for('parseObj').info(`Parsing object with parent: ${parentKey}`);\n    index++; // skip initial brace\n    skipBlank();\n    const obj = {};\n    let inAnyOfWrapper = false;\n    // If we are not in an array, find key in current level of document stock, and add to stack\n    if (parentKey !== '') {\n      // Are we in any anyOf?\n      const currentContainer = containerStack[containerStack.length - 1];\n      // Not an anyOf, so move down a level\n      if (!Array.isArray(currentContainer)) {\n        // If parentKey is set, we are not in an array, so get the next stack container\n        // (arrays handle it differently, so they can do clean up when the array is complete)\n        const nextContainer = currentContainer[internal].definition.shape[parentKey];\n        logger.for('parseObj').debug(`Starting new object with key: ${parentKey}`);\n        logger.for('parseObj').debug(nextContainer);\n        if (nextContainer == null) {\n          throwMalformedError(`Key: ${parentKey} not expected in container`);\n        }\n        containerStack.push(nextContainer);\n      }\n    }\n    const currentContainerStackIndex = containerStack.length - 1;\n    try {\n      while (jsonString[index] !== '}') {\n        skipBlank();\n        if (index >= length) {\n          return handleIncompleteObject(currentContainerStackIndex, obj, literalKey);\n        }\n        const key = parseStr(false);\n        skipBlank();\n        index++; // skip colon\n        try {\n          logger.for('parseObj').debug(`Handling key: ${key}`);\n          const currentContainer = containerStack[currentContainerStackIndex];\n          // Is this an anyOf (which can happen for nested anyOfs)\n          if (isAnyOfType(currentContainer)) {\n            // Property is anyOf, so push option list to container stack\n            containerStack.push(currentContainer[internal].definition.options);\n            logger.for('parseObj').debug(`Object key ${key} in container ${currentContainerStackIndex} is anyOf`);\n            // AnyOfs are never directly streaming\n            const value = parseAny(key, false, false, undefined);\n            inAnyOfWrapper = true;\n            logger.for('parseObj').debug('Value:');\n            logger.for('parseObj').debug(value);\n            obj[key] = value;\n          } else {\n            // This is a regular object, so find the schema for the key\n            const schemaFragmentForKey = currentContainer[internal].definition.shape[key];\n            if (isAnyOfType(schemaFragmentForKey)) {\n              // Property is anyOf, so push option list to container stack\n              containerStack.push(schemaFragmentForKey[internal].definition.options);\n              logger.for('parseObj').debug(`Object key ${key} in container ${currentContainerStackIndex} is anyOf`);\n              // AnyOfs are never directly streaming\n              const value = parseAny(key, false, false, undefined);\n              inAnyOfWrapper = true;\n              logger.for('parseObj').debug('Value:');\n              logger.for('parseObj').debug(value);\n              obj[key] = value;\n            } else {\n              const currentKeyAllowsIncomplete = isStreaming(schemaFragmentForKey);\n              logger.for('parseObj').debug(`Object key ${key} in container ${currentContainerStackIndex} allows incomplete: ${currentKeyAllowsIncomplete}`);\n              const value = parseAny(key, currentKeyAllowsIncomplete, false, undefined);\n              logger.for('parseObj').debug('Value:');\n              logger.for('parseObj').debug(value);\n              obj[key] = value;\n            }\n          }\n        } catch (e) {\n          logger.for('parseObj').error(e);\n          return handleIncompleteObject(currentContainerStackIndex, obj, literalKey);\n        }\n        skipBlank();\n        if (jsonString[index] === ',') index++; // skip comma\n      }\n    } catch (e) {\n      logger.for('parseObj').error(e);\n      return handleIncompleteObject(currentContainerStackIndex, obj, literalKey);\n    }\n    index++; // skip final brace\n    // Are we inside an array?  They handle adding/removing stack containers for themselves\n    if (!insideArray || inAnyOfWrapper) {\n      // If we just completed an anyOf wrapper, we need to pop the options array off the stack\n      if (!insideArray && inAnyOfWrapper) {\n        const completedContainer = containerStack.pop();\n        logger.for('parseObj').debug(`Also completed anyOf container: ${completedContainer}`);\n      }\n      // Done with this container, so pop off stack\n      const completedContainer = containerStack.pop();\n      logger.for('parseObj').debug(`Completed object container: ${(_b = (_a = completedContainer === null || completedContainer === void 0 ? void 0 : completedContainer[internal]) === null || _a === void 0 ? void 0 : _a.definition) === null || _b === void 0 ? void 0 : _b.description}`);\n    } else {\n      logger.for('parseObj').debug('Inside array. Object completed, but keeping container stack');\n    }\n    return obj;\n  };\n  const parseArr = (currentKey, allowsIncomplete) => {\n    if (containerStack.length === 1 && isArrayType(containerStack[0])) {\n      // See if the the schema allows streaming\n      allowsIncomplete = isStreaming(schema);\n    }\n    index++; // skip initial bracket\n    logger.for('parseArr').info('parseArr: Start');\n    const arr = [];\n    let arrayContainer = containerStack[containerStack.length - 1][internal].definition.element;\n    if (currentKey) {\n      arrayContainer = containerStack[containerStack.length - 1][internal].definition.shape[currentKey][internal].definition.element;\n    }\n    logger.for('parseArr').debug('Array container: ');\n    logger.for('parseArr').debug(arrayContainer);\n    logger.for('parseArr').debug(`Allows streaming? ${allowsIncomplete}`);\n    // logger.log(`Is anyOf? ${s.isAnyOfType(arrayContainer)}`);\n    let containerNeedsPopping = false;\n    let contentsAllowIncomplete = false;\n    // If this array is of objects, push the container onto the stack\n    if (isObjectType(arrayContainer)) {\n      logger.for('parseArr').debug('Array container is object type');\n      containerStack.push(arrayContainer);\n      containerNeedsPopping = true;\n    } else if (isAnyOfType(arrayContainer)) {\n      logger.for('parseArr').debug('Array container is anyOf. Pushing anyOf array to container stack');\n      containerStack.push(arrayContainer[internal].definition.options);\n      containerNeedsPopping = true;\n    } else {\n      logger.for('parseArr').debug('Array container is primitive');\n      // It's not an object, so check if it is a streaming primitive\n      contentsAllowIncomplete = isStreaming(arrayContainer);\n      logger.for('parseArr').debug(`Array primitive content allows streaming: ${contentsAllowIncomplete}`);\n    }\n    try {\n      while (jsonString[index] !== ']') {\n        logger.for('parseArr').debug(`Array content allows incomplete: ${contentsAllowIncomplete}`);\n        arr.push(parseAny('', contentsAllowIncomplete, true, undefined));\n        skipBlank();\n        if (jsonString[index] === ',') {\n          index++; // skip comma\n        }\n      }\n    } catch (_a) {\n      // logger.for('parseArr').error(e);\n      if (allowsIncomplete) {\n        return arr;\n      }\n      markPartialJSON(\"Expected ']' at end of array\");\n    }\n    index++; // skip final bracket\n    // Array was completed, so put container off if needed\n    if (containerNeedsPopping) {\n      containerStack.pop();\n    }\n    return arr;\n  };\n  const parseNum = () => {\n    if (index === 0) {\n      if (jsonString === '-') throwMalformedError(\"Not sure what '-' is\");\n      try {\n        // JSON string starts with a number, so we'll try to parse the whole thing as one.\n        // Thus, set index to length.\n        index = jsonString.length;\n        return JSON.parse(jsonString);\n      } catch (e) {\n        throwMalformedError(String(e));\n      }\n    }\n    const start = index;\n    if (jsonString[index] === '-') index++;\n    while (jsonString[index] && ',]}'.indexOf(jsonString[index]) === -1) index++;\n    if (index == length) markPartialJSON('Unterminated number literal');\n    try {\n      return JSON.parse(jsonString.substring(start, index));\n    } catch (_a) {\n      if (jsonString.substring(start, index) === '-') markPartialJSON(\"Not sure what '-' is\");\n      try {\n        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('e')));\n      } catch (e) {\n        throwMalformedError(String(e));\n      }\n    }\n  };\n  const skipBlank = () => {\n    while (index < length && ' \\n\\r\\t'.includes(jsonString[index])) {\n      index++;\n    }\n  };\n  try {\n    const result = parseAny('', false, false, undefined);\n    // We returned, but have we not consumed the whole length?\n    // We only check this on finished messages so as not to spam\n    // the warning on each few-character chunk of a streaming\n    // message.\n    if (assumeFinishedMessage && index < length) {\n      // NB: We call console.warn directly here instead of using the\n      // logger mechanism, because getting here almost always means the\n      // LLM hallucinated, adding extra stuff after the response or encoded\n      // it in a strange way (like escaping part or all of the JSON).\n      console.warn(`Extra data detected after parsing.\\n\nParsed: ${JSON.stringify(result)}\\n\nLeft over: ${jsonString.substring(index)}\\n\nThis is often caused by extra or incorrectly formatted data being returned by the \nLLM, despite requesting data with a particular structure.\n\nDifferent models, by default, handle complex structured data with varied levels of accuracy.\n\nModel behavior can typically be improved by:\n- Adding 1-3 examples of correct output to your prompt (aka few-shot).\n- Adding guardrails to the prompt like \"Do not escape tool function arguments.\"\n`);\n    }\n    return result;\n  } catch (e) {\n    if (e instanceof IncompleteNonStreamingObject) {\n      logger.for('_parseJSON').error('Got incomplete object error at top level');\n      return '';\n    }\n    if (e instanceof PartialJSON) {\n      logger.for('_parseJSON').error('Got unterminated container');\n      return '';\n    }\n    if (e instanceof MalformedJSON) {\n      if (e.message.includes('Exponent part is missing a number')) {\n        logger.for('_parseJSON').error('Found number with exponent sans number');\n        return '';\n      }\n      if (e.message.includes('Unterminated fractional number')) {\n        logger.for('_parseJSON').error('Found number with decimal point sans numbers');\n        return '';\n      }\n    }\n    throw e;\n  }\n};\n\nclass StreamSchemaParser {\n  constructor(schema) {\n    this.dataString = '';\n    this.schema = schema;\n  }\n  parse(item, assumeFinishedMessage) {\n    this.dataString += item;\n    const currResult = parseJSON(this.dataString, this.schema, assumeFinishedMessage);\n    return currResult;\n  }\n}\n\n/**\n * Converts a view message to an internal message.\n *\n * @param message - The view message to convert.\n * @returns The internal message.\n * @internal\n */\nfunction toInternalMessagesFromView(message) {\n  switch (message.role) {\n    case 'user':\n      {\n        return [{\n          role: 'user',\n          content: message.content\n        }];\n      }\n    case 'assistant':\n      {\n        return [{\n          role: 'assistant',\n          content: message.content,\n          toolCallIds: message.toolCalls.map(toolCall => toolCall.toolCallId)\n        }];\n      }\n    default:\n      {\n        return [];\n      }\n  }\n}\n/**\n * Converts an internal message to a view message.\n *\n * @param message - The internal message to convert.\n * @returns The view message.\n * @internal\n */\nfunction toViewMessagesFromInternal(message, toolCalls, tools, outputSchema, streaming = true) {\n  switch (message.role) {\n    case 'user':\n      {\n        return [{\n          role: 'user',\n          content: message.content\n        }];\n      }\n    case 'error':\n      {\n        return [{\n          role: 'error',\n          content: message.content\n        }];\n      }\n    case 'assistant':\n      {\n        const tater = outputSchema ? new StreamSchemaParser(outputSchema) : undefined;\n        let content = message.content;\n        if (typeof message.content === 'string' && tater) {\n          content = tater.parse(message.content, !streaming);\n        } else if (message.content && typeof message.content === 'object') {\n          content = message.content;\n        }\n        return [{\n          role: 'assistant',\n          content,\n          toolCalls: message.toolCallIds.flatMap(toolCallId => {\n            const toolCall = toolCalls[toolCallId];\n            const tool = tools.find(tool => tool.name === toolCall.name);\n            if (!tool) {\n              return [];\n            }\n            let toolArgs = toolCall.arguments;\n            // Ollama will return POJOs\n            if (typeof toolCall.arguments === 'object') {\n              toolArgs = JSON.stringify(toolCall.arguments);\n            }\n            switch (toolCall.status) {\n              case 'done':\n                {\n                  return [{\n                    role: 'tool',\n                    status: 'done',\n                    name: toolCall.name,\n                    toolCallId,\n                    args: isHashbrownType(tool.schema) ? new StreamSchemaParser(tool.schema).parse(toolArgs, !streaming) : JSON.parse(toolArgs),\n                    // The internal models don't use a union, since that tends to\n                    // complicate reducer logic. This is necessary to uplift our\n                    // internal model into the view union.\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    result: toolCall.result\n                  }];\n                }\n              case 'pending':\n                {\n                  return [{\n                    role: 'tool',\n                    status: 'pending',\n                    name: toolCall.name,\n                    toolCallId,\n                    progress: toolCall.progress,\n                    args: isHashbrownType(tool.schema) ? new StreamSchemaParser(tool.schema).parse(toolArgs, !streaming) : null\n                  }];\n                }\n            }\n          })\n        }];\n      }\n    default:\n      {\n        return [];\n      }\n  }\n}\n/**\n * Converts an internal message to an API message.\n *\n * @param message - The internal message to convert.\n * @param toolCalls - The tool calls to convert.\n * @returns The API message.\n * @internal\n */\nfunction toApiMessagesFromInternal(message, toolCalls) {\n  switch (message.role) {\n    case 'user':\n      {\n        return [{\n          role: 'user',\n          content: typeof message.content === 'string' ? message.content : JSON.stringify(message.content)\n        }];\n      }\n    case 'assistant':\n      {\n        const toolCallsForMessage = toolCalls.filter(toolCall => message.toolCallIds.includes(toolCall.id));\n        const toolMessages = toolCallsForMessage.flatMap(toolCall => {\n          if (toolCall.status !== 'done' || !toolCall.result) {\n            return [];\n          }\n          return [{\n            role: 'tool',\n            content: toolCall.result,\n            toolCallId: toolCall.id,\n            toolName: toolCall.name\n          }];\n        });\n        return [{\n          role: 'assistant',\n          content: message.content,\n          toolCalls: toolCallsForMessage.map((toolCall, index) => ({\n            id: toolCall.id,\n            index,\n            type: 'function',\n            function: {\n              name: toolCall.name,\n              arguments: toolCall.arguments\n            }\n          }))\n        }, ...toolMessages];\n      }\n    default:\n      {\n        return [];\n      }\n  }\n}\n/**\n * Converts an internal tool to an API tool.\n *\n * @param tool - The internal tool to convert.\n * @returns The API tool.\n * @internal\n */\nfunction toApiToolsFromInternal(tools, emulateStructuredOutput, outputSchema) {\n  const apiTools = tools.map(tool => ({\n    description: tool.description,\n    name: tool.name,\n    parameters: isHashbrownType(tool.schema) ? toJsonSchema(tool.schema) : tool.schema\n  }));\n  if (emulateStructuredOutput) {\n    apiTools.push({\n      description: 'This should be your final tool call. Generate a response that matches the provided schema.',\n      name: 'output',\n      parameters: toJsonSchema(outputSchema)\n    });\n  }\n  return apiTools;\n}\n/**\n * Converts an API tool call to an internal tool call.\n *\n * @param toolCall - The API tool call to convert.\n * @returns The internal tool calls.\n * @internal\n */\nfunction toInternalToolCallsFromApi(toolCall) {\n  if (toolCall.function.name === 'output') {\n    return [];\n  }\n  return [{\n    id: toolCall.id,\n    name: toolCall.function.name,\n    arguments: toolCall.function.arguments,\n    status: 'pending'\n  }];\n}\n/**\n * Converts a view message to an internal tool call.\n *\n * @param message - The view message to convert.\n * @returns The internal tool calls.\n * @internal\n */\nfunction toInternalToolCallsFromView(messages) {\n  return messages.flatMap(message => {\n    if (message.role !== 'assistant') {\n      return [];\n    }\n    return message.toolCalls.map(toolCall => {\n      switch (toolCall.status) {\n        case 'done':\n          {\n            return {\n              id: toolCall.toolCallId,\n              name: toolCall.name,\n              arguments: JSON.stringify(toolCall.args),\n              status: 'done',\n              result: toolCall.result\n            };\n          }\n        case 'pending':\n          {\n            return {\n              id: toolCall.toolCallId,\n              name: toolCall.name,\n              status: 'pending',\n              arguments: JSON.stringify(toolCall.args)\n            };\n          }\n      }\n    });\n  });\n}\n/**\n * Converts an API assistant message to an internal assistant message.\n *\n * @param message - The API assistant message to convert.\n * @returns The internal assistant message.\n * @internal\n */\nfunction toInternalMessagesFromApi(message) {\n  var _a, _b;\n  if (message.role === 'tool') {\n    return [];\n  }\n  if (message.role === 'user') {\n    return [{\n      role: 'user',\n      content: message.content\n    }];\n  }\n  if (message.role === 'error') {\n    return [{\n      role: 'error',\n      content: message.content\n    }];\n  }\n  const output = (_a = message.toolCalls) === null || _a === void 0 ? void 0 : _a.find(toolCall => toolCall.function.name === 'output');\n  const content = output ? output.function.arguments : message.content;\n  return [{\n    role: 'assistant',\n    content,\n    toolCallIds: ((_b = message.toolCalls) === null || _b === void 0 ? void 0 : _b.filter(toolCall => toolCall.function.name !== 'output').map(toolCall => toolCall.id)) || []\n  }];\n}\n\nvar internal_helpers = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    toApiMessagesFromInternal: toApiMessagesFromInternal,\n    toApiToolsFromInternal: toApiToolsFromInternal,\n    toInternalMessagesFromApi: toInternalMessagesFromApi,\n    toInternalMessagesFromView: toInternalMessagesFromView,\n    toInternalToolCallsFromApi: toInternalToolCallsFromApi,\n    toInternalToolCallsFromView: toInternalToolCallsFromView,\n    toViewMessagesFromInternal: toViewMessagesFromInternal\n});\n\nvar public_api = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Api: api_models,\n    Internal: internal_models,\n    helpers: internal_helpers\n});\n\nconst initialState$4 = {\n  apiUrl: '',\n  model: '',\n  system: '',\n  debounce: 150,\n  emulateStructuredOutput: false,\n  retries: 0\n};\nconst reducer$5 = createReducer(initialState$4, on(devActions.init, (state, action) => {\n  var _a, _b, _c;\n  return Object.assign(Object.assign({}, state), {\n    apiUrl: action.payload.apiUrl,\n    model: action.payload.model,\n    system: action.payload.system,\n    debounce: (_a = action.payload.debounce) !== null && _a !== void 0 ? _a : state.debounce,\n    responseSchema: action.payload.responseSchema,\n    middleware: action.payload.middleware,\n    emulateStructuredOutput: (_b = action.payload.emulateStructuredOutput) !== null && _b !== void 0 ? _b : state.emulateStructuredOutput,\n    retries: (_c = action.payload.retries) !== null && _c !== void 0 ? _c : state.retries\n  });\n}), on(devActions.updateOptions, (state, action) => {\n  return Object.assign(Object.assign({}, state), action.payload);\n}));\nconst selectApiUrl$1 = state => state.apiUrl;\nconst selectModel$1 = state => state.model;\nconst selectSystem$1 = state => state.system;\nconst selectDebounce$1 = state => state.debounce;\nconst selectResponseSchema$1 = state => state.responseSchema;\nconst selectMiddleware$1 = state => state.middleware;\nconst selectEmulateStructuredOutput$1 = state => state.emulateStructuredOutput;\nconst selectRetries$1 = state => state.retries;\n\nconst initialState$3 = {\n  messages: []\n};\nconst reducer$4 = createReducer(initialState$3, on(devActions.init, (state, action) => {\n  const messages = action.payload.messages;\n  if (!messages) {\n    return state;\n  }\n  return Object.assign(Object.assign({}, state), {\n    messages: messages.flatMap(message => toInternalMessagesFromView(message))\n  });\n}), on(apiActions.generateMessageSuccess, (state, action) => {\n  const message = action.payload;\n  const internalMessages = toInternalMessagesFromApi(message);\n  return Object.assign(Object.assign({}, state), {\n    messages: [...state.messages, ...internalMessages]\n  });\n}), on(apiActions.generateMessageError, (state, action) => {\n  const message = action.payload;\n  const errorMessage = {\n    role: 'error',\n    content: message.message\n  };\n  return Object.assign(Object.assign({}, state), {\n    messages: [...state.messages, errorMessage]\n  });\n}), on(devActions.setMessages, (state, action) => {\n  const messages = action.payload.messages;\n  const internalMessages = messages.flatMap(message => toInternalMessagesFromView(message));\n  return Object.assign(Object.assign({}, state), {\n    messages: internalMessages\n  });\n}), on(devActions.sendMessage, (state, action) => {\n  const message = action.payload.message;\n  const internalMessages = toInternalMessagesFromView(message);\n  return Object.assign(Object.assign({}, state), {\n    messages: [...state.messages, ...internalMessages]\n  });\n}));\nconst selectMessages$1 = state => state.messages;\n\nconst initialStatusState = {\n  isReceiving: false,\n  isSending: false,\n  isRunningToolCalls: false,\n  error: undefined,\n  exhaustedRetries: false\n};\nconst reducer$3 = createReducer(initialStatusState, on(devActions.init, (state, action) => {\n  var _a;\n  const messages = (_a = action.payload.messages) !== null && _a !== void 0 ? _a : [];\n  const lastMessage = messages[messages.length - 1];\n  if ((lastMessage === null || lastMessage === void 0 ? void 0 : lastMessage.role) === 'user') {\n    return Object.assign(Object.assign({}, state), {\n      isSending: true\n    });\n  }\n  return state;\n}), on(devActions.sendMessage, devActions.setMessages, devActions.resendMessages, state => {\n  return Object.assign(Object.assign({}, state), {\n    isSending: true\n  });\n}), on(apiActions.generateMessageStart, state => {\n  return Object.assign(Object.assign({}, state), {\n    isSending: false,\n    isReceiving: true\n  });\n}), on(apiActions.generateMessageChunk, state => {\n  return Object.assign(Object.assign({}, state), {\n    isReceiving: true\n  });\n}), on(apiActions.generateMessageSuccess, state => {\n  return Object.assign(Object.assign({}, state), {\n    isReceiving: false,\n    isRunningToolCalls: true,\n    error: undefined,\n    exhaustedRetries: false\n  });\n}), on(apiActions.generateMessageError, (state, action) => {\n  return Object.assign(Object.assign({}, state), {\n    isReceiving: false,\n    isSending: false,\n    error: action.payload\n  });\n}), on(internalActions.runToolCallsSuccess, state => {\n  return Object.assign(Object.assign({}, state), {\n    isRunningToolCalls: false,\n    isSending: true\n  });\n}), on(internalActions.runToolCallsError, (state, action) => {\n  return Object.assign(Object.assign({}, state), {\n    isRunningToolCalls: false,\n    error: action.payload\n  });\n}), on(apiActions.generateMessageExhaustedRetries, state => {\n  return Object.assign(Object.assign({}, state), {\n    exhaustedRetries: true\n  });\n}), on(devActions.stopMessageGeneration, state => {\n  return Object.assign(Object.assign({}, state), {\n    isReceiving: false,\n    isSending: false,\n    isRunningToolCalls: false,\n    error: undefined,\n    exhaustedRetries: false\n  });\n}), on(internalActions.skippedToolCalls, state => {\n  return Object.assign(Object.assign({}, state), {\n    isRunningToolCalls: false,\n    isSending: false,\n    isReceiving: false\n  });\n}));\nconst selectIsReceiving$1 = state => state.isReceiving;\nconst selectIsSending$1 = state => state.isSending;\nconst selectIsRunningToolCalls$1 = state => state.isRunningToolCalls;\nconst selectError$1 = state => state.error;\nconst selectExhaustedRetries$1 = state => state.exhaustedRetries;\n\nconst initialState$2 = {\n  message: null,\n  toolCalls: []\n};\nconst reducer$2 = createReducer(initialState$2, on(apiActions.generateMessageChunk, (state, action) => {\n  var _a, _b, _c, _d, _e;\n  const apiMessage = action.payload;\n  const [internalMessage] = toInternalMessagesFromApi({\n    role: (_a = apiMessage.role) !== null && _a !== void 0 ? _a : 'assistant',\n    content: (_b = apiMessage.content) !== null && _b !== void 0 ? _b : '',\n    toolCalls: (_c = apiMessage.toolCalls) !== null && _c !== void 0 ? _c : []\n  });\n  if (!internalMessage) {\n    return state;\n  }\n  if (internalMessage.role !== 'assistant') {\n    return state;\n  }\n  return Object.assign(Object.assign({}, state), {\n    message: internalMessage,\n    toolCalls: (_e = (_d = action.payload.toolCalls) === null || _d === void 0 ? void 0 : _d.flatMap(toInternalToolCallsFromApi)) !== null && _e !== void 0 ? _e : []\n  });\n}), on(apiActions.generateMessageSuccess, state => {\n  return Object.assign(Object.assign({}, state), {\n    message: null\n  });\n}), on(devActions.stopMessageGeneration, (state, action) => {\n  return Object.assign(Object.assign({}, state), {\n    message: action.payload ? null : state.message,\n    toolCalls: []\n  });\n}));\nconst selectRawStreamingMessage = state => state.message;\nconst selectRawStreamingToolCalls = state => state.toolCalls;\nconst selectStreamingMessage$1 = select(selectRawStreamingMessage, selectRawStreamingToolCalls, (message, toolCalls) => {\n  var _a, _b;\n  if (!message) {\n    return null;\n  }\n  return {\n    role: (_a = message.role) !== null && _a !== void 0 ? _a : 'assistant',\n    content: (_b = message.content) !== null && _b !== void 0 ? _b : '',\n    toolCallIds: toolCalls.map(toolCall => toolCall.id)\n  };\n});\nconst selectStreamingToolCallEntities$1 = select(selectRawStreamingToolCalls, toolCalls => {\n  return toolCalls.reduce((acc, toolCall) => {\n    acc[toolCall.id] = toolCall;\n    return acc;\n  }, {});\n});\n\nconst adapter = createEntityAdapter({\n  selectId: toolCall => toolCall.id\n});\nconst initialState$1 = {\n  ids: [],\n  entities: {}\n};\nconst reducer$1 = createReducer(initialState$1, on(devActions.init, devActions.setMessages, (state, action) => {\n  const messages = action.payload.messages;\n  if (!messages) {\n    return initialState$1;\n  }\n  return adapter.addMany(initialState$1, toInternalToolCallsFromView(messages));\n}), on(apiActions.generateMessageSuccess, (state, action) => {\n  const message = action.payload;\n  if (!message.toolCalls) {\n    return state;\n  }\n  return adapter.addMany(state, message.toolCalls.flatMap(toInternalToolCallsFromApi));\n}), on(internalActions.runToolCallsSuccess, (state, action) => {\n  const {\n    toolMessages\n  } = action.payload;\n  const changes = toolMessages.map(toolMessage => ({\n    id: toolMessage.toolCallId,\n    updates: {\n      result: toolMessage.content,\n      status: 'done'\n    }\n  }));\n  return adapter.updateMany(state, changes);\n}));\nconst selectToolCallIds = state => state.ids;\nconst selectToolCallEntities$1 = state => state.entities;\nconst selectToolCalls$1 = select(selectToolCallIds, selectToolCallEntities$1, (ids, entities) => ids.map(id => entities[id]));\nconst selectPendingToolCalls$1 = select(selectToolCalls$1, toolCalls => {\n  return toolCalls.filter(toolCall => toolCall.status === 'pending');\n});\n\nconst initialState = {\n  names: [],\n  entities: {}\n};\nconst reducer = createReducer(initialState, on(devActions.init, devActions.updateOptions, (state, action) => {\n  const tools = action.payload.tools;\n  if (!tools || tools.length === 0) {\n    return state;\n  }\n  return Object.assign(Object.assign({}, state), {\n    names: tools.map(tool => tool.name),\n    entities: tools.reduce((acc, tool) => {\n      acc[tool.name] = tool;\n      return acc;\n    }, {})\n  });\n}));\nconst selectToolNames = state => state.names;\nconst selectToolEntities$1 = state => state.entities;\nconst selectTools$1 = select(selectToolNames, selectToolEntities$1, (names, entities) => names.map(name => entities[name]));\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst reducers = {\n  config: reducer$5,\n  messages: reducer$4,\n  status: reducer$3,\n  streamingMessage: reducer$2,\n  toolCalls: reducer$1,\n  tools: reducer\n};\n/**\n * Messages\n */\nconst selectMessagesState = state => state.messages;\nconst selectMessages = select(selectMessagesState, selectMessages$1);\n/**\n * Status\n */\nconst selectStatusState = state => state.status;\nconst selectIsReceiving = select(selectStatusState, selectIsReceiving$1);\nconst selectIsSending = select(selectStatusState, selectIsSending$1);\nconst selectIsRunningToolCalls = select(selectStatusState, selectIsRunningToolCalls$1);\nconst selectError = select(selectStatusState, selectError$1);\nconst selectExhaustedRetries = select(selectStatusState, selectExhaustedRetries$1);\n/**\n * Streaming Message\n */\nconst selectStreamingMessageState = state => state.streamingMessage;\nconst selectStreamingMessage = select(selectStreamingMessageState, selectStreamingMessage$1);\nconst selectStreamingToolCallEntities = select(selectStreamingMessageState, selectStreamingToolCallEntities$1);\n/**\n * Tools\n */\nconst selectToolsState = state => state.tools;\nconst selectTools = select(selectToolsState, selectTools$1);\nconst selectToolEntities = select(selectToolsState, selectToolEntities$1);\n/**\n * Tool Calls\n */\nconst selectToolCallsState = state => state.toolCalls;\nconst selectToolCalls = select(selectToolCallsState, selectToolCalls$1);\nconst selectToolCallEntities = select(selectToolCallsState, selectToolCallEntities$1);\nconst selectPendingToolCalls = select(selectToolCallsState, selectPendingToolCalls$1);\n/**\n * Config\n */\nconst selectConfigState = state => state.config;\nconst selectApiUrl = select(selectConfigState, selectApiUrl$1);\nconst selectMiddleware = select(selectConfigState, selectMiddleware$1);\nconst selectModel = select(selectConfigState, selectModel$1);\nconst selectSystem = select(selectConfigState, selectSystem$1);\nconst selectDebounce = select(selectConfigState, selectDebounce$1);\nconst selectRetries = select(selectConfigState, selectRetries$1);\nconst selectResponseSchema = select(selectConfigState, selectResponseSchema$1);\nconst selectEmulateStructuredOutput = select(selectConfigState, selectEmulateStructuredOutput$1);\n/**\n * Top-level selectors\n */\nconst selectNonStreamingViewMessages = select(selectMessages, selectToolCallEntities, selectTools, selectResponseSchema, (messages, toolCalls, tools, responseSchema) => {\n  return messages.flatMap(message => toViewMessagesFromInternal(message, toolCalls, tools, responseSchema));\n});\nconst selectStreamingViewMessages = select(selectStreamingMessage, selectStreamingToolCallEntities, selectTools, selectResponseSchema, (streamingMessage, streamingToolCalls, tools, responseSchema) => {\n  return (streamingMessage ? [streamingMessage] : []).flatMap(message => toViewMessagesFromInternal(message, streamingToolCalls, tools, responseSchema));\n});\nconst selectViewMessages = select(selectNonStreamingViewMessages, selectStreamingViewMessages, (nonStreamingMessages, streamingMessages) => {\n  return [...nonStreamingMessages, ...streamingMessages];\n});\nconst selectLastAssistantMessage = select(selectViewMessages, messages => {\n  return messages.findLast(message => message.role === 'assistant');\n});\nconst selectApiMessages = select(selectMessages, selectToolCalls, (messages, toolCalls) => {\n  return messages.flatMap(message => toApiMessagesFromInternal(message, toolCalls));\n});\nconst selectShouldGenerateMessage = select(selectApiMessages, messages => {\n  const lastMessage = messages[messages.length - 1];\n  if (!lastMessage) {\n    return false;\n  }\n  return lastMessage.role === 'user' || lastMessage.role === 'tool';\n});\nconst selectApiTools = select(selectTools, selectResponseSchema, selectEmulateStructuredOutput, (tools, responseSchema, emulateStructuredOutput) => {\n  return toApiToolsFromInternal(tools, emulateStructuredOutput && !!responseSchema, responseSchema !== null && responseSchema !== void 0 ? responseSchema : nullish());\n});\nconst selectIsLoading = select(selectIsSending, selectIsReceiving, selectIsRunningToolCalls, (isSending, isReceiving, isRunningToolCalls) => isSending || isReceiving || isRunningToolCalls);\n\nconst generateMessage = createEffect(store => {\n  const effectAbortController = new AbortController();\n  // This controller is used to cancel the current message generation\n  // when a new message is sent or the user stops the generation.\n  let cancelAbortController = new AbortController();\n  store.when(internalActions.sizzle, devActions.setMessages, devActions.sendMessage, devActions.resendMessages, internalActions.runToolCallsSuccess, switchAsync(switchSignal => __awaiter(void 0, void 0, void 0, function* () {\n    var _a, e_1, _b, _c;\n    const apiUrl = store.read(selectApiUrl);\n    const middleware = store.read(selectMiddleware);\n    const model = store.read(selectModel);\n    const responseSchema = store.read(selectResponseSchema);\n    const messages = store.read(selectApiMessages);\n    const shouldGenerateMessage = store.read(selectShouldGenerateMessage);\n    const debounce = store.read(selectDebounce);\n    const retries = store.read(selectRetries);\n    const tools = store.read(selectApiTools);\n    const system = store.read(selectSystem);\n    const emulateStructuredOutput = store.read(selectEmulateStructuredOutput);\n    if (!shouldGenerateMessage) {\n      return;\n    }\n    const params = {\n      model,\n      system,\n      messages,\n      tools,\n      toolChoice: emulateStructuredOutput && responseSchema ? 'required' : undefined,\n      responseFormat: !emulateStructuredOutput && responseSchema ? toJsonSchema(responseSchema) : undefined\n    };\n    yield sleep(debounce, switchSignal);\n    let attempt = 0;\n    do {\n      attempt++;\n      if (effectAbortController.signal.aborted || switchSignal.aborted || cancelAbortController.signal.aborted) {\n        // we need to reset the cancelAbortController for the next messsage\n        if (cancelAbortController.signal.aborted) {\n          cancelAbortController = new AbortController();\n        }\n        return;\n      }\n      let requestInit = {\n        method: 'POST',\n        body: JSON.stringify(params),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: switchSignal\n      };\n      if (middleware && middleware.length) {\n        for (const m of middleware) {\n          requestInit = yield m(requestInit);\n        }\n      }\n      try {\n        const response = yield fetch(apiUrl, requestInit);\n        if (!response.ok) {\n          store.dispatch(apiActions.generateMessageError(new Error(`HTTP error! Status: ${response.status}`)));\n          continue;\n        }\n        if (!response.body) {\n          store.dispatch(apiActions.generateMessageError(new Error(`Response body is null`)));\n          continue;\n        }\n        // This catches an edge case where a cancellation was requested\n        // after we had already kicked off the initial request, but\n        // before we started decoding frames.\n        if (cancelAbortController.signal.aborted) {\n          // If the cancelAbortController is aborted, we need to reset it for the next message\n          cancelAbortController = new AbortController();\n          return;\n        }\n        store.dispatch(apiActions.generateMessageStart());\n        let message = null;\n        try {\n          for (var _d = true, _e = (e_1 = void 0, __asyncValues(decodeFrames(response.body, {\n              signal: AbortSignal.any([cancelAbortController.signal, effectAbortController.signal])\n            }))), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n            _c = _f.value;\n            _d = false;\n            const frame = _c;\n            switch (frame.type) {\n              case 'chunk':\n                {\n                  message = _updateMessagesWithDelta(message, frame.chunk);\n                  if (message) {\n                    store.dispatch(apiActions.generateMessageChunk(message));\n                  }\n                  break;\n                }\n              case 'error':\n                {\n                  // Assumption: a 'finish' will follow the 'error', but we know we need to retry\n                  // as soon as we see the error.  Therefore, throw an exception to break out\n                  // of the for loop.\n                  throw new Error(frame.error);\n                  break;\n                }\n              case 'finish':\n                {\n                  if (message) {\n                    store.dispatch(apiActions.generateMessageSuccess(message));\n                  } else {\n                    store.dispatch(apiActions.generateMessageError(new Error('No message was generated')));\n                  }\n                  break;\n                }\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } catch (e) {\n        if (e instanceof Error) {\n          store.dispatch(apiActions.generateMessageError(e));\n        }\n        continue;\n      } finally {\n        // Reset the cancelAbortController for the next message\n        if (cancelAbortController.signal.aborted) {\n          cancelAbortController = new AbortController();\n        }\n      }\n      break;\n    } while (retries > 0 && attempt < retries + 1);\n    // Did we exhaust our retries?\n    if (retries > 0 && attempt > retries) {\n      store.dispatch(apiActions.generateMessageExhaustedRetries());\n    }\n  }), effectAbortController.signal));\n  store.when(devActions.stopMessageGeneration, () => {\n    cancelAbortController.abort();\n  });\n  return () => {\n    effectAbortController.abort();\n    cancelAbortController.abort();\n  };\n});\n/**\n * Merges existing and new tool calls.\n *\n * @param existingCalls - The existing tool calls.\n * @param newCalls - The new tool calls to merge.\n * @returns The merged array of tool calls.\n */\nfunction mergeToolCalls(existingCalls = [], newCalls = []) {\n  const merged = [...existingCalls];\n  newCalls.forEach(newCall => {\n    var _a, _b;\n    const index = merged.findIndex(call => call.index === newCall.index);\n    if (index !== -1) {\n      const existing = merged[index];\n      merged[index] = Object.assign(Object.assign({}, existing), {\n        function: Object.assign(Object.assign({}, existing.function), {\n          arguments: existing.function.arguments + ((_b = (_a = newCall.function) === null || _a === void 0 ? void 0 : _a.arguments) !== null && _b !== void 0 ? _b : '')\n        })\n      });\n    } else {\n      merged.push(newCall);\n    }\n  });\n  return merged;\n}\n/**\n * Updates the messages array with an incoming assistant delta.\n *\n * @param messages - The current messages array.\n * @param delta - The incoming message delta.\n * @returns The updated messages array.\n */\nfunction _updateMessagesWithDelta(message, delta) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  if (message && message.role === 'assistant' && delta.choices.length) {\n    const updatedToolCalls = mergeToolCalls(message.toolCalls, (_a = delta.choices[0].delta.toolCalls) !== null && _a !== void 0 ? _a : []);\n    const updatedMessage = Object.assign(Object.assign({}, message), {\n      content: ((_b = message.content) !== null && _b !== void 0 ? _b : '') + ((_c = delta.choices[0].delta.content) !== null && _c !== void 0 ? _c : ''),\n      toolCalls: updatedToolCalls\n    });\n    return updatedMessage;\n  } else if (delta.choices.length && ((_e = (_d = delta.choices[0]) === null || _d === void 0 ? void 0 : _d.delta) === null || _e === void 0 ? void 0 : _e.role) === 'assistant') {\n    return {\n      role: 'assistant',\n      content: (_f = delta.choices[0].delta.content) !== null && _f !== void 0 ? _f : '',\n      toolCalls: mergeToolCalls([], (_g = delta.choices[0].delta.toolCalls) !== null && _g !== void 0 ? _g : [])\n    };\n  }\n  return message;\n}\n\nconst runTools = createEffect(store => {\n  const abortController = new AbortController();\n  store.when(apiActions.generateMessageSuccess, () => __awaiter(void 0, void 0, void 0, function* () {\n    const toolCalls = store.read(selectPendingToolCalls);\n    const toolEntities = store.read(selectToolEntities);\n    if (toolCalls.length === 0) {\n      yield Promise.resolve();\n      store.dispatch(internalActions.skippedToolCalls());\n      return;\n    }\n    const toolCallResults = toolCalls.map(toolCall => {\n      const tool = toolEntities[toolCall.name];\n      if (!tool) {\n        return Promise.reject(new Error(`Tool ${toolCall.name} not found`));\n      }\n      try {\n        const args = isHashbrownType(tool.schema) ? tool.schema.parseJsonSchema(toolCall.arguments) : JSON.parse(toolCall.arguments);\n        return Promise.resolve(tool.handler(args, abortController.signal));\n      } catch (error) {\n        // We may have received unnecessarily escaped input, so try\n        // again with JSON.parse\n        if (error instanceof Error && error.message.includes('Expected an object at')) {\n          try {\n            const args = isHashbrownType(tool.schema) ? tool.schema.parseJsonSchema(JSON.parse(toolCall.arguments)) : JSON.parse(toolCall.arguments);\n            return Promise.resolve(tool.handler(args, abortController.signal));\n          } catch (error) {\n            return Promise.reject(error);\n          }\n        }\n        return Promise.reject(error);\n      }\n    });\n    const results = yield Promise.allSettled(toolCallResults);\n    const toolMessages = toolCalls.map((toolCall, index) => ({\n      role: 'tool',\n      content: results[index],\n      toolCallId: toolCall.id,\n      toolName: toolCall.name\n    }));\n    store.dispatch(internalActions.runToolCallsSuccess({\n      toolMessages\n    }));\n  }));\n  return () => {\n    abortController.abort();\n  };\n});\n\nvar effects = [generateMessage, runTools];\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Core entry point for the Hashbrown framework.\n * Provides state management and messaging utilities for integrating LLM-based chat interactions into frontend applications.\n */\n/**\n * @public\n */\nfunction fryHashbrown(init) {\n  var _a;\n  const hasIllegalOutputTool = (_a = init.tools) === null || _a === void 0 ? void 0 : _a.some(tool => tool.name === 'output');\n  if (hasIllegalOutputTool) {\n    throw new Error('The \"output\" tool name is a reserved tool name and cannot be used.');\n  }\n  const state = createStore({\n    debugName: init.debugName,\n    reducers,\n    effects,\n    projectStateForDevtools: state => ({\n      messages: selectViewMessages(state),\n      isReceiving: selectIsReceiving(state),\n      isSending: selectIsSending(state),\n      isRunningToolCalls: selectIsRunningToolCalls(state),\n      error: selectError(state),\n      ɵɵinternal: state\n    })\n  });\n  state.dispatch(devActions.init({\n    apiUrl: init.apiUrl,\n    model: init.model,\n    system: init.system,\n    messages: init.messages,\n    tools: init.tools,\n    responseSchema: init.responseSchema,\n    middleware: init.middleware,\n    emulateStructuredOutput: init.emulateStructuredOutput,\n    debounce: init.debounce,\n    retries: init.retries\n  }));\n  function setMessages(messages) {\n    state.dispatch(devActions.setMessages({\n      messages: messages\n    }));\n  }\n  function sendMessage(message) {\n    state.dispatch(devActions.sendMessage({\n      message: message\n    }));\n  }\n  function resendMessages() {\n    state.dispatch(devActions.resendMessages());\n  }\n  function updateOptions(options) {\n    state.dispatch(devActions.updateOptions(options));\n  }\n  function sizzle() {\n    const abortController = new AbortController();\n    let effectCleanupFn;\n    Promise.resolve().then(() => {\n      if (abortController.signal.aborted) {\n        return;\n      }\n      effectCleanupFn = state.runEffects();\n      state.dispatch(internalActions.sizzle());\n    });\n    return () => {\n      abortController.abort('Initialization aborted');\n      effectCleanupFn === null || effectCleanupFn === void 0 ? void 0 : effectCleanupFn();\n    };\n  }\n  function stop(clearStreamingMessage = false) {\n    const isLoading = state.read(selectIsLoading);\n    if (!isLoading) {\n      throw new Error('Cannot stop streaming messages when not streaming.');\n    }\n    state.dispatch(devActions.stopMessageGeneration(clearStreamingMessage));\n  }\n  return {\n    setMessages,\n    sendMessage,\n    resendMessages,\n    updateOptions,\n    stop,\n    sizzle,\n    messages: state.createSignal(selectViewMessages),\n    error: state.createSignal(selectError),\n    isReceiving: state.createSignal(selectIsReceiving),\n    isSending: state.createSignal(selectIsSending),\n    isRunningToolCalls: state.createSignal(selectIsRunningToolCalls),\n    isLoading: state.createSignal(selectIsLoading),\n    exhaustedRetries: state.createSignal(selectExhaustedRetries),\n    lastAssistantMessage: state.createSignal(selectLastAssistantMessage)\n  };\n}\n\nconst PLACEHOLDER_PREFIX = '__HBX_';\n/**\n * Weave template expressions into a single string by inserting stable placeholders\n * (e.g., __HBX_0__) at expression positions. Returns the concatenated text and\n * the ordered list of placeholder tokens.\n */\nfunction weavePlaceholders(strings, exprs) {\n  const tokens = strings.map((chunk, i) => i < exprs.length ? `${chunk}${PLACEHOLDER_PREFIX}${i}__` : chunk).join('');\n  const placeholders = exprs.map((_, i) => `${PLACEHOLDER_PREFIX}${i}__`);\n  return {\n    text: tokens,\n    placeholders\n  };\n}\n/**\n * Functional scan for <ui>...</ui> blocks. Produces an array of UiBlock descriptors\n * including absolute offsets and inner source text.\n */\nfunction findUiBlocks(text) {\n  const next = (from, acc) => {\n    const startTag = text.indexOf('<ui>', from);\n    if (startTag === -1) return acc;\n    const endTag = text.indexOf('</ui>', startTag);\n    if (endTag === -1) return acc;\n    const innerStart = startTag + '<ui>'.length;\n    const innerEnd = endTag;\n    const blockText = text.slice(innerStart, innerEnd);\n    const block = {\n      start: startTag,\n      end: endTag + '</ui>'.length,\n      innerStart,\n      innerEnd,\n      source: blockText,\n      ast: []\n    };\n    return next(endTag + 5, acc.concat(block));\n  };\n  return next(0, []);\n}\n/** Whitespace check helper. */\nconst isWhitespace = ch => /\\s/.test(ch);\n/**\n * Parse a single <ui> inner source into UiAst nodes. Pure function: returns\n * the nodes and any diagnostics gathered while parsing.\n */\nfunction parseUi(source, baseOffset) {\n  let i = 0;\n  const diags = [];\n  const diag = d => {\n    diags.push(Object.assign(Object.assign({}, d), {\n      line: 0,\n      column: 0\n    }));\n  };\n  const skipWs = () => {\n    var _a;\n    while (i < source.length && isWhitespace((_a = source[i]) !== null && _a !== void 0 ? _a : '')) i++;\n  };\n  const parseText = () => {\n    const start = i;\n    let text = '';\n    while (i < source.length && source[i] !== '<') {\n      text += source[i];\n      i++;\n    }\n    return text.length === 0 ? null : {\n      kind: 'text',\n      text,\n      start: baseOffset + start,\n      end: baseOffset + i\n    };\n  };\n  const parseAttrs = () => {\n    var _a;\n    let attrs = {};\n    while (i < source.length) {\n      skipWs();\n      const ch = source[i];\n      if (ch === '/' || ch === '>' || ch == null) break;\n      const nameStart = i;\n      let name = '';\n      while (i < source.length) {\n        const c = (_a = source[i]) !== null && _a !== void 0 ? _a : '';\n        if (/[-A-Za-z0-9_:$]/.test(c)) {\n          name += c;\n          i++;\n        } else {\n          break;\n        }\n      }\n      skipWs();\n      const readUnquoted = () => {\n        var _a;\n        const vs = i;\n        while (i < source.length && /[^\\s/>]/.test((_a = source[i]) !== null && _a !== void 0 ? _a : '')) i++;\n        return {\n          value: source.slice(vs, i),\n          start: baseOffset + vs,\n          end: baseOffset + i\n        };\n      };\n      const readQuoted = q => {\n        i++;\n        const vs = i;\n        while (i < source.length && source[i] !== q) i++;\n        const segment = source.slice(vs, i);\n        const span = {\n          value: segment,\n          start: baseOffset + vs,\n          end: baseOffset + i\n        };\n        if (source[i] === q) i++;\n        return span;\n      };\n      const attrSpan = source[i] === '=' ? (() => {\n        i++;\n        skipWs();\n        const q = source[i];\n        return q === '\"' || q === \"'\" ? readQuoted(q) : readUnquoted();\n      })() : {\n        value: 'true',\n        start: baseOffset + nameStart,\n        end: baseOffset + i\n      };\n      if (Object.prototype.hasOwnProperty.call(attrs, name)) {\n        diag({\n          code: 'E1401',\n          severity: 'error',\n          message: `Duplicate attribute \"${name}\"`,\n          start: baseOffset + nameStart,\n          end: baseOffset + i,\n          snippet: source.slice(nameStart, i)\n        });\n      }\n      attrs = Object.assign(Object.assign({}, attrs), {\n        [name]: attrSpan\n      });\n      skipWs();\n    }\n    return attrs;\n  };\n  const parseElement = () => {\n    var _a;\n    if (source[i] !== '<') return null;\n    const start = i;\n    i++;\n    if (source[i] === '/') return null;\n    let tag = '';\n    while (i < source.length && /[-A-Za-z0-9]/.test((_a = source[i]) !== null && _a !== void 0 ? _a : '')) {\n      tag += source[i];\n      i++;\n    }\n    skipWs();\n    const attrs = parseAttrs();\n    const selfClosing = source[i] === '/' ? (i++, true) : false;\n    if (source[i] === '>') i++;\n    const parseChildren = acc => {\n      var _a;\n      if (i >= source.length) return acc;\n      if (source[i] === '<' && source[i + 1] === '/') {\n        i += 2;\n        while (i < source.length && /[-A-Za-z0-9]/.test((_a = source[i]) !== null && _a !== void 0 ? _a : '')) i++;\n        while (i < source.length && source[i] !== '>') i++;\n        if (source[i] === '>') i++;\n        return acc;\n      }\n      const child = source[i] === '<' ? parseElement() : parseText();\n      return child == null ? acc : parseChildren(acc.concat(child));\n    };\n    const children = selfClosing ? [] : parseChildren([]);\n    const end = baseOffset + i;\n    return {\n      kind: 'element',\n      tag,\n      start: baseOffset + start,\n      end,\n      attrs,\n      children,\n      selfClosing\n    };\n  };\n  const parseNodes = acc => {\n    skipWs();\n    if (i >= source.length) return acc;\n    const node = source[i] === '<' ? parseElement() : parseText();\n    return node == null ? acc : parseNodes(acc.concat(node));\n  };\n  const nodes = parseNodes([]);\n  return {\n    nodes,\n    diagnostics: diags\n  };\n}\n/** Map absolute offset to 1-based {line, column}. */\nfunction absoluteToLineCol(text, abs) {\n  var _a;\n  const slice = text.slice(0, Math.min(abs, text.length));\n  const lines = slice.split('\\n');\n  const line = lines.length;\n  const column = ((_a = lines[lines.length - 1]) !== null && _a !== void 0 ? _a : '').length + 1;\n  return {\n    line,\n    column\n  };\n}\n/** Plain-object check that excludes arrays and class instances. */\nfunction isPlainObject(v) {\n  if (Object.prototype.toString.call(v) !== '[object Object]') return false;\n  const proto = Object.getPrototypeOf(v);\n  return proto === Object.prototype || proto === null;\n}\n/** Ensure values are JSON-serializable according to policy. */\nfunction ensureSerializable(value) {\n  if (value == null || typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    return true;\n  }\n  if (typeof value === 'bigint') return 'BigInt';\n  if (typeof value === 'function') return 'function';\n  if (typeof value === 'symbol') return 'symbol';\n  if (value instanceof Date) return 'Date';\n  if (value instanceof Map) return 'Map';\n  if (value instanceof Set) return 'Set';\n  if (Array.isArray(value)) {\n    const firstBad = value.map(ensureSerializable).find(r => r !== true);\n    return firstBad !== null && firstBad !== void 0 ? firstBad : true;\n  }\n  if (isPlainObject(value)) {\n    try {\n      JSON.stringify(value);\n      return true;\n    } catch (_a) {\n      return 'circular';\n    }\n  }\n  return 'class-instance';\n}\n/** Lower a UiAst element into an HBNode, collecting diagnostics functionally. */\nfunction lowerToHB(node, exprsByToken) {\n  if (node.kind === 'text') return {\n    hb: null,\n    diagnostics: []\n  };\n  const foldAttrs = entries => {\n    return entries.reduce((acc, [k, span]) => {\n      const raw = span.value;\n      if (raw.startsWith(PLACEHOLDER_PREFIX)) {\n        const val = exprsByToken.get(raw);\n        const ser = ensureSerializable(val);\n        return ser !== true ? {\n          props: acc.props,\n          diagnostics: acc.diagnostics.concat({\n            code: 'E1301',\n            severity: 'error',\n            message: `${raw} is not JSON-serializable (${ser}).`,\n            start: span.start,\n            end: span.end,\n            line: 0,\n            column: 0,\n            snippet: raw\n          })\n        } : {\n          props: Object.assign(Object.assign({}, acc.props), {\n            [k]: val\n          }),\n          diagnostics: acc.diagnostics\n        };\n      }\n      const value = raw === 'true' ? true : raw === 'false' ? false : raw === 'null' ? null : /^-?\\d+(?:\\.\\d+)?$/.test(raw) ? Number(raw) : raw;\n      return {\n        props: Object.assign(Object.assign({}, acc.props), {\n          [k]: value\n        }),\n        diagnostics: acc.diagnostics\n      };\n    }, {\n      props: {},\n      diagnostics: []\n    });\n  };\n  const {\n    props,\n    diagnostics: attrDiags\n  } = foldAttrs(Object.entries(node.attrs));\n  const childrenLowered = node.children.map(c => lowerToHB(c, exprsByToken));\n  const childDiags = childrenLowered.flatMap(r => r.diagnostics);\n  const children = childrenLowered.map(r => r.hb).filter(h => h != null);\n  const hb = children.length ? {\n    $tag: node.tag,\n    $children: children,\n    $props: props\n  } : {\n    $tag: node.tag,\n    $children: [],\n    $props: props\n  };\n  return {\n    hb,\n    diagnostics: attrDiags.concat(childDiags)\n  };\n}\n/**\n * Lower a UiAst element into a flexible HB node that can represent text children\n * (when component policy is 'text'). This variant requires access to the component\n * registry (by name or selector) to know each component's children policy.\n */\nfunction lowerWithPolicy(node, exprsByToken, byName) {\n  if (node.kind === 'text') return null;\n  const foldAttrs = entries => {\n    return entries.reduce((acc, [k, span]) => {\n      const raw = span.value;\n      if (raw.startsWith(PLACEHOLDER_PREFIX)) {\n        const val = exprsByToken.get(raw);\n        return Object.assign(Object.assign({}, acc), {\n          [k]: val\n        });\n      }\n      const value = raw === 'true' ? true : raw === 'false' ? false : raw === 'null' ? null : /^-?\\d+(?:\\.\\d+)?$/.test(raw) ? Number(raw) : raw;\n      return Object.assign(Object.assign({}, acc), {\n        [k]: value\n      });\n    }, {});\n  };\n  const props = foldAttrs(Object.entries(node.attrs));\n  const comp = byName.get(node.tag);\n  const policy = comp ? comp.children : undefined;\n  if (policy === 'text') {\n    // Concatenate only text children (preserve placeholders) as content\n    const content = node.children.map(c => c.kind === 'text' ? c.text : '').join('');\n    const elementChildren = node.children.map(c => c.kind === 'element' ? lowerWithPolicy(c, exprsByToken, byName) : null).filter(h => h != null);\n    // Include a meta property for validation; stripped out for injection later\n    return {\n      $tag: node.tag,\n      $children: content,\n      $elementChildren: elementChildren,\n      $props: props\n    };\n  }\n  // Default behavior: lower element children only (ignore text nodes)\n  const loweredChildren = node.children.map(c => c.kind === 'element' ? lowerWithPolicy(c, exprsByToken, byName) : null).filter(h => h != null);\n  return {\n    $tag: node.tag,\n    $children: loweredChildren,\n    $props: props\n  };\n}\n/** Compute Levenshtein distance for nearest-name suggestions. */\nfunction levenshtein(a, b) {\n  const dp = Array.from({\n    length: a.length + 1\n  }, (_, i) => Array.from({\n    length: b.length + 1\n  }, (_, j) => i === 0 ? j : j === 0 ? i : 0));\n  for (let i = 1; i <= a.length; i++) {\n    for (let j = 1; j <= b.length; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);\n    }\n  }\n  return dp[a.length][b.length];\n}\n/** Validate examples against component registry; returns diagnostics (functional). */\nfunction validateExamples(examples, blocks, components, toLineCol) {\n  const byName = new Map();\n  const allNames = [];\n  components.forEach(c => {\n    if (c && typeof c.name === 'string') {\n      byName.set(c.name, c);\n      allNames.push(c.name);\n    }\n    // Support Angular-style selector aliases\n    if (c && typeof c.selector === 'string') {\n      const sel = c.selector;\n      byName.set(sel, c);\n      allNames.push(sel);\n    }\n  });\n  const visit = (node, blk) => {\n    const comp = byName.get(node.$tag);\n    if (!comp) {\n      const suggestions = allNames.map(n => ({\n        n,\n        d: levenshtein(n.toLowerCase(), node.$tag.toLowerCase())\n      })).sort((a, b) => a.d - b.d).slice(0, 1).map(x => x.n);\n      return [Object.assign(Object.assign({\n        code: 'E1001',\n        severity: 'error',\n        message: `<${node.$tag}> not found.` + (suggestions.length ? ` Did you mean <${suggestions[0]}>?` : ''),\n        start: blk.innerStart,\n        end: blk.innerEnd\n      }, toLineCol(blk.innerStart)), {\n        snippet: blk.source\n      })];\n    }\n    const diags = [];\n    if (comp.props && typeof comp.props === 'object') {\n      const definedProps = new Set(Object.keys(comp.props));\n      const nodeProps = node.$props || {};\n      definedProps.forEach(key => {\n        if (!(key in nodeProps)) {\n          diags.push(Object.assign(Object.assign({\n            code: 'E1102',\n            severity: 'error',\n            message: `<${node.$tag}> missing required prop \"${key}\".`,\n            start: blk.innerStart,\n            end: blk.innerEnd\n          }, toLineCol(blk.innerStart)), {\n            snippet: blk.source\n          }));\n        }\n      });\n      Object.entries(nodeProps).forEach(([k, v]) => {\n        var _a;\n        if (!definedProps.has(k)) {\n          diags.push(Object.assign(Object.assign({\n            code: 'W2001',\n            severity: 'warning',\n            message: `Prop \"${k}\" is not defined on <${node.$tag}>.`,\n            start: blk.innerStart,\n            end: blk.innerEnd\n          }, toLineCol(blk.innerStart)), {\n            snippet: blk.source\n          }));\n        } else {\n          try {\n            const schema = (_a = comp.props) === null || _a === void 0 ? void 0 : _a[k];\n            if (schema && typeof schema.validate === 'function') {\n              schema.validate(v);\n            }\n          } catch (e) {\n            diags.push(Object.assign(Object.assign({\n              code: 'E1203',\n              severity: 'error',\n              message: `Prop \"${k}\" on <${node.$tag}> failed schema validation: \\n\\n${e.message}`,\n              start: blk.innerStart,\n              end: blk.innerEnd\n            }, toLineCol(blk.innerStart)), {\n              snippet: blk.source\n            }));\n          }\n        }\n      });\n    }\n    const policy = comp.children;\n    const arrayChildren = Array.isArray(node.$children) ? node.$children : [];\n    if (policy === 'text') {\n      // Text-only components: any element child is not allowed\n      const hasElementChildren = Array.isArray(node.$elementChildren) ? node.$elementChildren.length > 0 : arrayChildren.length > 0;\n      if (hasElementChildren) {\n        diags.push(Object.assign(Object.assign({\n          code: 'W2101',\n          severity: 'warning',\n          message: `<${node.$tag}> expects text children, element found.`,\n          start: blk.innerStart,\n          end: blk.innerEnd\n        }, toLineCol(blk.innerStart)), {\n          snippet: blk.source\n        }));\n      }\n      // no recursion for text children\n      return diags;\n    }\n    if (policy === false && arrayChildren.length) {\n      diags.push(Object.assign(Object.assign({\n        code: 'W2101',\n        severity: 'warning',\n        message: `<${node.$tag}> does not accept children.`,\n        start: blk.innerStart,\n        end: blk.innerEnd\n      }, toLineCol(blk.innerStart)), {\n        snippet: blk.source\n      }));\n    } else if (Array.isArray(policy) && arrayChildren.length) {\n      const allowed = new Set(policy.map(p => p.name));\n      arrayChildren.forEach(ch => {\n        if (!allowed.has(ch.$tag)) {\n          diags.push(Object.assign(Object.assign({\n            code: 'W2101',\n            severity: 'warning',\n            message: `<${node.$tag}> children restricted; \"${ch.$tag}\" not allowed.`,\n            start: blk.innerStart,\n            end: blk.innerEnd\n          }, toLineCol(blk.innerStart)), {\n            snippet: blk.source\n          }));\n        }\n      });\n    }\n    const childDiags = arrayChildren.flatMap(c => visit(c, blk));\n    return diags.concat(childDiags);\n  };\n  return examples.flatMap((tree, idx) => tree.flatMap(n => blocks[idx] ? visit(n, blocks[idx]) : []));\n}\n/** Replace <ui> blocks with inline JSON fences or placeholders. */\nfunction injectExamples(text, blocks, examples, mode) {\n  if (mode === 'none') return text;\n  const parts = blocks.reduce((acc, blk, i) => {\n    const pre = text.slice(acc.cursor, blk.start);\n    const mid = mode === 'inline' ? `\\n\\n${JSON.stringify(examples[i], null, 2)}\\n\\n` : `[See compiled UI example ${String.fromCharCode('A'.charCodeAt(0) + i)}]`;\n    return {\n      cursor: blk.end,\n      out: acc.out + pre + mid\n    };\n  }, {\n    cursor: 0,\n    out: ''\n  });\n  return parts.out + text.slice(parts.cursor);\n}\n/**\n * @public\n */\nfunction prompt(strings, ...exprs) {\n  const {\n    text,\n    placeholders\n  } = weavePlaceholders(strings, exprs);\n  const exprsByToken = new Map(placeholders.map((p, i) => [p, exprs[i]]));\n  const blocks = findUiBlocks(text);\n  const parsed = blocks.map(b => parseUi(b.source, b.innerStart));\n  const astBlocks = parsed.map(p => p.nodes);\n  const parseDiagnostics = parsed.flatMap(p => p.diagnostics).map(d => Object.assign(Object.assign({}, d), absoluteToLineCol(text, d.start)));\n  const lowered = astBlocks.map(ast => ast.map(n => lowerToHB(n, exprsByToken)));\n  const loweredTrees = lowered.map(nodes => nodes.map(r => r.hb).filter(x => x != null));\n  const lowerDiagnostics = lowered.flatMap(nodes => nodes.flatMap(r => r.diagnostics)).map(d => Object.assign(Object.assign({}, d), absoluteToLineCol(text, d.start)));\n  let diagnostics = parseDiagnostics.concat(lowerDiagnostics);\n  function compile(components, schema) {\n    // Build component lookup by name and selector for policy-aware lowering\n    const byName = new Map();\n    components.forEach(c => {\n      if (c && typeof c.name === 'string') byName.set(c.name, c);\n      if (c && typeof c.selector === 'string') byName.set(c.selector, c);\n    });\n    // Lower AST using the component children policy (supports 'text')\n    const policyExamples = astBlocks.map(ast => ast.map(n => lowerWithPolicy(n, exprsByToken, byName)).filter(n => n != null));\n    // Prepare a cleaned version for injection without meta helper properties\n    const cleanForInjection = nodes => nodes.map(n => {\n      const _a = n,\n        {\n          $tag,\n          $children\n        } = _a,\n        rest = __rest(_a, [\"$tag\", \"$children\"]);\n      const cleaned = {\n        $tag\n      };\n      if (Array.isArray($children)) {\n        cleaned.$children = cleanForInjection($children);\n      } else {\n        cleaned.$children = $children;\n      }\n      // Copy non-internal props (ignore $elementChildren)\n      Object.entries(rest).forEach(([k, v]) => {\n        if (k !== '$elementChildren') cleaned[k] = v;\n      });\n      return cleaned;\n    });\n    const validation = validateExamples(policyExamples, blocks, components, o => absoluteToLineCol(text, o));\n    diagnostics = parseDiagnostics.concat(lowerDiagnostics).concat(validation);\n    const cleaned = policyExamples.map(tree => cleanForInjection(tree));\n    // If an explicit UI schema is provided, downlevel examples for streaming\n    // just before emitting them inside JSON fences.\n    const toInject = cleaned.map(tree => {\n      try {\n        return schema.toStreaming({\n          ui: tree\n        });\n      } catch (_a) {\n        return '';\n      }\n    });\n    // If no components are provided, do not inline JSON fences; preserve author text.\n    const mode = components.length > 0 ? 'inline' : 'none';\n    return injectExamples(text, blocks, toInject, mode);\n  }\n  return {\n    compile,\n    examples: loweredTrees,\n    get diagnostics() {\n      return diagnostics;\n    },\n    meta: {\n      uiBlocks: blocks.map(b => ({\n        start: b.start,\n        end: b.end,\n        source: b.source\n      }))\n    }\n  };\n}\n\n/**\n * Creates a function with an input schema.\n *\n * @public\n * @param cfg - The configuration for the function containing:\n *   - `name`: The name of the function\n *   - `description`: The description of the function\n *   - `args`: The args schema of the function\n *   - `result`: The result schema of the function\n *   - `handler`: The handler of the function\n * @returns The function reference.\n */\nfunction createRuntimeFunctionImpl(cfg) {\n  if (!('args' in cfg) && !('result' in cfg)) {\n    return {\n      name: cfg.name,\n      description: cfg.description,\n      handler: function (_, abortSignal) {\n        return cfg.handler(abortSignal);\n      }\n    };\n  }\n  if (!('args' in cfg)) {\n    return {\n      name: cfg.name,\n      description: cfg.description,\n      result: cfg.result,\n      handler: function (_, abortSignal) {\n        return cfg.handler(abortSignal);\n      }\n    };\n  }\n  if (!('result' in cfg)) {\n    return {\n      name: cfg.name,\n      description: cfg.description,\n      args: cfg.args,\n      handler: cfg.handler\n    };\n  }\n  return {\n    name: cfg.name,\n    description: cfg.description,\n    args: cfg.args,\n    result: cfg.result,\n    handler: cfg.handler\n  };\n}\nfunction attachFunctionToContext(context, transport, definition, attachTo, abortSignal) {\n  const {\n    name,\n    args: argsSchema,\n    result: resultSchema,\n    handler\n  } = definition;\n  const fnHandle = context.newAsyncifiedFunction(name, (...args) => {\n    if (argsSchema === undefined && resultSchema === undefined) {\n      return handler(null, abortSignal).then(() => context.undefined);\n    }\n    if (argsSchema === undefined) {\n      return handler(null, abortSignal).then(result => transport.sendObject(result));\n    }\n    if (resultSchema === undefined) {\n      const resolvedArgs = transport.receiveObject(args[0]);\n      return handler(resolvedArgs, abortSignal).then(() => context.undefined);\n    }\n    const resolvedArgs = transport.receiveObject(args[0]);\n    return handler(resolvedArgs, abortSignal).then(result => transport.sendObject(result));\n  });\n  context.setProp(attachTo, name, fnHandle);\n  return fnHandle;\n}\n\nclass RuntimeTransport {\n  constructor(context) {\n    this.context = context;\n    const jsonResult = context.getProp(context.global, 'JSON');\n    const stringifyResult = context.getProp(jsonResult, 'stringify');\n    const parseResult = context.getProp(jsonResult, 'parse');\n    this.jsonHandle = jsonResult;\n    this.stringifyHandle = stringifyResult;\n    this.parseHandle = parseResult;\n  }\n  sendObject(object) {\n    const asString = JSON.stringify(object);\n    const stringHandle = this.context.newString(asString);\n    const result = this.context.callFunction(this.parseHandle, this.jsonHandle, stringHandle);\n    stringHandle.dispose();\n    return result;\n  }\n  sendError(name, message) {\n    return this.context.newError({\n      name,\n      message\n    });\n  }\n  receiveObject(handle) {\n    const result = this.context.callFunction(this.stringifyHandle, this.jsonHandle, handle);\n    const stringHandle = result.unwrap();\n    const asString = this.context.getString(stringHandle);\n    stringHandle.dispose();\n    return JSON.parse(asString);\n  }\n}\n\nfunction installDateTimeFormat(ctx) {\n  const formatHandle = ctx.newFunction('format', (dateHandle, localeHandle, optionsHandle) => {\n    const date = ctx.dump(dateHandle);\n    const locale = ctx.dump(localeHandle);\n    const options = ctx.dump(optionsHandle);\n    const result = new Intl.DateTimeFormat(locale, options).format(new Date(date));\n    return ctx.newString(result);\n  });\n  ctx.setProp(ctx.global, '__hb__Intl.DateTimeFormat.format', formatHandle);\n  ctx.evalCode(`\n    class DateTimeFormat {\n      constructor(locale, options) {\n        this.locale = locale;\n        this.options = options;\n      }\n\n      format(date) {\n        return globalThis[\"__hb__Intl.DateTimeFormat.format\"].call(\n          this,\n          date,\n          this.locale,\n          this.options\n        );\n      }\n    }\n\n    globalThis.Intl.DateTimeFormat = DateTimeFormat;\n  `);\n}\n\nfunction installIntl(ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const IntlHandle = ctx.newObject();\n    ctx.setProp(ctx.global, 'Intl', IntlHandle);\n    installDateTimeFormat(ctx);\n  });\n}\n\n/**\n * Creates a new runtime.\n *\n * @public\n * @param options - The options for creating the runtime containing:\n *   - `timeout`: The timeout for the runtime\n *   - `functions`: The functions that are available in the runtime\n * @returns A reference to the runtime.\n */\nfunction createRuntimeImpl(options) {\n  const {\n    timeout = 1000,\n    functions\n  } = options;\n  const description = functions.map(fn => {\n    const argsWithType = fn.args ? `args: ${fn.args.toTypeScript()}` : '';\n    const returnType = fn.result ? fn.result.toTypeScript() : 'void';\n    return [`### ${fn.name}`, fn.description, '', `**Type Signature:**`, `\\`\\`\\`typescript`, `${fn.name}(${argsWithType}): ${returnType}`, `\\`\\`\\``].join('\\n');\n  }).join('\\n\\n');\n  return {\n    functions,\n    timeout,\n    describe() {\n      return description;\n    },\n    run(code, abortSignal) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const signal = abortSignal ? AbortSignal.any([abortSignal, AbortSignal.timeout(timeout)]) : AbortSignal.timeout(timeout);\n        const [{\n          newQuickJSAsyncWASMModuleFromVariant\n        }, variant] = yield Promise.all([__webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_hashbrownai_core_0_3_0_node_modules_hashbrownai_core_ind-673761\").then(__webpack_require__.bind(__webpack_require__, /*! ./index.esm4.js */ \"(app-pages-browser)/./node_modules/.pnpm/@hashbrownai+core@0.3.0/node_modules/@hashbrownai/core/index.esm4.js\")), __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_hashbrownai_core_0_3_0_node_modules_hashbrownai_core_ind-3a8ec2\").then(__webpack_require__.bind(__webpack_require__, /*! ./index.esm2.js */ \"(app-pages-browser)/./node_modules/.pnpm/@hashbrownai+core@0.3.0/node_modules/@hashbrownai/core/index.esm2.js\")).then(m => m.default)]);\n        const QuickJS = yield newQuickJSAsyncWASMModuleFromVariant(variant);\n        const runtime = QuickJS.newRuntime({\n          interruptHandler: () => {\n            return signal.aborted;\n          }\n        });\n        const vm = runtime.newContext();\n        const transport = new RuntimeTransport(vm);\n        installIntl(vm);\n        options.functions.forEach(fn => {\n          attachFunctionToContext(vm, transport, fn, vm.global, signal);\n        });\n        const result = yield vm.evalCodeAsync(code);\n        if (result.error) {\n          const response = {\n            error: vm.dump(result.error)\n          };\n          result.error.dispose();\n          vm.dispose();\n          return response;\n        } else {\n          const response = {\n            result: vm.dump(result.value)\n          };\n          result.value.dispose();\n          vm.dispose();\n          return response;\n        }\n      });\n    }\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Flattens a component hierarchy into a map of component names to their definitions.\n * This includes nested components defined in the children property.\n *\n * @public\n */\nfunction flattenComponents(components) {\n  const componentMap = new Map();\n  function processComponent(component) {\n    componentMap.set(component.name, component);\n    if (component.children && Array.isArray(component.children)) {\n      component.children.forEach(processComponent);\n    }\n  }\n  components.forEach(processComponent);\n  return componentMap;\n}\n/**\n * Creates a schema for a list of exposed components, allowing for the definition\n * of component structures and their relationships.\n *\n * @public\n * @param components - An array of components to create schemas for.\n * @returns A schema representing the structure of the components.\n */\nfunction createComponentSchema(components) {\n  const weakMap = new WeakMap();\n  const elements = anyOf(components.map(component => createSchema(component)));\n  function createSchema(component) {\n    var _a, _b, _c, _d;\n    if (weakMap.has(component.component)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return weakMap.get(component.component);\n    }\n    const children = component.children;\n    if (children === 'any') {\n      const schema = object$1(component.description, {\n        $tag: literal(component.name),\n        $props: object$1('Component Props', (_a = component.props) !== null && _a !== void 0 ? _a : {}),\n        get $children() {\n          return array('Child Elements', elements);\n        }\n      });\n      weakMap.set(component.component, schema);\n      return schema;\n    } else if (children === 'text') {\n      const schema = object$1(component.description, {\n        $tag: literal(component.name),\n        $props: object$1('Component Props', (_b = component.props) !== null && _b !== void 0 ? _b : {}),\n        $children: string('Content')\n      });\n      weakMap.set(component.component, schema);\n      return schema;\n    } else if (children && Array.isArray(children)) {\n      const schema = object$1(component.description, {\n        $tag: literal(component.name),\n        $props: object$1('Component Props', (_c = component.props) !== null && _c !== void 0 ? _c : {}),\n        get $children() {\n          return array('Child Elements', anyOf(children.map(child => createSchema(child))));\n        }\n      });\n      weakMap.set(component.component, schema);\n      return schema;\n    } else {\n      const schema = object$1(component.description, {\n        $tag: literal(component.name),\n        $props: object$1('Component Props', (_d = component.props) !== null && _d !== void 0 ? _d : {})\n      });\n      weakMap.set(component.component, schema);\n      return schema;\n    }\n  }\n  return elements;\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createComponentSchema: createComponentSchema,\n    flattenComponents: flattenComponents\n});\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Deep structural comparison that \"just works\" on primitives too.\n * @public\n */\nfunction deepEqual(a, b, seen = new WeakMap()) {\n  // 1. Fast‑path for strict equality – catches most primitives & identical references.\n  if (a === b) {\n    // Distinguish +0 and –0 (JS treats them as equal but spec says they’re not “SameValue”)\n    return a !== 0 || 1 / a === 1 / b;\n  }\n  // 2. Handle the one primitive pair that fails `===`: NaN\n  if (Number.isNaN(a) && Number.isNaN(b)) return true;\n  // 3. If types differ (and neither is null/undefined), we’re already unequal.\n  const ta = typeof a,\n    tb = typeof b;\n  if (ta !== tb) return false;\n  if (ta !== 'object' && ta !== 'function') return false; // all remaining primitives handled above\n  // 4. Null is `object` in JS but can’t be equal to anything reached here.\n  if (a === null || b === null) return false;\n  // 5. Protect against cycles (A↔B, etc.)\n  if (seen.get(a) === b) return true;\n  seen.set(a, b);\n  /** Helper used below */\n  const eq = (x, y) => deepEqual(x, y, seen);\n  // ========== Built‑ins with bespoke semantics ==========\n  if (a instanceof Date || b instanceof Date) return a instanceof Date && b instanceof Date && a.getTime() === b.getTime();\n  if (a instanceof RegExp || b instanceof RegExp) return a instanceof RegExp && b instanceof RegExp && a.source === b.source && a.flags === b.flags;\n  if (ArrayBuffer.isView(a) || ArrayBuffer.isView(b)) {\n    if (!(ArrayBuffer.isView(a) && ArrayBuffer.isView(b))) return false;\n    if (a.byteLength !== b.byteLength) return false;\n    // DataView covers every TypedArray behind the scenes\n    const dvA = new DataView(a.buffer, a.byteOffset);\n    const dvB = new DataView(b.buffer, b.byteOffset);\n    for (let i = 0; i < dvA.byteLength; i++) {\n      if (dvA.getUint8(i) !== dvB.getUint8(i)) return false;\n    }\n    return true;\n  }\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) if (!eq(a[i], b[i])) return false;\n    return true;\n  }\n  if (a instanceof Set || b instanceof Set) {\n    if (!(a instanceof Set && b instanceof Set) || a.size !== b.size) return false;\n    outer: for (const va of a) {\n      for (const vb of b) if (eq(va, vb)) continue outer;\n      return false; // no match found\n    }\n    return true;\n  }\n  if (a instanceof Map || b instanceof Map) {\n    if (!(a instanceof Map && b instanceof Map) || a.size !== b.size) return false;\n    outer: for (const [ka, va] of a) {\n      for (const [kb, vb] of b) {\n        if (eq(ka, kb) && eq(va, vb)) continue outer;\n      }\n      return false;\n    }\n    return true;\n  }\n  // ========== Plain objects + class instances (prototype doesn’t matter) ==========\n  const keysA = Reflect.ownKeys(a);\n  const keysB = Reflect.ownKeys(b);\n  if (keysA.length !== keysB.length) return false;\n  for (const k of keysA) {\n    if (!keysB.includes(k) || !eq(a[k], b[k])) return false;\n  }\n  return true;\n}\n\nvar types = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaGFzaGJyb3duYWkrY29yZUAwLjMuMC9ub2RlX21vZHVsZXMvQGhhc2hicm93bmFpL2NvcmUvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsME1BQTBNLGNBQWM7QUFDeE4sOEJBQThCLHNCQUFzQjtBQUNwRCwwQkFBMEIsWUFBWSxzQkFBc0IscUNBQXFDLDJDQUEyQyxNQUFNO0FBQ2xKLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixxREFBcUQsWUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGVBQWU7QUFDNUQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxJQUFJLElBQUk7QUFDM0I7QUFDQSxHQUFHO0FBQ0gsY0FBYyxLQUFLLElBQUksSUFBSTtBQUMzQixHQUFHO0FBQ0gsY0FBYyxLQUFLLElBQUksSUFBSTtBQUMzQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLE1BQU07QUFDbEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJLElBQUk7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQyxhQUFhLDRCQUE0QjtBQUN6QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHVDQUF1QztBQUN2QyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRCx1Q0FBdUM7QUFDdkM7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCx1Q0FBdUM7QUFDdkM7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCx1Q0FBdUM7QUFDdkM7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHVDQUF1QztBQUN2QztBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNULEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsZ0JBQWdCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLHlDQUF5QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELGdEQUFnRDtBQUNoRDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsTUFBTSxFQUFFLG1CQUFtQixFQUFFLEVBQUU7QUFDaEcsOENBQThDLG1CQUFtQixFQUFFLEVBQUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RUE7QUFDQTtBQUNBLENBQUM7O0FBRTJQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaGFzaGJyb3duYWkrY29yZUAwLjMuMC9ub2RlX21vZHVsZXMvQGhhc2hicm93bmFpL2NvcmUvaW5kZXguZXNtLmpzPzEwMzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG4vKipcbiAqIERlY29kZSBhIFJlYWRhYmxlU3RyZWFtXFw8VWludDhBcnJheVxcPiBvZiBsZW5ndGgtcHJlZml4ZWQgSlNPTiBmcmFtZXMgaW50byBhIHN0cmVhbSBvZiBULlxuICpcbiAqIEZyYW1lIGZvcm1hdDogWzQtYnl0ZSBCRSBsZW5ndGhdW1VURi04IEpTT04gcGF5bG9hZF1cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gc3RyZWFtIC0gUmVhZGFibGVTdHJlYW0gcHJvZHVjaW5nIFVpbnQ4QXJyYXkgY2h1bmtzXG4gKiBAcGFyYW0gb3B0aW9ucyAtIGRlY29kaW5nIG9wdGlvbnNcbiAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIG9mIHRoZSBwYXJzZWQgSlNPTiBvYmplY3RzXG4gKiBAcmV0dXJucyAtIEEgc3RyZWFtIG9mIHBhcnNlZCBKU09OIG9iamVjdHMgb2YgdHlwZSBUXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUZyYW1lcyhzdHJlYW0sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogZGVjb2RlRnJhbWVzXzEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmFsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgIHJlYWRlci5jYW5jZWwoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgeWllbGQgX19hd2FpdChyZWFkZXIuY2FuY2VsKCkpO1xuICAgICAgcmV0dXJuIHlpZWxkIF9fYXdhaXQodm9pZCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RpbmcgYWJvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9ID0geWllbGQgX19hd2FpdChyZWFkZXIucmVhZCgpKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgbmV3QnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICBuZXdCdWZmZXIuc2V0KGNodW5rLCBidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgYnVmZmVyID0gbmV3QnVmZmVyO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCAtIG9mZnNldCA+PSA0KSB7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCAvKiBCaWcgRW5kaWFuICovZmFsc2UpO1xuICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoIC0gb2Zmc2V0IDwgNCArIGxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gb2Zmc2V0ICsgNDtcbiAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIGxlbmd0aDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZEJ5dGVzID0gYnVmZmVyLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgY29uc3QganNvbiA9IHRleHREZWNvZGVyLmRlY29kZShwYXlsb2FkQnl0ZXMpO1xuICAgICAgICAgICAgY29uc3QgZnJhbWUgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChmcmFtZSk7XG4gICAgICAgICAgICBpZiAoZnJhbWUudHlwZSA9PT0gJ2ZpbmlzaCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF9fYXdhaXQodm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OIHBheWxvYWQ6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJlYW0gZW5kZWQgd2l0aCAke2J1ZmZlci5sZW5ndGh9IGxlZnRvdmVyIGJ5dGVzYCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIGZyYW1lIGludG8gYSBiaW5hcnkgZm9ybWF0LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBmcmFtZSAtIFRoZSBmcmFtZSB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBmcmFtZS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlRnJhbWUoZnJhbWUpIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBqc29uQnl0ZXMgPSBlbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShmcmFtZSkpO1xuICBjb25zdCBsZW4gPSBqc29uQnl0ZXMubGVuZ3RoO1xuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSg0ICsgbGVuKTtcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhvdXQuYnVmZmVyLCBvdXQuYnl0ZU9mZnNldCwgb3V0LmJ5dGVMZW5ndGgpO1xuICB2aWV3LnNldFVpbnQzMigwLCBsZW4sIC8qIEJpZyBFbmRpYW4gKi9mYWxzZSk7XG4gIG91dC5zZXQoanNvbkJ5dGVzLCA0KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIFN5bmNocm9ub3VzIOKAnHRyYW1wb2xpbmXigJ0gc2NoZWR1bGVyLlxuICpcbiAqIEFsbCB3b3JrIGV4ZWN1dGVzIGluIHRoZSBzYW1lIG1hY3JvdGFzaywgYnV0IHN0YWNrLXNhZmU6XG4gKiB0YXNrcyBzY2hlZHVsZWQgZnJvbSBpbnNpZGUgb3RoZXIgdGFza3MgYXJlIHF1ZXVlZFxuICogYW5kIHByb2Nlc3NlZCBhZnRlciB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMuXG4gKi9cbmNsYXNzIFRyYW1wb2xpbmVTY2hlZHVsZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5leHRJZCA9IDA7XG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkgcmV0dXJuO1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB3aGlsZSAodGhpcy5xdWV1ZS5zaXplKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHRoaXMucXVldWUuZW50cmllcygpLm5leHQoKS52YWx1ZTtcbiAgICAgIGlmICghZW50cnkpIGJyZWFrO1xuICAgICAgY29uc3QgW2lkLCB0YXNrXSA9IGVudHJ5O1xuICAgICAgdGhpcy5xdWV1ZS5kZWxldGUoaWQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGFzaygpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFN1cmZhY2UgZXJyb3JzIGFzeW5jaHJvbm91c2x5IHNvIG9uZSBmYWlsdXJlXG4gICAgICAgIC8vIGRvZXNu4oCZdCBwcmV2ZW50IGxhdGVyIHRhc2tzIGZyb20gcnVubmluZ1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG4gIHNjaGVkdWxlVGFzayhmbikge1xuICAgIGNvbnN0IGlkID0gKyt0aGlzLm5leHRJZDtcbiAgICB0aGlzLnF1ZXVlLnNldChpZCwgZm4pO1xuICAgIHRoaXMuZmx1c2goKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgY2FuY2VsVGFzayhpZCkge1xuICAgIHRoaXMucXVldWUuZGVsZXRlKGlkKTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgcGF5bG9hZCBwcm9qZWN0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGl0cyBhcmd1bWVudC5cbiAqXG4gKiBAdHlwZVBhcmFtIFQgLSBUaGUgcGF5bG9hZCB0eXBlLlxuICogQHJldHVybnMgRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBwcm92aWRlZCBwYXlsb2FkLlxuICovXG5mdW5jdGlvbiBwcm9wcygpIHtcbiAgcmV0dXJuIHBheWxvYWQgPT4gcGF5bG9hZDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhY3Rpb24gY3JlYXRvciB3aXRoIG5vIHBheWxvYWQuXG4gKlxuICogQHJldHVybnMgRnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBhY3Rpb24gd2l0aCBvbmx5IGEgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZW1wdHlQcm9wcygpIHtcbiAgcmV0dXJuICgpID0+IHt9O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBncm91cCBvZiBhY3Rpb24gY3JlYXRvciBmdW5jdGlvbnMgd2l0aCBhIGNvbW1vbiB0eXBlIHByZWZpeC5cbiAqXG4gKiBAdHlwZVBhcmFtIEdyb3VwTmFtZSAtIFRoZSBtb2RpZmllciBmb3IgYWN0aW9uIHR5cGVzIChlLmcuLCBmZWF0dXJlIG5hbWUpLlxuICogQHR5cGVQYXJhbSBUIC0gQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgcGF5bG9hZCBjcmVhdG9yIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIGdyb3VwIHByZWZpeCBuYW1lLlxuICogQHBhcmFtIGdyb3VwIC0gQW4gb2JqZWN0IG1hcHBpbmcgYWN0aW9uIG5hbWVzIHRvIHBheWxvYWQgZnVuY3Rpb25zLlxuICogQHJldHVybnMgQSBzZXQgb2YgYWN0aW9uIGNyZWF0b3JzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25Hcm91cChuYW1lLCBncm91cCkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGdyb3VwKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgT2JqZWN0LmFzc2lnbih0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyBwYXlsb2FkID0+ICh7XG4gICAgdHlwZTogYFske25hbWV9XSAke2tleX1gLFxuICAgIHBheWxvYWRcbiAgfSkgOiAoKSA9PiAoe1xuICAgIHR5cGU6IGBbJHtuYW1lfV0gJHtrZXl9YFxuICB9KSwge1xuICAgIHR5cGU6IGBbJHtuYW1lfV0gJHtrZXl9YFxuICB9KV0pKTtcbn1cbi8qKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqID09PSAgICAgICAgIFJlZHVjZXJzICAgICAgICAgPT09XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIENyZWF0ZXMgYSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgcmVzcG9uZHMgdG8gc3BlY2lmaWVkIGFjdGlvbiB0eXBlcy5cbiAqXG4gKiBAdHlwZVBhcmFtIFN0YXRlIC0gVGhlIHR5cGUgb2YgdGhlIHNsaWNlIG9mIHN0YXRlLlxuICogQHR5cGVQYXJhbSBBY3Rpb25zIC0gQW4gYXJyYXkgb2YgQWN0aW9uQ3JlYXRvciB0eXBlcyB0byBoYW5kbGUuXG4gKiBAcGFyYW0gcGFyYW1zIC0gT25lIG9yIG1vcmUgYWN0aW9uIGNyZWF0b3JzIGZvbGxvd2VkIGJ5IGEgcmVkdWNlciBoYW5kbGVyLlxuICogQHJldHVybnMgQSByZWR1Y2VyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvbiguLi5wYXJhbXMpIHtcbiAgY29uc3QgYWN0aW9uRm5zID0gcGFyYW1zLnNsaWNlKDAsIC0xKTtcbiAgY29uc3QgcmVkdWNlckZuID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgY29uc3Qgc2hvdWxkUmVkdWNlU3RhdGUgPSBhY3Rpb25GbnMuc29tZShwYXJhbSA9PiBwYXJhbS50eXBlID09PSBhY3Rpb24udHlwZSk7XG4gICAgaWYgKCFzaG91bGRSZWR1Y2VTdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gcmVkdWNlckZuKHN0YXRlLCBhY3Rpb24pO1xuICB9O1xufVxuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSByZWR1Y2VyIGZ1bmN0aW9ucyBpbnRvIGEgc2luZ2xlIHJvb3QgcmVkdWNlci5cbiAqXG4gKiBAdHlwZVBhcmFtIFN0YXRlIC0gVGhlIGNvbWJpbmVkIHN0YXRlIHNoYXBlLlxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSAtIFRoZSBpbml0aWFsIHN0YXRlIHdoZW4gdW5kZWZpbmVkIGlzIHBhc3NlZC5cbiAqIEBwYXJhbSByZWR1Y2VycyAtIE9uZSBvciBtb3JlIHJlZHVjZXIgZnVuY3Rpb25zLlxuICogQHJldHVybnMgVGhlIHJvb3QgcmVkdWNlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUsIC4uLnJlZHVjZXJzKSB7XG4gIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIHJldHVybiByZWR1Y2Vycy5yZWR1Y2UoKGFjYywgcmVkdWNlcikgPT4gcmVkdWNlcihhY2MsIGFjdGlvbiksIHN0YXRlID09PSB1bmRlZmluZWQgPyBpbml0aWFsU3RhdGUgOiBzdGF0ZSk7XG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gZWZmZWN0IGZ1bmN0aW9uIHRoYXQgY2FuIHN1YnNjcmliZSB0byBzdG9yZSBhY3Rpb25zIGFuZCByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBlZmZlY3RGbiAtIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIHN0b3JlIGFuZCByZXR1cm5zIGEgdGVhcmRvd24gY2FsbGJhY2suXG4gKiBAcmV0dXJucyBUaGUgcHJvdmlkZWQgZWZmZWN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFZmZlY3QoZWZmZWN0Rm4pIHtcbiAgcmV0dXJuIGVmZmVjdEZuO1xufVxuZnVuY3Rpb24gc2VsZWN0KC4uLnBhcmFtcykge1xuICBsZXQgaW5wdXRzID0gcGFyYW1zLnNsaWNlKDAsIC0xKTtcbiAgbGV0IHNlbGVjdEZuID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcbiAgbGV0IGNvbmZpZztcbiAgaWYgKHR5cGVvZiBzZWxlY3RGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbmZpZyA9IHNlbGVjdEZuO1xuICAgIHNlbGVjdEZuID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAyXTtcbiAgICBpbnB1dHMgPSBwYXJhbXMuc2xpY2UoMCwgLTIpO1xuICB9XG4gIGxldCBsYXN0SW5wdXRWYWx1ZXMgPSBbXTtcbiAgbGV0IGxhc3RPdXRwdXQ7XG4gIHJldHVybiBzdGF0ZSA9PiB7XG4gICAgY29uc3QgaW5wdXRWYWx1ZXMgPSBpbnB1dHMubWFwKGlucHV0ID0+IGlucHV0KHN0YXRlKSk7XG4gICAgaWYgKGlucHV0VmFsdWVzLnNvbWUoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgaXNNaXNtYXRjaGVkID0gdmFsdWUgIT09IGxhc3RJbnB1dFZhbHVlc1tpbmRleF07XG4gICAgICBpZiAoaXNNaXNtYXRjaGVkICYmIGNvbmZpZyAmJiBjb25maWcuZGVidWdOYW1lKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTZWxlY3QgQXJndW1lbnQgTWlzbWF0Y2g6JywgY29uZmlnLmRlYnVnTmFtZSwgYGlucHV0WyR7aW5kZXh9XWAsICdsYXN0OicsIGxhc3RJbnB1dFZhbHVlc1tpbmRleF0sICdub3c6JywgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzTWlzbWF0Y2hlZDtcbiAgICB9KSkge1xuICAgICAgbGFzdElucHV0VmFsdWVzID0gaW5wdXRWYWx1ZXM7XG4gICAgICBsYXN0T3V0cHV0ID0gc2VsZWN0Rm4oLi4uaW5wdXRWYWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdE91dHB1dDtcbiAgfTtcbn1cbi8qKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqID09PSAgICAgICAgIFN0b3JlICAgICAgICAgICAgPT09XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSB3aXRoIHJlZHVjZXJzIGFuZCBlZmZlY3RzLlxuICogQHR5cGVQYXJhbSBSZWR1Y2VycyAtIEFuIG9iamVjdCBtYXBwaW5nIGtleXMgdG8gcmVkdWNlciBmdW5jdGlvbnMuXG4gKiBAdHlwZVBhcmFtIFN0YXRlIC0gVGhlIHJlc3VsdGluZyBzdGF0ZSBzaGFwZSBpbmZlcnJlZCBmcm9tIFJlZHVjZXJzLlxuICogQHBhcmFtIGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMgVGhlIGluaXRpYWxpemVkIHN0b3JlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShjb25maWcpIHtcbiAgY29uc3Qgc2NoZWR1bGVyID0gbmV3IFRyYW1wb2xpbmVTY2hlZHVsZXIoKTtcbiAgY29uc3QgZGV2dG9vbHMgPSBjb25maWcuZGVidWdOYW1lID8gY29ubmVjdFRvQ2hyb21lRXh0ZW5zaW9uKHtcbiAgICBuYW1lOiBjb25maWcuZGVidWdOYW1lXG4gIH0pIDogdW5kZWZpbmVkO1xuICBjb25zdCByZWR1Y2VyRm5FbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoY29uZmlnLnJlZHVjZXJzKTtcbiAgY29uc3QgcmVkdWNlckZuID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICByZXR1cm4gcmVkdWNlckZuRW50cmllcy5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7XG4gICAgICAgIFtrZXldOiB2YWx1ZShhY2MgPT09IG51bGwgfHwgYWNjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY2Nba2V5XSwgYWN0aW9uKVxuICAgICAgfSk7XG4gICAgfSwgc3RhdGUpO1xuICB9O1xuICBjb25zdCB3aGVuQ2FsbGJhY2tGbk1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3Qgc2VsZWN0Q2FsbGJhY2tGbnMgPSBbXTtcbiAgbGV0IHN0YXRlID0gcmVkdWNlckZuKHVuZGVmaW5lZCwge1xuICAgIHR5cGU6ICdAQGluaXQnXG4gIH0pO1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBzY2hlZHVsZXIuc2NoZWR1bGVUYXNrKCgpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgc3RhdGUgPSByZWR1Y2VyRm4oc3RhdGUsIGFjdGlvbik7XG4gICAgICBjb25zdCB3aGVuQ2FsbGJhY2tGbnMgPSAoX2EgPSB3aGVuQ2FsbGJhY2tGbk1hcC5nZXQoYWN0aW9uLnR5cGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgIHdoZW5DYWxsYmFja0Zucy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGFjdGlvbikpO1xuICAgICAgc2VsZWN0Q2FsbGJhY2tGbnMuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKTtcbiAgICAgIGRldnRvb2xzID09PSBudWxsIHx8IGRldnRvb2xzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXZ0b29scy5zZW5kKGFjdGlvbiwgKF9jID0gKF9iID0gY29uZmlnLnByb2plY3RTdGF0ZUZvckRldnRvb2xzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChjb25maWcsIHN0YXRlKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogc3RhdGUpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHdoZW4oLi4ucGFyYW1zKSB7XG4gICAgY29uc3QgYWN0aW9uRm5zID0gcGFyYW1zLnNsaWNlKDAsIC0xKTtcbiAgICBjb25zdCBjYWxsYmFja0ZuID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcbiAgICBhY3Rpb25GbnMuZm9yRWFjaChhY3Rpb25GbiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXdoZW5DYWxsYmFja0ZuTWFwLmhhcyhhY3Rpb25Gbi50eXBlKSkge1xuICAgICAgICB3aGVuQ2FsbGJhY2tGbk1hcC5zZXQoYWN0aW9uRm4udHlwZSwgW10pO1xuICAgICAgfVxuICAgICAgKF9hID0gd2hlbkNhbGxiYWNrRm5NYXAuZ2V0KGFjdGlvbkZuLnR5cGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaChjYWxsYmFja0ZuKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYWN0aW9uRm5zLmZvckVhY2goYWN0aW9uRm4gPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IChfYSA9IHdoZW5DYWxsYmFja0ZuTWFwLmdldChhY3Rpb25Gbi50eXBlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIHdoZW5DYWxsYmFja0ZuTWFwLnNldChhY3Rpb25Gbi50eXBlLCBjYWxsYmFja3MuZmlsdGVyKGNiID0+IGNiICE9PSBjYWxsYmFja0ZuKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHdoZW5PbmNlKC4uLnBhcmFtcykge1xuICAgIGNvbnN0IGFjdGlvbkZucyA9IHBhcmFtcy5zbGljZSgwLCAtMSk7XG4gICAgY29uc3QgY2FsbGJhY2tGbiA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgY2xlYW51cEZuID0gd2hlbiguLi5hY3Rpb25GbnMsIGFjdGlvbiA9PiB7XG4gICAgICBjYWxsYmFja0ZuKGFjdGlvbik7XG4gICAgICBjbGVhbnVwRm4oKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2xlYW51cEZuO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWQoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3Ioc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdChzZWxlY3Rvciwgb25DaGFuZ2UpIHtcbiAgICBsZXQgY3VycmVudFZhbHVlID0gcmVhZChzZWxlY3Rvcik7XG4gICAgb25DaGFuZ2UoY3VycmVudFZhbHVlKTtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcmVhZChzZWxlY3Rvcik7XG4gICAgICBpZiAobmV3VmFsdWUgIT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICBjdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgb25DaGFuZ2UobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2VsZWN0Q2FsbGJhY2tGbnMucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNlbGVjdENhbGxiYWNrRm5zLnNwbGljZShzZWxlY3RDYWxsYmFja0Zucy5pbmRleE9mKGNhbGxiYWNrKSwgMSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVTaWduYWwoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbigoKSA9PiByZWFkKHNlbGVjdG9yKSwge1xuICAgICAgc3Vic2NyaWJlOiBvbkNoYW5nZSA9PiBzZWxlY3Qoc2VsZWN0b3IsIG9uQ2hhbmdlKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJ1bkVmZmVjdHMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBkZXZ0b29scyA9PT0gbnVsbCB8fCBkZXZ0b29scyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGV2dG9vbHMuaW5pdCgoX2IgPSAoX2EgPSBjb25maWcucHJvamVjdFN0YXRlRm9yRGV2dG9vbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbmZpZywgc3RhdGUpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBzdGF0ZSk7XG4gICAgY29uc3QgY2xlYW51cEZucyA9IGNvbmZpZy5lZmZlY3RzLm1hcChlZmZlY3QgPT4gZWZmZWN0KHN0b3JlKSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXBGbnMuZm9yRWFjaChmbiA9PiBmbigpKTtcbiAgICAgIGRldnRvb2xzID09PSBudWxsIHx8IGRldnRvb2xzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXZ0b29scy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH1cbiAgY29uc3Qgc3RvcmUgPSB7XG4gICAgZGlzcGF0Y2gsXG4gICAgcmVhZCxcbiAgICBzZWxlY3QsXG4gICAgd2hlbjogd2hlbixcbiAgICB3aGVuT25jZTogd2hlbk9uY2UsXG4gICAgY3JlYXRlU2lnbmFsLFxuICAgIHJ1bkVmZmVjdHNcbiAgfTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIEVudGl0eUFkYXB0ZXIgZm9yIHBlcmZvcm1pbmcgaW1tdXRhYmxlIHVwZGF0ZXMgb24gZW50aXR5IGNvbGxlY3Rpb25zLlxuICogQHR5cGVQYXJhbSBFbnRpdHkgLSBUaGUgZW50aXR5IHR5cGUuXG4gKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiB3aXRoIGEgc2VsZWN0SWQgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyBBZGFwdGVyIHdpdGggQ1JVRCBtZXRob2RzIGZvciBlbnRpdHkgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVudGl0eUFkYXB0ZXIoY29uZmlnKSB7XG4gIGNvbnN0IHtcbiAgICBzZWxlY3RJZFxuICB9ID0gY29uZmlnO1xuICBmdW5jdGlvbiB1cGRhdGVPbmUoc3RhdGUsIGNoYW5nZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICAgIGVudGl0aWVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmVudGl0aWVzKSwge1xuICAgICAgICBbY2hhbmdlcy5pZF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuZW50aXRpZXNbY2hhbmdlcy5pZF0pLCBjaGFuZ2VzLnVwZGF0ZXMpXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnkoc3RhdGUsIGNoYW5nZXMpIHtcbiAgICByZXR1cm4gY2hhbmdlcy5yZWR1Y2UoKGFjYywgY2hhbmdlKSA9PiB1cGRhdGVPbmUoYWNjLCBjaGFuZ2UpLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkT25lKHN0YXRlLCBlbnRpdHkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICAgIGlkczogWy4uLnN0YXRlLmlkcywgc2VsZWN0SWQoZW50aXR5KV0sXG4gICAgICBlbnRpdGllczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5lbnRpdGllcyksIHtcbiAgICAgICAgW3NlbGVjdElkKGVudGl0eSldOiBlbnRpdHlcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTWFueShzdGF0ZSwgZW50aXRpZXMpIHtcbiAgICByZXR1cm4gZW50aXRpZXMucmVkdWNlKChhY2MsIGVudGl0eSkgPT4gYWRkT25lKGFjYywgZW50aXR5KSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU9uZShzdGF0ZSwgaWRUb1JlbW92ZSkge1xuICAgIGNvbnN0IHVwZGF0ZWRFbnRpdGllcyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmVudGl0aWVzKTtcbiAgICBkZWxldGUgdXBkYXRlZEVudGl0aWVzW2lkVG9SZW1vdmVdO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgaWRzOiBzdGF0ZS5pZHMuZmlsdGVyKGlkID0+IGlkICE9PSBpZFRvUmVtb3ZlKSxcbiAgICAgIGVudGl0aWVzOiB1cGRhdGVkRW50aXRpZXNcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVNYW55KHN0YXRlLCBpZHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICAgIGlkczogc3RhdGUuaWRzLmZpbHRlcihpZCA9PiAhaWRzLmluY2x1ZGVzKGlkKSksXG4gICAgICBlbnRpdGllczogT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHN0YXRlLmVudGl0aWVzKS5maWx0ZXIoKFtpZF0pID0+ICFpZHMuaW5jbHVkZXMoaWQpKSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZU9uZSxcbiAgICB1cGRhdGVNYW55LFxuICAgIGFkZE9uZSxcbiAgICBhZGRNYW55LFxuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55XG4gIH07XG59XG5mdW5jdGlvbiBjb25uZWN0VG9DaHJvbWVFeHRlbnNpb24ob3B0aW9ucykge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZXh0ZW5zaW9uID0gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX187XG4gIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBleHRlbnNpb24uY29ubmVjdCh7XG4gICAgbmFtZTogb3B0aW9ucy5uYW1lXG4gIH0pO1xufVxuXG52YXIgZGV2QWN0aW9ucyA9IGNyZWF0ZUFjdGlvbkdyb3VwKCdkZXYnLCB7XG4gIGluaXQ6IHByb3BzKCksXG4gIHNldE1lc3NhZ2VzOiBwcm9wcygpLFxuICBzZW5kTWVzc2FnZTogcHJvcHMoKSxcbiAgcmVzZW5kTWVzc2FnZXM6IHByb3BzLFxuICB1cGRhdGVPcHRpb25zOiBwcm9wcygpLFxuICBzdG9wTWVzc2FnZUdlbmVyYXRpb246IHByb3BzKClcbn0pO1xuXG52YXIgYXBpQWN0aW9ucyA9IGNyZWF0ZUFjdGlvbkdyb3VwKCdhcGknLCB7XG4gIGdlbmVyYXRlTWVzc2FnZVN0YXJ0OiBlbXB0eVByb3BzKCksXG4gIGdlbmVyYXRlTWVzc2FnZUNodW5rOiBwcm9wcygpLFxuICBnZW5lcmF0ZU1lc3NhZ2VTdWNjZXNzOiBwcm9wcygpLFxuICBnZW5lcmF0ZU1lc3NhZ2VFcnJvcjogcHJvcHMoKSxcbiAgZ2VuZXJhdGVNZXNzYWdlRXhoYXVzdGVkUmV0cmllczogcHJvcHMoKVxufSk7XG5cbnZhciBpbnRlcm5hbEFjdGlvbnMgPSBjcmVhdGVBY3Rpb25Hcm91cCgnaW50ZXJuYWwnLCB7XG4gIHNpenpsZTogZW1wdHlQcm9wcygpLFxuICBydW5Ub29sQ2FsbHNTdWNjZXNzOiBwcm9wcygpLFxuICBydW5Ub29sQ2FsbHNFcnJvcjogcHJvcHMoKSxcbiAgc2tpcHBlZFRvb2xDYWxsczogZW1wdHlQcm9wcygpXG59KTtcblxuLyoqXG4gKiBTa2lsbGV0IGlzIGFuIExMTS1vcHRpbWl6ZWQgc3RyZWFtaW5nIEpTT04gUGFyc2VyIC0gcGVyZmVjdGx5IHN1aXRlZCBmb3Igc3RyZWFtaW5nIGhvdCBhbmQgZnJlc2ggSlNPTi5cbiAqXG4gKiBQb3J0aW9ucyBvZiB0aGlzIGNvZGUgYXJlIGRlcml2ZWQgZnJvbSBab2QgKE1JVCBMaWNlbnNlKSAoaHR0cHM6Ly9naXRodWIuY29tL2NvbGluaGFja3Mvem9kKS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGZ1bGwgbGljZW5zZSB0ZXh0LlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICogQGF1dGhvciBMaXZlTG92ZUFwcCwgTExDXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZlbG92ZWFwcC9oYXNoYnJvd25cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NvbGluaGFja3Mvem9kXG4gKi9cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IGludGVybmFsID0gJ35zY2hlbWEnO1xuY29uc3QgUFJJTUlUSVZFX1dSQVBQRVJfRklFTERfTkFNRSA9ICdfX3dyYXBwZWRQcmltaXRpdmUnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgSGFzaGJyb3duVHlwZUN0b3IgPSAoe1xuICBuYW1lLFxuICBpbml0aWFsaXplcixcbiAgdG9Kc29uU2NoZW1hSW1wbCxcbiAgcGFyc2VKc29uU2NoZW1hSW1wbCxcbiAgdG9UeXBlU2NyaXB0SW1wbCxcbiAgdmFsaWRhdGVJbXBsLFxuICB0b1N0cmVhbWluZ0ltcGxcbn0pID0+IHtcbiAgY2xhc3MgQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGRlZmluaXRpb24pIHtcbiAgICAgIENsYXNzLmluaXQodGhpcywgZGVmaW5pdGlvbik7XG4gICAgICB0aGlzLnRvSnNvblNjaGVtYUltcGwgPSB0b0pzb25TY2hlbWFJbXBsO1xuICAgICAgdGhpcy5wYXJzZUpzb25TY2hlbWFJbXBsID0gcGFyc2VKc29uU2NoZW1hSW1wbDtcbiAgICAgIHRoaXMudG9UeXBlU2NyaXB0SW1wbCA9IHRvVHlwZVNjcmlwdEltcGw7XG4gICAgICB0aGlzLnZhbGlkYXRlSW1wbCA9IHZhbGlkYXRlSW1wbDtcbiAgICAgIHRoaXMudG9TdHJlYW1pbmdJbXBsID0gdG9TdHJlYW1pbmdJbXBsO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdChpbnN0YW5jZSwgZGVmaW5pdGlvbikge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gaW5zdGFuY2VbaW50ZXJuYWxdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpbnN0YW5jZVtpbnRlcm5hbF0gPSB7XG4gICAgICAgIGRlZmluaXRpb246IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICAgICAgc3RyZWFtaW5nOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaW5pdGlhbGl6ZXIoaW5zdGFuY2UsIGRlZmluaXRpb24pO1xuICAgICAgaW5zdGFuY2VbaW50ZXJuYWxdLmRlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgIH1cbiAgICB0b0pzb25TY2hlbWEoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0pzb25TY2hlbWFJbXBsKHRoaXMpO1xuICAgIH1cbiAgICBwYXJzZUpzb25TY2hlbWEob2JqZWN0LCBwYXRoID0gW10pIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSnNvblNjaGVtYUltcGwodGhpcywgb2JqZWN0LCBwYXRoKTtcbiAgICB9XG4gICAgdG9UeXBlU2NyaXB0KHBhdGhTZWVuID0gbmV3IFNldCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1R5cGVTY3JpcHRJbXBsKHRoaXMsIHBhdGhTZWVuKTtcbiAgICB9XG4gICAgdmFsaWRhdGUob2JqZWN0LCBwYXRoID0gW10pIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlSW1wbCh0aGlzLCB0aGlzW2ludGVybmFsXS5kZWZpbml0aW9uLCBvYmplY3QsIHBhdGgpO1xuICAgIH1cbiAgICB0b1N0cmVhbWluZyhvYmplY3QsIHBhdGggPSBbXSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TdHJlYW1pbmdJbXBsKHRoaXMsIHRoaXNbaW50ZXJuYWxdLmRlZmluaXRpb24sIG9iamVjdCwgcGF0aCk7XG4gICAgfVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcywgJ25hbWUnLCB7XG4gICAgdmFsdWU6IG5hbWVcbiAgfSk7XG4gIHJldHVybiBDbGFzcztcbn07XG5jb25zdCBIYXNoYnJvd25UeXBlID0gSGFzaGJyb3duVHlwZUN0b3Ioe1xuICBuYW1lOiAnSGFzaGJyb3duVHlwZScsXG4gIGluaXRpYWxpemVyOiAoaW5zdCwgZGVmKSA9PiB7XG4gICAgaW5zdCAhPT0gbnVsbCAmJiBpbnN0ICE9PSB2b2lkIDAgPyBpbnN0IDogaW5zdCA9IHt9O1xuICAgIGluc3RbaW50ZXJuYWxdLmRlZmluaXRpb24gPSBkZWY7XG4gIH0sXG4gIHRvSnNvblNjaGVtYUltcGw6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHBhcnNlSnNvblNjaGVtYUltcGw6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHRvVHlwZVNjcmlwdEltcGw6ICgpID0+IHtcbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIHZhbGlkYXRlSW1wbDogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgdG9TdHJlYW1pbmdJbXBsOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9XG59KTtcbmNvbnN0IFN0cmluZ1R5cGUgPSBIYXNoYnJvd25UeXBlQ3Rvcih7XG4gIG5hbWU6ICdTdHJpbmcnLFxuICBpbml0aWFsaXplcjogKGluc3QsIGRlZikgPT4ge1xuICAgIEhhc2hicm93blR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICB9LFxuICB0b0pzb25TY2hlbWFJbXBsOiBzY2hlbWEgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24uZGVzY3JpcHRpb25cbiAgICB9O1xuICB9LFxuICBwYXJzZUpzb25TY2hlbWFJbXBsOiAoc2NoZW1hLCBvYmplY3QsIHBhdGgpID0+IHtcbiAgICAvLyBJcyB0aGlzIGEgd3JhcHBlZCBwcmltaXRpdmU/XG4gICAgaWYgKG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKG9iamVjdCkuaW5jbHVkZXMoUFJJTUlUSVZFX1dSQVBQRVJfRklFTERfTkFNRSkpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFtQUklNSVRJVkVfV1JBUFBFUl9GSUVMRF9OQU1FXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nIGF0OiAke3BhdGguam9pbignLicpfSwgZ290ICR7b2JqZWN0fWApO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG4gIHRvVHlwZVNjcmlwdEltcGw6IHNjaGVtYSA9PiB7XG4gICAgcmV0dXJuIGAvKiAke3NjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5kZXNjcmlwdGlvbn0gKi8gc3RyaW5nYDtcbiAgfSxcbiAgdmFsaWRhdGVJbXBsOiAoc2NoZW1hLCBkZWZpbml0aW9uLCBvYmplY3QsIHBhdGgpID0+IHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmcgYXQ6ICR7cGF0aC5qb2luKCcuJyl9LCBnb3QgJHt0eXBlb2Ygb2JqZWN0fWApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0sXG4gIHRvU3RyZWFtaW5nSW1wbDogKHNjaGVtYSwgZGVmaW5pdGlvbiwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxufSk7XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmdUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVbaW50ZXJuYWxdLmRlZmluaXRpb24udHlwZSA9PT0gJ3N0cmluZyc7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc3RyaW5nJDEoZGVzY3JpcHRpb24pIHtcbiAgcmV0dXJuIG5ldyBTdHJpbmdUeXBlKHtcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBzdHJlYW1pbmc6IGZhbHNlXG4gIH0pO1xufVxuY29uc3QgTGl0ZXJhbFR5cGUgPSBIYXNoYnJvd25UeXBlQ3Rvcih7XG4gIG5hbWU6ICdMaXRlcmFsJyxcbiAgaW5pdGlhbGl6ZXI6IChpbnN0LCBkZWYpID0+IHtcbiAgICBIYXNoYnJvd25UeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgfSxcbiAgdG9Kc29uU2NoZW1hSW1wbDogc2NoZW1hID0+IHtcbiAgICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBzY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24udmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IGlzTnVtYmVyID0gdHlwZW9mIHNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi52YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgdHlwZW9mIHNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi52YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBpc1N0cmluZyA/ICdzdHJpbmcnIDogaXNOdW1iZXIgPyAnbnVtYmVyJyA6ICdib29sZWFuJyxcbiAgICAgIGNvbnN0OiBzY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24udmFsdWUsXG4gICAgICBkZXNjcmlwdGlvbjogc2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLmRlc2NyaXB0aW9uXG4gICAgfTtcbiAgfSxcbiAgcGFyc2VKc29uU2NoZW1hSW1wbDogKHNjaGVtYSwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgLy8gSXMgdGhpcyBhIHdyYXBwZWQgcHJpbWl0aXZlP1xuICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhvYmplY3QpLmluY2x1ZGVzKFBSSU1JVElWRV9XUkFQUEVSX0ZJRUxEX05BTUUpKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbUFJJTUlUSVZFX1dSQVBQRVJfRklFTERfTkFNRV07XG4gICAgfVxuICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZyc7XG4gICAgY29uc3QgaXNOdW1iZXIgPSB0eXBlb2Ygb2JqZWN0ID09PSAnbnVtYmVyJztcbiAgICBjb25zdCBpc0Jvb2xlYW4gPSB0eXBlb2Ygb2JqZWN0ID09PSAnYm9vbGVhbic7XG4gICAgaWYgKCFpc1N0cmluZyAmJiAhaXNOdW1iZXIgJiYgIWlzQm9vbGVhbikgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHN0cmluZywgbnVtYmVyLCBvciBib29sZWFuIGF0OiAke3BhdGguam9pbignLicpfSwgZ290ICR7b2JqZWN0fSwgcmVjZWl2ZWQgJHtzY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24udmFsdWV9YCk7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSxcbiAgdG9UeXBlU2NyaXB0SW1wbDogc2NoZW1hID0+IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLnZhbHVlKTtcbiAgfSxcbiAgdmFsaWRhdGVJbXBsOiAoc2NoZW1hLCBkZWZpbml0aW9uLCBvYmplY3QsIHBhdGgpID0+IHtcbiAgICBpZiAoZGVmaW5pdGlvbi52YWx1ZSAhPT0gb2JqZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHRoZSBsaXRlcmFsIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkoZGVmaW5pdGlvbi52YWx1ZSl9IGF0OiAke3BhdGguam9pbignLicpfSwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KG9iamVjdCl9YCk7XG4gICAgfVxuICB9LFxuICB0b1N0cmVhbWluZ0ltcGw6IChzY2hlbWEsIGRlZmluaXRpb24sIG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbn0pO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzTGl0ZXJhbFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZVtpbnRlcm5hbF0uZGVmaW5pdGlvbi50eXBlID09PSAnbGl0ZXJhbCc7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZSkge1xuICByZXR1cm4gbmV3IExpdGVyYWxUeXBlKHtcbiAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgZGVzY3JpcHRpb246IGAke3ZhbHVlfWAsXG4gICAgdmFsdWUsXG4gICAgc3RyZWFtaW5nOiBmYWxzZVxuICB9KTtcbn1cbmNvbnN0IE51bWJlclR5cGUgPSBIYXNoYnJvd25UeXBlQ3Rvcih7XG4gIG5hbWU6ICdOdW1iZXInLFxuICBpbml0aWFsaXplcjogKGluc3QsIGRlZikgPT4ge1xuICAgIEhhc2hicm93blR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICB9LFxuICB0b0pzb25TY2hlbWFJbXBsOiBzY2hlbWEgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24uZGVzY3JpcHRpb25cbiAgICB9O1xuICB9LFxuICBwYXJzZUpzb25TY2hlbWFJbXBsOiAoc2NoZW1hLCBvYmplY3QsIHBhdGgpID0+IHtcbiAgICAvLyBJcyB0aGlzIGEgd3JhcHBlZCBwcmltaXRpdmU/XG4gICAgaWYgKG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKG9iamVjdCkuaW5jbHVkZXMoUFJJTUlUSVZFX1dSQVBQRVJfRklFTERfTkFNRSkpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFtQUklNSVRJVkVfV1JBUFBFUl9GSUVMRF9OQU1FXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyIGF0OiAke3BhdGguam9pbignLicpfWApO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG4gIHRvVHlwZVNjcmlwdEltcGw6IHNjaGVtYSA9PiB7XG4gICAgcmV0dXJuIGAvKiAke3NjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5kZXNjcmlwdGlvbn0gKi8gbnVtYmVyYDtcbiAgfSxcbiAgdmFsaWRhdGVJbXBsOiAoc2NoZW1hLCBkZWZpbml0aW9uLCBvYmplY3QsIHBhdGgpID0+IHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXIgYXQ6ICR7cGF0aC5qb2luKCcuJyl9YCk7XG4gICAgfVxuICB9LFxuICB0b1N0cmVhbWluZ0ltcGw6IChzY2hlbWEsIGRlZmluaXRpb24sIG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbn0pO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlW2ludGVybmFsXS5kZWZpbml0aW9uLnR5cGUgPT09ICdudW1iZXInO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIG51bWJlcihkZXNjcmlwdGlvbikge1xuICByZXR1cm4gbmV3IE51bWJlclR5cGUoe1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIHN0cmVhbWluZzogZmFsc2VcbiAgfSk7XG59XG5jb25zdCBCb29sZWFuVHlwZSA9IEhhc2hicm93blR5cGVDdG9yKHtcbiAgbmFtZTogJ0Jvb2xlYW4nLFxuICBpbml0aWFsaXplcjogKGluc3QsIGRlZikgPT4ge1xuICAgIEhhc2hicm93blR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICB9LFxuICB0b0pzb25TY2hlbWFJbXBsOiBzY2hlbWEgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZXNjcmlwdGlvbjogc2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLmRlc2NyaXB0aW9uXG4gICAgfTtcbiAgfSxcbiAgcGFyc2VKc29uU2NoZW1hSW1wbDogKHNjaGVtYSwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgLy8gSXMgdGhpcyBhIHdyYXBwZWQgcHJpbWl0aXZlP1xuICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhvYmplY3QpLmluY2x1ZGVzKFBSSU1JVElWRV9XUkFQUEVSX0ZJRUxEX05BTUUpKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbUFJJTUlUSVZFX1dSQVBQRVJfRklFTERfTkFNRV07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBib29sZWFuIGF0OiAke3BhdGguam9pbignLicpfWApO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG4gIHRvVHlwZVNjcmlwdEltcGw6IHNjaGVtYSA9PiB7XG4gICAgcmV0dXJuIGAvKiAke3NjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5kZXNjcmlwdGlvbn0gKi8gYm9vbGVhbmA7XG4gIH0sXG4gIHZhbGlkYXRlSW1wbDogKHNjaGVtYSwgZGVmaW5pdGlvbiwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdib29sZWFuJykgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGJvb2xlYW4gYXQ6ICR7cGF0aC5qb2luKCcuJyl9YCk7XG4gIH0sXG4gIHRvU3RyZWFtaW5nSW1wbDogKHNjaGVtYSwgZGVmaW5pdGlvbiwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxufSk7XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlW2ludGVybmFsXS5kZWZpbml0aW9uLnR5cGUgPT09ICdib29sZWFuJztcbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBib29sZWFuKGRlc2NyaXB0aW9uKSB7XG4gIHJldHVybiBuZXcgQm9vbGVhblR5cGUoe1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBzdHJlYW1pbmc6IGZhbHNlXG4gIH0pO1xufVxuY29uc3QgSW50ZWdlclR5cGUgPSBIYXNoYnJvd25UeXBlQ3Rvcih7XG4gIG5hbWU6ICdJbnRlZ2VyJyxcbiAgaW5pdGlhbGl6ZXI6IChpbnN0LCBkZWYpID0+IHtcbiAgICBIYXNoYnJvd25UeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgfSxcbiAgdG9Kc29uU2NoZW1hSW1wbDogc2NoZW1hID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVzY3JpcHRpb246IHNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5kZXNjcmlwdGlvblxuICAgIH07XG4gIH0sXG4gIHBhcnNlSnNvblNjaGVtYUltcGw6IChzY2hlbWEsIG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIC8vIElzIHRoaXMgYSB3cmFwcGVkIHByaW1pdGl2ZT9cbiAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMob2JqZWN0KS5pbmNsdWRlcyhQUklNSVRJVkVfV1JBUFBFUl9GSUVMRF9OQU1FKSkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0W1BSSU1JVElWRV9XUkFQUEVSX0ZJRUxEX05BTUVdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXIgYXQ6ICR7cGF0aC5qb2luKCcuJyl9YCk7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG9iamVjdCkpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gaW50ZWdlciBhdDogJHtwYXRoLmpvaW4oJy4nKX1gKTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuICB0b1R5cGVTY3JpcHRJbXBsOiBzY2hlbWEgPT4ge1xuICAgIHJldHVybiBgLyogJHtzY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24uZGVzY3JpcHRpb259ICovIGludGVnZXJgO1xuICB9LFxuICB2YWxpZGF0ZUltcGw6IChzY2hlbWEsIGRlZmluaXRpb24sIG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlciBhdDogJHtwYXRoLmpvaW4oJy4nKX1gKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob2JqZWN0KSkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiBpbnRlZ2VyIGF0OiAke3BhdGguam9pbignLicpfWApO1xuICB9LFxuICB0b1N0cmVhbWluZ0ltcGw6IChzY2hlbWEsIGRlZmluaXRpb24sIG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbn0pO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZWdlclR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZVtpbnRlcm5hbF0uZGVmaW5pdGlvbi50eXBlID09PSAnaW50ZWdlcic7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaW50ZWdlcihkZXNjcmlwdGlvbikge1xuICByZXR1cm4gbmV3IEludGVnZXJUeXBlKHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgc3RyZWFtaW5nOiBmYWxzZVxuICB9KTtcbn1cbmNvbnN0IE9iamVjdFR5cGUgPSBIYXNoYnJvd25UeXBlQ3Rvcih7XG4gIG5hbWU6ICdPYmplY3QnLFxuICBpbml0aWFsaXplcjogKGluc3QsIGRlZikgPT4ge1xuICAgIEhhc2hicm93blR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICB9LFxuICB0b0pzb25TY2hlbWFJbXBsOiBzY2hlbWEgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIC8vIFByb3BlcnRpZXMgaXMgcG9wdWxhdGVkIGV4dGVybmFsbHkgYmVjYXVzZSB3ZSBuZWVkIHRvIGZpbmQgbG9vcHNcbiAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgcmVxdWlyZWQ6IE9iamVjdC5rZXlzKHNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5zaGFwZSksXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogc2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLmRlc2NyaXB0aW9uXG4gICAgfTtcbiAgfSxcbiAgcGFyc2VKc29uU2NoZW1hSW1wbDogKHNjaGVtYSwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnIHx8IG9iamVjdCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiBvYmplY3QgYXQ6ICR7cGF0aC5qb2luKCcuJyl9YCk7XG4gICAgY29uc3Qge1xuICAgICAgc2hhcGVcbiAgICB9ID0gc2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uO1xuICAgIE9iamVjdC5lbnRyaWVzKHNoYXBlKS5mb3JFYWNoKChba2V5LCBjaGlsZF0pID0+IHtcbiAgICAgIC8vIEFueU9mIHVud3JhcHBpbmcgY2FuIGNoYW5nZSB0aGUgZGVzaXJlZCBmb3JtIG9mIHRoZSByZXN1bHQgb2JqZWN0LCBzb1xuICAgICAgLy8gdXBkYXRlIHRoZSBvYmplY3QgYXMgd2UgcGFyc2VcbiAgICAgIG9iamVjdFtrZXldID0gY2hpbGQucGFyc2VKc29uU2NoZW1hKG9iamVjdFtrZXldLCBbLi4ucGF0aCwga2V5XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSxcbiAgdG9UeXBlU2NyaXB0SW1wbDogKHNjaGVtYSwgcGF0aFNlZW4pID0+IHtcbiAgICBpZiAocGF0aFNlZW4uaGFzKHNjaGVtYSkpIHtcbiAgICAgIGNvbnN0IGRlc2MgPSBzY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24uZGVzY3JpcHRpb24gfHwgJzxhbm9ueW1vdXM+JztcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ3ljbGUgZGV0ZWN0ZWQgaW4gc2NoZW1hIGF0IFwiJHtkZXNjfVwiYCk7XG4gICAgfVxuICAgIHBhdGhTZWVuLmFkZChzY2hlbWEpO1xuICAgIGNvbnN0IGRlcHRoID0gcGF0aFNlZW4uc2l6ZSAtIDE7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5zaGFwZSk7XG4gICAgY29uc3QgbGluZXMgPSBlbnRyaWVzLm1hcCgoW2tleSwgY2hpbGRdKSA9PiB7XG4gICAgICAvLyBjbG9uZSBwYXRoU2VlbiBmb3IgZWFjaCBicmFuY2hcbiAgICAgIHJldHVybiBgJHsnICcucmVwZWF0KGRlcHRoICsgMil9JHtrZXl9OiAke2NoaWxkLnRvVHlwZVNjcmlwdChuZXcgU2V0KHBhdGhTZWVuKSl9O2A7XG4gICAgfSk7XG4gICAgcmV0dXJuIGAvKiAke3NjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5kZXNjcmlwdGlvbn0gKi8ge1xuJHtsaW5lcy5qb2luKCdcXG4nKX1cbiR7JyAnLnJlcGVhdChkZXB0aCl9fWA7XG4gIH0sXG4gIHZhbGlkYXRlSW1wbDogKHNjaGVtYSwgZGVmaW5pdGlvbiwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnIHx8IG9iamVjdCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiBvYmplY3QgYXQ6ICR7cGF0aC5qb2luKCcuJyl9YCk7XG4gICAgY29uc3Qge1xuICAgICAgc2hhcGVcbiAgICB9ID0gZGVmaW5pdGlvbjtcbiAgICBPYmplY3QuZW50cmllcyhzaGFwZSkuZm9yRWFjaCgoW2tleSwgY2hpbGRdKSA9PiB7XG4gICAgICBjaGlsZC52YWxpZGF0ZShvYmplY3Rba2V5XSwgWy4uLnBhdGgsIGtleV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG4gIHRvU3RyZWFtaW5nSW1wbDogKHNjaGVtYSwgZGVmaW5pdGlvbiwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc2hhcGVcbiAgICB9ID0gZGVmaW5pdGlvbjtcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoc2hhcGUpO1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgcmV0dXJuIFtrZXksIHZhbHVlLnRvU3RyZWFtaW5nKG9iamVjdFtrZXldLCBbLi4ucGF0aCwga2V5XSldO1xuICAgIH0pKTtcbiAgfVxufSk7XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVbaW50ZXJuYWxdLmRlZmluaXRpb24udHlwZSA9PT0gJ29iamVjdCc7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gb2JqZWN0JDEoZGVzY3JpcHRpb24sIHNoYXBlKSB7XG4gIHJldHVybiBuZXcgT2JqZWN0VHlwZSh7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgc3RyZWFtaW5nOiBmYWxzZSxcbiAgICBzaGFwZVxuICB9KTtcbn1cbmNvbnN0IEFycmF5VHlwZSA9IEhhc2hicm93blR5cGVDdG9yKHtcbiAgbmFtZTogJ0FycmF5JyxcbiAgaW5pdGlhbGl6ZXI6IChpbnN0LCBkZWYpID0+IHtcbiAgICBIYXNoYnJvd25UeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgfSxcbiAgdG9Kc29uU2NoZW1hSW1wbDogc2NoZW1hID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIC8vIGl0ZW1zIGlzIHBvcHVsYXRlZCBleHRlcm5hbGx5IHNpbmNlIHdlIGZpbmQgbG9vcHMgYW5kIGR1cGxpY2F0ZWQgc2VjdGlvbnNcbiAgICAgIC8vIHRocm91Z2ggdGhlIHdob2xlIHNjaGVtYVxuICAgICAgaXRlbXM6IFtdLFxuICAgICAgZGVzY3JpcHRpb246IHNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5kZXNjcmlwdGlvblxuICAgIH07XG4gIH0sXG4gIHBhcnNlSnNvblNjaGVtYUltcGw6IChzY2hlbWEsIG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIC8vIElzIHRoaXMgYSB3cmFwcGVkIHByaW1pdGl2ZT9cbiAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMob2JqZWN0KS5pbmNsdWRlcyhQUklNSVRJVkVfV1JBUFBFUl9GSUVMRF9OQU1FKSkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0W1BSSU1JVElWRV9XUkFQUEVSX0ZJRUxEX05BTUVdO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0KSkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiBhcnJheSBhdDogJHtwYXRoLmpvaW4oJy4nKX1gKTtcbiAgICAvLyBBbnlPZiB1bndyYXBwaW5nIGNhbiBjaGFuZ2UgdGhlIGRlc2lyZWQgZm9ybSBvZiB0aGUgcmVzdWx0IG9iamVjdCwgc29cbiAgICAvLyB1cGRhdGUgdGhlIG9iamVjdCBhcyB3ZSBwYXJzZVxuICAgIG9iamVjdC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaXRlbSA9IHNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5lbGVtZW50LnBhcnNlSnNvblNjaGVtYShpdGVtLCBwYXRoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuICB0b1R5cGVTY3JpcHRJbXBsOiAoc2NoZW1hLCBwYXRoU2VlbikgPT4ge1xuICAgIGlmIChwYXRoU2Vlbi5oYXMoc2NoZW1hKSkge1xuICAgICAgY29uc3QgZGVzYyA9IHNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5kZXNjcmlwdGlvbiB8fCAnPGFub255bW91cz4nO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDeWNsZSBkZXRlY3RlZCBpbiBzY2hlbWEgYXQgXCIke2Rlc2N9XCJgKTtcbiAgICB9XG4gICAgcGF0aFNlZW4uYWRkKHNjaGVtYSk7XG4gICAgcmV0dXJuIGAvKiAke3NjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5kZXNjcmlwdGlvbn0gKi8gQXJyYXk8JHtzY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24uZWxlbWVudC50b1R5cGVTY3JpcHQobmV3IFNldChwYXRoU2VlbikpfT5gO1xuICB9LFxuICB2YWxpZGF0ZUltcGw6IChzY2hlbWEsIGRlZmluaXRpb24sIG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIGFycmF5IGF0OiAke3BhdGguam9pbignLicpfWApO1xuICAgIG9iamVjdC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgZGVmaW5pdGlvbi5lbGVtZW50LnZhbGlkYXRlKGl0ZW0sIHBhdGgpO1xuICAgIH0pO1xuICB9LFxuICB0b1N0cmVhbWluZ0ltcGw6IChzY2hlbWEsIGRlZmluaXRpb24sIG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIHJldHVybiBvYmplY3QubWFwKGl0ZW0gPT4ge1xuICAgICAgcmV0dXJuIGRlZmluaXRpb24uZWxlbWVudC50b1N0cmVhbWluZyhpdGVtLCBwYXRoKTtcbiAgICB9KTtcbiAgfVxufSk7XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNBcnJheVR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZVtpbnRlcm5hbF0uZGVmaW5pdGlvbi50eXBlID09PSAnYXJyYXknO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGFycmF5JDEoZGVzY3JpcHRpb24sIGl0ZW0pIHtcbiAgcmV0dXJuIG5ldyBBcnJheVR5cGUoe1xuICAgIHR5cGU6ICdhcnJheScsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgc3RyZWFtaW5nOiBmYWxzZSxcbiAgICBlbGVtZW50OiBpdGVtXG4gIH0pO1xufVxuY29uc3QgQW55T2ZUeXBlID0gSGFzaGJyb3duVHlwZUN0b3Ioe1xuICBuYW1lOiAnQW55T2ZUeXBlJyxcbiAgaW5pdGlhbGl6ZXI6IChpbnN0LCBkZWYpID0+IHtcbiAgICBIYXNoYnJvd25UeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgfSxcbiAgdG9Kc29uU2NoZW1hSW1wbDogc2NoZW1hID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgYW55T2Y6IFtdXG4gICAgfTtcbiAgfSxcbiAgcGFyc2VKc29uU2NoZW1hSW1wbDogKHNjaGVtYSwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5vcHRpb25zO1xuICAgIGxldCBwYXJzZWRPYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgYnVpbGREaXNjcmltaW5hdG9yTWFwID0gb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0IG9mIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdFR5cGUob3B0KSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNoYXBlID0gb3B0W2ludGVybmFsXS5kZWZpbml0aW9uLnNoYXBlO1xuICAgICAgICBjb25zdCBsaXRlcmFsRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHNoYXBlKS5maWx0ZXIoKFssIHZdKSA9PiBpc0xpdGVyYWxUeXBlKHYpKTtcbiAgICAgICAgLy8gUmVxdWlyZSBleGFjdGx5IG9uZSBsaXRlcmFsIGZvciBjbGVhciBkaXNjcmltaW5hdGlvblxuICAgICAgICBpZiAobGl0ZXJhbEVudHJpZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2xpdGVyYWxLZXksIGxpdFNjaGVtYV0gPSBsaXRlcmFsRW50cmllc1swXTtcbiAgICAgICAgY29uc3QgbGl0ZXJhbFZhbHVlID0gbGl0U2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGxpdGVyYWxWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBPbmx5IHN1cHBvcnQgc3RyaW5nLWJhc2VkIGRpc2NyaW1pbmF0b3JzIGZvciB3cmFwcGVyIGtleXNcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgbGl0ZXJhbFZhbHVlKSkge1xuICAgICAgICAgIC8vIEFtYmlndW91cyAoZHVwbGljYXRlKSBkaXNjcmltaW5hdG9yIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbWFwW2xpdGVyYWxWYWx1ZV0gPSB7XG4gICAgICAgICAgc2NoZW1hOiBvcHQsXG4gICAgICAgICAgbGl0ZXJhbEtleSxcbiAgICAgICAgICBsaXRlcmFsVmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtYXApLmxlbmd0aCA9PT0gb3B0aW9ucy5sZW5ndGggPyBtYXAgOiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgZGlzY3JpbWluYXRvck1hcCA9IGJ1aWxkRGlzY3JpbWluYXRvck1hcChvcHRpb25zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChuZWVkc0Rpc2NyaW1pbmF0b3JXcmFwcGVySW5BbnlPZihvcHRpb25zW2ldKSAmJiBkaXNjcmltaW5hdG9yTWFwKSB7XG4gICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvckVudHJ5ID0gT2JqZWN0LmVudHJpZXMoZGlzY3JpbWluYXRvck1hcCkuZmluZCgoWywgdl0pID0+IHYuc2NoZW1hID09PSBvcHRpb25zW2ldKTtcbiAgICAgICAgICBpZiAoIWRpc2NyaW1pbmF0b3JFbnRyeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkaXNjcmltaW5hdG9yIGtleSBmb3VuZCBmb3Igb3B0aW9uICR7b3B0aW9uc1tpXX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGl0ZXJhbEtleSxcbiAgICAgICAgICAgIGxpdGVyYWxWYWx1ZSxcbiAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgIH0gPSBkaXNjcmltaW5hdG9yRW50cnlbMV07XG4gICAgICAgICAgY29uc3QgZXh0cmFjdGVkT2JqZWN0ID0gb2JqZWN0W2xpdGVyYWxWYWx1ZV07XG4gICAgICAgICAgZXh0cmFjdGVkT2JqZWN0W2xpdGVyYWxLZXldID0gbGl0ZXJhbFZhbHVlO1xuICAgICAgICAgIHBhcnNlZE9iamVjdCA9IHNjaGVtYS5wYXJzZUpzb25TY2hlbWEoZXh0cmFjdGVkT2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChuZWVkc0Rpc2NyaW1pbmF0b3JXcmFwcGVySW5BbnlPZihvcHRpb25zW2ldKSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JyB8fCBvYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gb2JqZWN0IGF0OiAke3BhdGguam9pbignLicpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhbnlPZktleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgICAgIGlmIChhbnlPZktleXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBhbnlPZiB3cmFwcGVyIGF0ICR7cGF0aC5qb2luKCcuJyl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFueU9mSW5kZXggPSBhbnlPZktleXNbMF07XG4gICAgICAgICAgaWYgKGFueU9mSW5kZXggIT09IGkudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGRpc2NyaW1pbmF0b3IgdmFsdWUgJHthbnlPZkluZGV4fSBmb3Igb3B0aW9uICR7aX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyc2VkT2JqZWN0ID0gb3B0aW9uc1tpXS5wYXJzZUpzb25TY2hlbWEob2JqZWN0W2FueU9mSW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZWRPYmplY3QgPSBvcHRpb25zW2ldLnBhcnNlSnNvblNjaGVtYShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgLy8gUGFyc2luZyBmYWlsZWQsIGJ1dCB0aGF0IGlzIG5vdCB1bmV4cGVjdGVkIGR1ZSB0byB0aGUgbG9vcGluZy5cbiAgICAgICAgLy8gSnVzdCB0cnkgdGhlIG5leHQgb3B0aW9uLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnNlZE9iamVjdCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFsbCBvcHRpb25zIGluIGFueU9mIGZhaWxlZCBwYXJzaW5nIGF0OiAke3BhdGguam9pbignLicpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkT2JqZWN0O1xuICB9LFxuICB0b1R5cGVTY3JpcHRJbXBsOiAoc2NoZW1hLCBwYXRoU2VlbikgPT4ge1xuICAgIGlmIChwYXRoU2Vlbi5oYXMoc2NoZW1hKSkge1xuICAgICAgY29uc3QgZGVzYyA9IHNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5kZXNjcmlwdGlvbiB8fCAnPGFub255bW91cz4nO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDeWNsZSBkZXRlY3RlZCBpbiBzY2hlbWEgYXQgXCIke2Rlc2N9XCJgKTtcbiAgICB9XG4gICAgcGF0aFNlZW4uYWRkKHNjaGVtYSk7XG4gICAgcmV0dXJuIGAvKiAke3NjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5kZXNjcmlwdGlvbn0gKi8gKCR7c2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLm9wdGlvbnMubWFwKG9wdCA9PiBvcHQudG9UeXBlU2NyaXB0KG5ldyBTZXQocGF0aFNlZW4pKSkuam9pbignIHwgJyl9KWA7XG4gIH0sXG4gIHZhbGlkYXRlSW1wbDogKHNjaGVtYSwgZGVmaW5pdGlvbiwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3B0aW9uc1xuICAgIH0gPSBkZWZpbml0aW9uO1xuICAgIGxldCBmb3VuZE1hdGNoID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBvcHRpb25zW2ldLnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgIGZvdW5kTWF0Y2ggPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coZSk7XG4gICAgICAgIC8vIFBhcnNpbmcgZmFpbGVkLCBidXQgdGhhdCBpcyBub3QgdW5leHBlY3RlZCBkdWUgdG8gdGhlIGxvb3BpbmcuXG4gICAgICAgIC8vIEp1c3QgdHJ5IHRoZSBuZXh0IG9wdGlvbi5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmRNYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbGwgb3B0aW9ucyBpbiBhbnlPZiBmYWlsZWQgcGFyc2luZyBhdDogJHtwYXRoLmpvaW4oJy4nKX1gKTtcbiAgICB9XG4gIH0sXG4gIHRvU3RyZWFtaW5nSW1wbDogKHNjaGVtYSwgZGVmaW5pdGlvbiwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hpbmdPcHRpb24gPSBkZWZpbml0aW9uLm9wdGlvbnMuZmluZChvcHQgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3B0LnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYnVpbGREaXNjcmltaW5hdG9yTWFwID0gb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0IG9mIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdFR5cGUob3B0KSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNoYXBlID0gb3B0W2ludGVybmFsXS5kZWZpbml0aW9uLnNoYXBlO1xuICAgICAgICBjb25zdCBsaXRlcmFsRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHNoYXBlKS5maWx0ZXIoKFssIHZdKSA9PiBpc0xpdGVyYWxUeXBlKHYpKTtcbiAgICAgICAgLy8gUmVxdWlyZSBleGFjdGx5IG9uZSBsaXRlcmFsIGZvciBjbGVhciBkaXNjcmltaW5hdGlvblxuICAgICAgICBpZiAobGl0ZXJhbEVudHJpZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2xpdGVyYWxLZXksIGxpdFNjaGVtYV0gPSBsaXRlcmFsRW50cmllc1swXTtcbiAgICAgICAgY29uc3QgbGl0ZXJhbFZhbHVlID0gbGl0U2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGxpdGVyYWxWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBPbmx5IHN1cHBvcnQgc3RyaW5nLWJhc2VkIGRpc2NyaW1pbmF0b3JzIGZvciB3cmFwcGVyIGtleXNcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgbGl0ZXJhbFZhbHVlKSkge1xuICAgICAgICAgIC8vIEFtYmlndW91cyAoZHVwbGljYXRlKSBkaXNjcmltaW5hdG9yIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbWFwW2xpdGVyYWxWYWx1ZV0gPSB7XG4gICAgICAgICAgc2NoZW1hOiBvcHQsXG4gICAgICAgICAgbGl0ZXJhbEtleSxcbiAgICAgICAgICBsaXRlcmFsVmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtYXApLmxlbmd0aCA9PT0gb3B0aW9ucy5sZW5ndGggPyBtYXAgOiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgZGlzY3JpbWluYXRvck1hcCA9IGJ1aWxkRGlzY3JpbWluYXRvck1hcChkZWZpbml0aW9uLm9wdGlvbnMpO1xuICAgIGlmICghbWF0Y2hpbmdPcHRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGluIGFueU9mIGF0OiAke3BhdGguam9pbignLicpfWApO1xuICAgIH1cbiAgICBpZiAobmVlZHNEaXNjcmltaW5hdG9yV3JhcHBlckluQW55T2YobWF0Y2hpbmdPcHRpb24pICYmIGRpc2NyaW1pbmF0b3JNYXApIHtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JFbnRyeSA9IE9iamVjdC5lbnRyaWVzKGRpc2NyaW1pbmF0b3JNYXApLmZpbmQoKFssIHZdKSA9PiB2LnNjaGVtYSA9PT0gbWF0Y2hpbmdPcHRpb24pO1xuICAgICAgaWYgKCFkaXNjcmltaW5hdG9yRW50cnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkaXNjcmltaW5hdG9yIGtleSBmb3VuZCBmb3Igb3B0aW9uICR7bWF0Y2hpbmdPcHRpb259YCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpdGVyYWxLZXksXG4gICAgICAgIGxpdGVyYWxWYWx1ZSxcbiAgICAgICAgc2NoZW1hXG4gICAgICB9ID0gZGlzY3JpbWluYXRvckVudHJ5WzFdO1xuICAgICAgY29uc3Qgc3RyZWFtaW5nT2JqZWN0ID0gc2NoZW1hLnRvU3RyZWFtaW5nKG9iamVjdCwgcGF0aCk7XG4gICAgICBkZWxldGUgc3RyZWFtaW5nT2JqZWN0W2xpdGVyYWxLZXldO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2xpdGVyYWxWYWx1ZV06IHN0cmVhbWluZ09iamVjdFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG5lZWRzRGlzY3JpbWluYXRvcldyYXBwZXJJbkFueU9mKG1hdGNoaW5nT3B0aW9uKSAmJiAhZGlzY3JpbWluYXRvck1hcCkge1xuICAgICAgY29uc3QgaW5kZXhPZk1hdGNoaW5nT3B0aW9uID0gZGVmaW5pdGlvbi5vcHRpb25zLmluZGV4T2YobWF0Y2hpbmdPcHRpb24pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2luZGV4T2ZNYXRjaGluZ09wdGlvbi50b1N0cmluZygpXTogbWF0Y2hpbmdPcHRpb24udG9TdHJlYW1pbmcob2JqZWN0LCBwYXRoKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoaW5nT3B0aW9uLnRvU3RyZWFtaW5nKG9iamVjdCwgcGF0aCk7XG4gIH1cbn0pO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzQW55T2ZUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVbaW50ZXJuYWxdLmRlZmluaXRpb24udHlwZSA9PT0gJ2FueS1vZic7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gYW55T2Yob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEFueU9mVHlwZSh7XG4gICAgdHlwZTogJ2FueS1vZicsXG4gICAgZGVzY3JpcHRpb246ICdhbnktb2YnLFxuICAgIG9wdGlvbnMsXG4gICAgc3RyZWFtaW5nOiBmYWxzZVxuICB9KTtcbn1cbmNvbnN0IEVudW1UeXBlID0gSGFzaGJyb3duVHlwZUN0b3Ioe1xuICBuYW1lOiAnRW51bScsXG4gIGluaXRpYWxpemVyOiAoaW5zdCwgZGVmKSA9PiB7XG4gICAgSGFzaGJyb3duVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIH0sXG4gIHRvSnNvblNjaGVtYUltcGw6IHNjaGVtYSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogc2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLmVudHJpZXMsXG4gICAgICBkZXNjcmlwdGlvbjogc2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLmRlc2NyaXB0aW9uXG4gICAgfTtcbiAgfSxcbiAgcGFyc2VKc29uU2NoZW1hSW1wbDogKHNjaGVtYSwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgLy8gSXMgdGhpcyBhIHdyYXBwZWQgcHJpbWl0aXZlP1xuICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhvYmplY3QpLmluY2x1ZGVzKFBSSU1JVElWRV9XUkFQUEVSX0ZJRUxEX05BTUUpKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbUFJJTUlUSVZFX1dSQVBQRVJfRklFTERfTkFNRV07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHN0cmluZyBhdDogJHtwYXRoLmpvaW4oJy4nKX1gKTtcbiAgICBpZiAoIXNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5lbnRyaWVzLmluY2x1ZGVzKG9iamVjdCkpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gZW51bSB2YWx1ZSBhdDogJHtwYXRoLmpvaW4oJy4nKX1gKTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuICB0b1R5cGVTY3JpcHRJbXBsOiBzY2hlbWEgPT4ge1xuICAgIHJldHVybiBzY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24uZW50cmllcy5tYXAoZSA9PiBgXCIke2V9XCJgKS5qb2luKCcgfCAnKTtcbiAgfSxcbiAgdmFsaWRhdGVJbXBsOiAoc2NoZW1hLCBkZWZpbml0aW9uLCBvYmplY3QsIHBhdGgpID0+IHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmcgYXQ6ICR7cGF0aC5qb2luKCcuJyl9YCk7XG4gICAgaWYgKCFkZWZpbml0aW9uLmVudHJpZXMuaW5jbHVkZXMob2JqZWN0KSkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiBlbnVtIHZhbHVlIGF0OiAke3BhdGguam9pbignLicpfWApO1xuICB9LFxuICB0b1N0cmVhbWluZ0ltcGw6IChzY2hlbWEsIGRlZmluaXRpb24sIG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbn0pO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzRW51bVR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZVtpbnRlcm5hbF0uZGVmaW5pdGlvbi50eXBlID09PSAnZW51bSc7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW51bWVyYXRpb24oZGVzY3JpcHRpb24sIGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtVHlwZSh7XG4gICAgdHlwZTogJ2VudW0nLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIGVudHJpZXMsXG4gICAgc3RyZWFtaW5nOiBmYWxzZVxuICB9KTtcbn1cbmNvbnN0IE51bGxUeXBlID0gSGFzaGJyb3duVHlwZUN0b3Ioe1xuICBuYW1lOiAnTnVsbCcsXG4gIGluaXRpYWxpemVyOiAoaW5zdCwgZGVmKSA9PiB7XG4gICAgSGFzaGJyb3duVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIH0sXG4gIHRvSnNvblNjaGVtYUltcGw6IHNjaGVtYSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdudWxsJyxcbiAgICAgIGNvbnN0OiBzY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24udmFsdWUsXG4gICAgICBkZXNjcmlwdGlvbjogc2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLmRlc2NyaXB0aW9uXG4gICAgfTtcbiAgfSxcbiAgcGFyc2VKc29uU2NoZW1hSW1wbDogKHNjaGVtYSwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgLy8gSXMgdGhpcyBhIHdyYXBwZWQgcHJpbWl0aXZlP1xuICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhvYmplY3QpLmluY2x1ZGVzKFBSSU1JVElWRV9XUkFQUEVSX0ZJRUxEX05BTUUpKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbUFJJTUlUSVZFX1dSQVBQRVJfRklFTERfTkFNRV07XG4gICAgfVxuICAgIGlmIChvYmplY3QgIT09IG51bGwpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudWxsIGF0OiAke3BhdGguam9pbignLicpfWApO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG4gIHRvVHlwZVNjcmlwdEltcGw6IHNjaGVtYSA9PiB7XG4gICAgcmV0dXJuIGAvKiAke3NjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5kZXNjcmlwdGlvbn0gKi8gbnVsbGA7XG4gIH0sXG4gIHZhbGlkYXRlSW1wbDogKHNjaGVtYSwgZGVmaW5pdGlvbiwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgaWYgKG9iamVjdCAhPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bGwgYXQ6ICR7cGF0aC5qb2luKCcuJyl9YCk7XG4gIH0sXG4gIHRvU3RyZWFtaW5nSW1wbDogKHNjaGVtYSwgZGVmaW5pdGlvbiwgb2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxufSk7XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNOdWxsVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlW2ludGVybmFsXS5kZWZpbml0aW9uLnR5cGUgPT09ICdudWxsJztcbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBudWxsaXNoKCkge1xuICByZXR1cm4gbmV3IE51bGxUeXBlKHtcbiAgICB0eXBlOiAnbnVsbCcsXG4gICAgZGVzY3JpcHRpb246ICcnLFxuICAgIHN0cmVhbWluZzogZmFsc2VcbiAgfSk7XG59XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogICAgICAgICAgIFN0cmVhbWluZyBIZWxwZXJzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuZnVuY3Rpb24gbmVlZHNEaXNjcmltaW5hdG9yV3JhcHBlckluQW55T2Yoc2NoZW1hKSB7XG4gIGlmIChpc0FueU9mVHlwZShzY2hlbWEpIHx8IGlzQXJyYXlUeXBlKHNjaGVtYSkgfHwgaXNPYmplY3RUeXBlKHNjaGVtYSkgfHwgaXNTdHJpbmdUeXBlKHNjaGVtYSkgJiYgaXNTdHJlYW1pbmcoc2NoZW1hKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU3RyZWFtaW5nKHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLnN0cmVhbWluZztcbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc0hhc2hicm93blR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZVtpbnRlcm5hbF0gIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldERlc2NyaXB0aW9uKHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLmRlc2NyaXB0aW9uO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc3RyaW5nKGRlc2NyaXB0aW9uKSB7XG4gIHJldHVybiBuZXcgU3RyaW5nVHlwZSh7XG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgc3RyZWFtaW5nOiB0cnVlXG4gIH0pO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIG9iamVjdChkZXNjcmlwdGlvbiwgc2hhcGUpIHtcbiAgcmV0dXJuIG5ldyBPYmplY3RUeXBlKHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBzdHJlYW1pbmc6IHRydWUsXG4gICAgc2hhcGVcbiAgfSk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gYXJyYXkoZGVzY3JpcHRpb24sIGl0ZW0pIHtcbiAgcmV0dXJuIG5ldyBBcnJheVR5cGUoe1xuICAgIHR5cGU6ICdhcnJheScsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgc3RyZWFtaW5nOiB0cnVlLFxuICAgIGVsZW1lbnQ6IGl0ZW1cbiAgfSk7XG59XG5cbnZhciBzdHJlYW1pbmcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGFycmF5OiBhcnJheSxcbiAgICBvYmplY3Q6IG9iamVjdCxcbiAgICBzdHJpbmc6IHN0cmluZ1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogQ29udmVydCBhbiBhcmJpdHJhcnkgZGVzY3JpcHRpb24gaW50byBhIGNhbWVsQ2FzZSBpZGVudGlmaWVyLlxuICpcbiAqIC0gU3RyaXBzIG91dCBhbnkgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gKiAtIFNwbGl0cyBvbiB3aGl0ZXNwYWNlXG4gKiAtIExvd2VyY2FzZXMgYWxsIHdvcmRzLCB0aGVuIHVwcGVyY2FzZXMgdGhlIGZpcnN0IGxldHRlciBvZiBlYWNoIHN1YnNlcXVlbnQgd29yZFxuICogLSBQcmVmaXhlcyB3aXRoIGBfYCBpZiB0aGUgcmVzdWx0IHdvdWxkIHN0YXJ0IHdpdGggYSBkaWdpdFxuICovXG5mdW5jdGlvbiBkZXNjcmlwdGlvblRvQ2FtZWxDYXNlKGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IGNsZWFuZWQgPSBkZXNjcmlwdGlvbi5yZXBsYWNlKC9bXmEtekEtWjAtOV0rL2csICcgJykudHJpbSgpO1xuICBjb25zdCB3b3JkcyA9IGNsZWFuZWQuc3BsaXQoL1xccysvKS5tYXAodyA9PiB3LnRvTG93ZXJDYXNlKCkpO1xuICBpZiAod29yZHMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIGNvbnN0IFtmaXJzdCwgLi4ucmVzdF0gPSB3b3JkcztcbiAgY29uc3QgY29yZSA9IGZpcnN0ICsgcmVzdC5tYXAodyA9PiB3WzBdLnRvVXBwZXJDYXNlKCkgKyB3LnNsaWNlKDEpKS5qb2luKCcnKTtcbiAgcmV0dXJuIC9eXFxkLy50ZXN0KGNvcmUpID8gYF8ke2NvcmV9YCA6IGNvcmU7XG59XG4vKipcbiAqIFdhbGtzIHRoZSBIYXNoYnJvd25UeXBlIGdyYXBoLCBmaW5kcyBhbnkgc3ViLXNjaGVtYXMgc2VlbiBtb3JlIHRoYW4gb25jZVxuICogKGV4Y2x1ZGluZyB0aGUgcm9vdCksIGFzc2lnbnMgZWFjaCBhIHVuaXF1ZSBuYW1lLCBhbmQgZW1pdHMgYSBkcmFmdC0wNyBKU09OIFNjaGVtYVxuICogd2l0aCBhICRkZWZzIHNlY3Rpb24uICBDeWNsZXMgYWx3YXlzIGJlY29tZSAkcmVmcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvSnNvblNjaGVtYShzY2hlbWEpIHtcbiAgY29uc3Qgcm9vdE5vZGUgPSBzY2hlbWE7XG4gIC8vIDEpIENvbGxlY3QgcmVwZWF0ZWQgbm9kZXNcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgY29uc3QgcmVwZWF0cyA9IG5ldyBTZXQoKTtcbiAgKGZ1bmN0aW9uIHZpc2l0KG4sIHBhdGgpIHtcbiAgICBpZiAoc2Vlbi5oYXMobikpIHtcbiAgICAgIHJlcGVhdHMuYWRkKG4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWVuLmFkZChuKTtcbiAgICBpZiAoaXNPYmplY3RUeXBlKG4pKSB7XG4gICAgICBPYmplY3QudmFsdWVzKG5baW50ZXJuYWxdLmRlZmluaXRpb24uc2hhcGUpLmZvckVhY2goY2hpbGQgPT4gdmlzaXQoY2hpbGQsIFsuLi5wYXRoLCBuXSkpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheVR5cGUobikpIHtcbiAgICAgIHZpc2l0KG5baW50ZXJuYWxdLmRlZmluaXRpb24uZWxlbWVudCwgWy4uLnBhdGgsIG5dKTtcbiAgICB9IGVsc2UgaWYgKGlzQW55T2ZUeXBlKG4pKSB7XG4gICAgICBuW2ludGVybmFsXS5kZWZpbml0aW9uLm9wdGlvbnMuZm9yRWFjaChvcHQgPT4gdmlzaXQob3B0LCBbLi4ucGF0aCwgbl0pKTtcbiAgICB9XG4gIH0pKHJvb3ROb2RlLCBbXSk7XG4gIC8vIG5ldmVyIHB1dCB0aGUgcm9vdCBpdHNlbGYgaW50byAkZGVmc1xuICByZXBlYXRzLmRlbGV0ZShyb290Tm9kZSk7XG4gIC8vIDIpIEFzc2lnbiBlYWNoIHJlcGVhdGVkIG5vZGUgYSB1bmlxdWUgY2FtZWxDYXNlIG5hbWVcbiAgY29uc3QgZGVmTmFtZU1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdXNlZE5hbWVzID0gbmV3IFNldCgpO1xuICBsZXQgYW5vbiA9IDE7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiByZXBlYXRzKSB7XG4gICAgY29uc3QgZGVzYyA9IG5vZGVbaW50ZXJuYWxdLmRlZmluaXRpb24uZGVzY3JpcHRpb24gfHwgYGRlZiR7YW5vbisrfWA7XG4gICAgbGV0IG5hbWUgPSBkZXNjcmlwdGlvblRvQ2FtZWxDYXNlKGRlc2MpIHx8IGBkZWYke2Fub24rK31gO1xuICAgIGlmICh1c2VkTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICBsZXQgaSA9IDE7XG4gICAgICB3aGlsZSAodXNlZE5hbWVzLmhhcyhgJHtuYW1lfSR7aX1gKSkgaSsrO1xuICAgICAgbmFtZSA9IGAke25hbWV9JHtpfWA7XG4gICAgfVxuICAgIHVzZWROYW1lcy5hZGQobmFtZSk7XG4gICAgZGVmTmFtZU1hcC5zZXQobm9kZSwgbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZSBwcmludGVyLlxuICAgKlxuICAgKiBAcGFyYW0gbiAtIGN1cnJlbnQgbm9kZVxuICAgKiBAcGFyYW0gaXNSb290IC0gdHJ1ZSBvbmx5IGZvciB0aGUgdmVyeSB0b3AtbGV2ZWwgc2NoZW1hXG4gICAqIEBwYXJhbSBpbkRlZiAtIGlmIG5vbi1udWxsLCB3ZSdyZSBwcmludGluZyAkZGVmc1tpbkRlZl0g4oCUIGFueSBvdGhlciBkZWYgYmVjb21lcyAkcmVmXG4gICAqIEBwYXJhbSBwYXRoU2VlbiAtIHRyYWNrcyB0aGUgY2hhaW4gb2YgaW5saW5lZCBub2RlcyB0byBjYXRjaCBjeWNsZXNcbiAgICovXG4gIGZ1bmN0aW9uIHByaW50Tm9kZShuLCBpc1Jvb3QgPSBmYWxzZSwgaW5EZWYgPSBudWxsLCBwYXRoU2VlbiA9IG5ldyBTZXQoKSxcbiAgLy8gSWYgcHJvdmlkZWQsIG9taXQgdGhpcyBwcm9wZXJ0eSB3aGVuIHByaW50aW5nIGFuIG9iamVjdC4gVXNlZCBmb3JcbiAgLy8gYW55T2YgbGl0ZXJhbC1iYXNlZCBlbnZlbG9wZXMgd2hlcmUgdGhlIGxpdGVyYWwgaXMgcmVkdW5kYW50LlxuICBvbWl0T2JqZWN0UHJvcCkge1xuICAgIC8vIGEpIGN5Y2xlIGJhY2sgdG8gdGhlIHJvb3RcbiAgICBpZiAoIWlzUm9vdCAmJiBuID09PSByb290Tm9kZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJHJlZjogJyMnXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBiKSBhbnkgb3RoZXIgc2hhcmVkIGRlZiBiZWNvbWVzIGEgJHJlZlxuICAgIGlmIChkZWZOYW1lTWFwLmhhcyhuKSAmJiBuICE9PSBpbkRlZikge1xuICAgICAgY29uc3Qgbm0gPSBkZWZOYW1lTWFwLmdldChuKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICRyZWY6IGAjLyRkZWZzLyR7bm19YFxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gYykgY2F0Y2ggc2VsZi1jeWNsZXMgb3IgbXV0dWFsIGN5Y2xlcyBpbiBpbmxpbmUgcG9ydGlvbnNcbiAgICBpZiAocGF0aFNlZW4uaGFzKG4pKSB7XG4gICAgICAvLyBpZiBpdOKAmXMgbmFtZWQsIHJlZiBpdDsgb3RoZXJ3aXNlIHBvaW50IGF0IHJvb3RcbiAgICAgIGlmIChkZWZOYW1lTWFwLmhhcyhuKSkge1xuICAgICAgICBjb25zdCBubSA9IGRlZk5hbWVNYXAuZ2V0KG4pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICRyZWY6IGAjLyRkZWZzLyR7bm19YFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAkcmVmOiAnIydcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZCkgaW5saW5lIHRoaXMgbm9kZVxuICAgIHBhdGhTZWVuLmFkZChuKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChpc09iamVjdFR5cGUobikpIHtcbiAgICAgIC8vIFNvcnQgcHJvcHMgc28gdGhhdCBzdHJlYW1pbmcgb25lcyBhcmUgYXQgdGhlIGVuZFxuICAgICAgY29uc3Qgc2hhcGVXaXRoU3RyZWFtaW5nQXRFbmQgPSBPYmplY3QuZW50cmllcyhuW2ludGVybmFsXS5kZWZpbml0aW9uLnNoYXBlKVxuICAgICAgLy8gSWYgd2UncmUgb21pdHRpbmcgYSBwcm9wIGR1ZSB0byBlbnZlbG9wZSBkaXNjcmltaW5hdGlvbiwgcmVtb3ZlIGl0XG4gICAgICAuZmlsdGVyKChba2V5XSkgPT4gb21pdE9iamVjdFByb3AgPyBrZXkgIT09IG9taXRPYmplY3RQcm9wIDogdHJ1ZSkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoIWlzU3RyZWFtaW5nKGFbMV0pICYmIGlzU3RyZWFtaW5nKGJbMV0pKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmVhbWluZyhhWzFdKSAmJiAhaXNTdHJlYW1pbmcoYlsxXSkpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvcHMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW2ssIGNoaWxkXSBvZiBzaGFwZVdpdGhTdHJlYW1pbmdBdEVuZCkge1xuICAgICAgICBwcm9wc1trXSA9IHByaW50Tm9kZShjaGlsZCwgZmFsc2UsIGluRGVmLCBwYXRoU2Vlbik7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBuLnRvSnNvblNjaGVtYSgpO1xuICAgICAgcmVzdWx0LnByb3BlcnRpZXMgPSBwcm9wcztcbiAgICAgIC8vIEVuc3VyZSByZXF1aXJlZCBrZXlzIGRvIG5vdCBpbmNsdWRlIGFueSBvbWl0dGVkIGRpc2NyaW1pbmF0b3IgcHJvcFxuICAgICAgcmVzdWx0LnJlcXVpcmVkID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheVR5cGUobikpIHtcbiAgICAgIHJlc3VsdCA9IG4udG9Kc29uU2NoZW1hKCk7XG4gICAgICByZXN1bHQuaXRlbXMgPSBwcmludE5vZGUobltpbnRlcm5hbF0uZGVmaW5pdGlvbi5lbGVtZW50LCBmYWxzZSwgaW5EZWYsIHBhdGhTZWVuKTtcbiAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgICAgICByZXF1aXJlZDogW1BSSU1JVElWRV9XUkFQUEVSX0ZJRUxEX05BTUVdLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIFtQUklNSVRJVkVfV1JBUFBFUl9GSUVMRF9OQU1FXTogcmVzdWx0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBbnlPZlR5cGUobikpIHtcbiAgICAgIHJlc3VsdCA9IG4udG9Kc29uU2NoZW1hKCk7XG4gICAgICBjb25zdCBidWlsZERpc2NyaW1pbmF0b3JNYXAgPSBvcHRpb25zID0+IHtcbiAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgIGZvciAoY29uc3Qgb3B0IG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0VHlwZShvcHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2hhcGUgPSBvcHRbaW50ZXJuYWxdLmRlZmluaXRpb24uc2hhcGU7XG4gICAgICAgICAgY29uc3QgbGl0ZXJhbEVudHJpZXMgPSBPYmplY3QuZW50cmllcyhzaGFwZSkuZmlsdGVyKChbLCB2XSkgPT4gaXNMaXRlcmFsVHlwZSh2KSk7XG4gICAgICAgICAgLy8gUmVxdWlyZSBleGFjdGx5IG9uZSBsaXRlcmFsIGZvciBjbGVhciBkaXNjcmltaW5hdGlvblxuICAgICAgICAgIGlmIChsaXRlcmFsRW50cmllcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBbbGl0ZXJhbEtleSwgbGl0U2NoZW1hXSA9IGxpdGVyYWxFbnRyaWVzWzBdO1xuICAgICAgICAgIGNvbnN0IGxpdGVyYWxWYWx1ZSA9IGxpdFNjaGVtYVtpbnRlcm5hbF0uZGVmaW5pdGlvbi52YWx1ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGxpdGVyYWxWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgc3VwcG9ydCBzdHJpbmctYmFzZWQgZGlzY3JpbWluYXRvcnMgZm9yIHdyYXBwZXIga2V5c1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBsaXRlcmFsVmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBBbWJpZ3VvdXMgKGR1cGxpY2F0ZSkgZGlzY3JpbWluYXRvciB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcFtsaXRlcmFsVmFsdWVdID0ge1xuICAgICAgICAgICAgc2NoZW1hOiBvcHQsXG4gICAgICAgICAgICBsaXRlcmFsS2V5LFxuICAgICAgICAgICAgbGl0ZXJhbFZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwKS5sZW5ndGggPT09IG9wdGlvbnMubGVuZ3RoID8gbWFwIDogbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBvcHRpb25zID0gbltpbnRlcm5hbF0uZGVmaW5pdGlvbi5vcHRpb25zO1xuICAgICAgY29uc3QgbGl0ZXJhbERpc2NyaW1pbmF0b3JNYXAgPSBidWlsZERpc2NyaW1pbmF0b3JNYXAob3B0aW9ucyk7XG4gICAgICBpZiAobGl0ZXJhbERpc2NyaW1pbmF0b3JNYXApIHtcbiAgICAgICAgLy8gRW1pdCB3cmFwcGVycyBrZXllZCBieSB0aGUgbGl0ZXJhbCB2YWx1ZVxuICAgICAgICByZXN1bHQuYW55T2YgPSBvcHRpb25zLm1hcChvcHQgPT4ge1xuICAgICAgICAgIC8vIEZpbmQgdGhpcyBvcHRpb24ncyBsaXRlcmFsIHZhbHVlIGJ5IHNjYW5uaW5nIGl0cyBzaGFwZVxuICAgICAgICAgIGNvbnN0IHNoYXBlID0gb3B0W2ludGVybmFsXS5kZWZpbml0aW9uLnNoYXBlO1xuICAgICAgICAgIGNvbnN0IFtsaXRlcmFsS2V5LCBsaXRTY2hlbWFdID0gT2JqZWN0LmVudHJpZXMoc2hhcGUpLmZpbmQoKFssIHZdKSA9PiBpc0xpdGVyYWxUeXBlKHYpKTtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsVmFsdWUgPSBsaXRTY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24udmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IFtsaXRlcmFsVmFsdWVdLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAvLyBXaGVuIHByaW50aW5nIHRoZSBvcHRpb24gb2JqZWN0LCBvbWl0IHRoZSBkaXNjcmltaW5hdG9yIGxpdGVyYWxcbiAgICAgICAgICAgICAgLy8ga2V5IGZyb20gdGhlIGlubmVyIHNjaGVtYSBiZWNhdXNlIGl0IGlzIGFscmVhZHkgY29udmV5ZWQgYnlcbiAgICAgICAgICAgICAgLy8gdGhlIGVudmVsb3BlIGtleSAobGl0ZXJhbFZhbHVlKVxuICAgICAgICAgICAgICBbbGl0ZXJhbFZhbHVlXTogcHJpbnROb2RlKG9wdCwgZmFsc2UsIGluRGVmLCBwYXRoU2VlbiwgbGl0ZXJhbEtleSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIHByZXZpb3VzIGJlaGF2aW9yOiBpbmRleC1iYXNlZCB3cmFwcGVycyBmb3IgY29tcGxleCBvcHRpb25zXG4gICAgICAgIHJlc3VsdC5hbnlPZiA9IG9wdGlvbnMubWFwKChvcHQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKG5lZWRzRGlzY3JpbWluYXRvcldyYXBwZXJJbkFueU9mKG9wdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4QXNTdHIgPSBgJHtpbmRleH1gO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IFtpbmRleEFzU3RyXSxcbiAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIFtpbmRleEFzU3RyXTogcHJpbnROb2RlKG9wdCwgZmFsc2UsIGluRGVmLCBwYXRoU2VlbilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50Tm9kZShvcHQsIGZhbHNlLCBpbkRlZiwgcGF0aFNlZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG4udG9Kc29uU2NoZW1hKCk7XG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICAgICAgcmVxdWlyZWQ6IFtQUklNSVRJVkVfV1JBUFBFUl9GSUVMRF9OQU1FXSxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBbUFJJTUlUSVZFX1dSQVBQRVJfRklFTERfTkFNRV06IHJlc3VsdFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aFNlZW4uZGVsZXRlKG4pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gMykgQnVpbGQgdGhlICRkZWZzIHNlY3Rpb25cbiAgY29uc3QgZGVmcyA9IHt9O1xuICBmb3IgKGNvbnN0IFtub2RlLCBuYW1lXSBvZiBkZWZOYW1lTWFwLmVudHJpZXMoKSkge1xuICAgIC8vIGlzUm9vdD1mYWxzZSwgaW5EZWY9bm9kZSwgZnJlc2ggcGF0aFNlZW5cbiAgICBkZWZzW25hbWVdID0gcHJpbnROb2RlKG5vZGUsIGZhbHNlLCBub2RlLCBuZXcgU2V0KCkpO1xuICB9XG4gIC8vIDQpIFByaW50IHRoZSByb290IHNjaGVtYVxuICBjb25zdCByb290UHJpbnRlZCA9IHByaW50Tm9kZShyb290Tm9kZSwgdHJ1ZSwgbnVsbCwgbmV3IFNldCgpKTtcbiAgLy8gNSkgQXNzZW1ibGUgYW5kIHJldHVyblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtcbiAgICAkc2NoZW1hOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjJ1xuICB9LCByb290UHJpbnRlZCksIE9iamVjdC5rZXlzKGRlZnMpLmxlbmd0aCA+IDAgPyB7XG4gICAgJGRlZnM6IGRlZnNcbiAgfSA6IHt9KTtcbn1cblxudmFyIHB1YmxpY19hcGkkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgQW55T2ZUeXBlOiBBbnlPZlR5cGUsXG4gICAgQXJyYXlUeXBlOiBBcnJheVR5cGUsXG4gICAgQm9vbGVhblR5cGU6IEJvb2xlYW5UeXBlLFxuICAgIENvbnN0U3RyaW5nVHlwZTogTGl0ZXJhbFR5cGUsXG4gICAgRW51bVR5cGU6IEVudW1UeXBlLFxuICAgIEhhc2hicm93blR5cGU6IEhhc2hicm93blR5cGUsXG4gICAgSW50ZWdlclR5cGU6IEludGVnZXJUeXBlLFxuICAgIE51bGxUeXBlOiBOdWxsVHlwZSxcbiAgICBOdW1iZXJUeXBlOiBOdW1iZXJUeXBlLFxuICAgIE9iamVjdFR5cGU6IE9iamVjdFR5cGUsXG4gICAgU3RyaW5nVHlwZTogU3RyaW5nVHlwZSxcbiAgICBhbnlPZjogYW55T2YsXG4gICAgYXJyYXk6IGFycmF5JDEsXG4gICAgYm9vbGVhbjogYm9vbGVhbixcbiAgICBlbnVtZXJhdGlvbjogZW51bWVyYXRpb24sXG4gICAgZ2V0RGVzY3JpcHRpb246IGdldERlc2NyaXB0aW9uLFxuICAgIGludGVnZXI6IGludGVnZXIsXG4gICAgaXNBbnlPZlR5cGU6IGlzQW55T2ZUeXBlLFxuICAgIGlzQXJyYXlUeXBlOiBpc0FycmF5VHlwZSxcbiAgICBpc0Jvb2xlYW5UeXBlOiBpc0Jvb2xlYW5UeXBlLFxuICAgIGlzRW51bVR5cGU6IGlzRW51bVR5cGUsXG4gICAgaXNIYXNoYnJvd25UeXBlOiBpc0hhc2hicm93blR5cGUsXG4gICAgaXNJbnRlZ2VyVHlwZTogaXNJbnRlZ2VyVHlwZSxcbiAgICBpc0xpdGVyYWxUeXBlOiBpc0xpdGVyYWxUeXBlLFxuICAgIGlzTnVsbFR5cGU6IGlzTnVsbFR5cGUsXG4gICAgaXNOdW1iZXJUeXBlOiBpc051bWJlclR5cGUsXG4gICAgaXNPYmplY3RUeXBlOiBpc09iamVjdFR5cGUsXG4gICAgaXNTdHJpbmdUeXBlOiBpc1N0cmluZ1R5cGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbCxcbiAgICBudWxsaXNoOiBudWxsaXNoLFxuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIG9iamVjdDogb2JqZWN0JDEsXG4gICAgc3RyZWFtaW5nOiBzdHJlYW1pbmcsXG4gICAgc3RyaW5nOiBzdHJpbmckMSxcbiAgICB0b0pzb25TY2hlbWE6IHRvSnNvblNjaGVtYVxufSk7XG5cbmZ1bmN0aW9uIHNsZWVwKHRpbWVvdXQsIGFib3J0U2lnbmFsKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpO1xuICAgICAgaWYgKGFib3J0U2lnbmFsKSB7XG4gICAgICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzd2l0Y2hBc3luYyhmbiwgb3V0ZXJTaWduYWwpIHtcbiAgbGV0IGFib3J0Q29udHJvbGxlcjtcbiAgaWYgKG91dGVyU2lnbmFsKSB7XG4gICAgb3V0ZXJTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgnY2FuY2VsbGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoJ2NhbmNlbGxlZCcpO1xuICAgIH1cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGFib3J0Q29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGZuKGNvbnRyb2xsZXIuc2lnbmFsKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIgPT09IGNvbnRyb2xsZXIpIHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG52YXIgYXBpX21vZGVscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG52YXIgaW50ZXJuYWxfbW9kZWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmNvbnN0IFRSQUNFX0xFVkVMID0gMDtcbmNvbnN0IERFQlVHX0xFVkVMID0gMTtcbmNvbnN0IElORk9fTEVWRUwgPSAyO1xuY29uc3QgV0FSTl9MRVZFTCA9IDM7XG5jb25zdCBFUlJPUl9MRVZFTCA9IDQ7XG5jb25zdCBOT05FX0xFVkVMID0gNTtcbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGxvZ1BhdGhzRW5hYmxlZCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmxvZ1BhdGhzRW5hYmxlZCA9IHt9O1xuICAgIHRoaXMubG9nUGF0aHNFbmFibGVkID0gbG9nUGF0aHNFbmFibGVkO1xuICAgIHRoaXMuYWxsTGV2ZWwgPSAoX2EgPSBsb2dQYXRoc0VuYWJsZWRbJ2FsbCddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBOT05FX0xFVkVMO1xuICB9XG4gIGZvcihsb2dnZXJOYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNlOiBhcmdzID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYWxsTGV2ZWwgPD0gVFJBQ0VfTEVWRUwgfHwgdGhpcy5sb2dQYXRoc0VuYWJsZWRbbG9nZ2VyTmFtZV0gJiYgdGhpcy5sb2dQYXRoc0VuYWJsZWRbbG9nZ2VyTmFtZV0gPD0gVFJBQ0VfTEVWRUwpIHtcbiAgICAgICAgICBjb25zb2xlLnRyYWNlKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVidWc6IGFyZ3MgPT4ge1xuICAgICAgICBpZiAodGhpcy5hbGxMZXZlbCA8PSBERUJVR19MRVZFTCB8fCB0aGlzLmxvZ1BhdGhzRW5hYmxlZFtsb2dnZXJOYW1lXSAmJiB0aGlzLmxvZ1BhdGhzRW5hYmxlZFtsb2dnZXJOYW1lXSA8PSBERUJVR19MRVZFTCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5mbzogYXJncyA9PiB7XG4gICAgICAgIGlmICh0aGlzLmFsbExldmVsIDw9IElORk9fTEVWRUwgfHwgdGhpcy5sb2dQYXRoc0VuYWJsZWRbbG9nZ2VyTmFtZV0gJiYgdGhpcy5sb2dQYXRoc0VuYWJsZWRbbG9nZ2VyTmFtZV0gPD0gSU5GT19MRVZFTCkge1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdhcm46IGFyZ3MgPT4ge1xuICAgICAgICBpZiAodGhpcy5hbGxMZXZlbCA8PSBXQVJOX0xFVkVMIHx8IHRoaXMubG9nUGF0aHNFbmFibGVkW2xvZ2dlck5hbWVdICYmIHRoaXMubG9nUGF0aHNFbmFibGVkW2xvZ2dlck5hbWVdIDw9IEVSUk9SX0xFVkVMKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGFyZ3MgPT4ge1xuICAgICAgICBpZiAodGhpcy5hbGxMZXZlbCA8PSBFUlJPUl9MRVZFTCB8fCB0aGlzLmxvZ1BhdGhzRW5hYmxlZFtsb2dnZXJOYW1lXSAmJiB0aGlzLmxvZ1BhdGhzRW5hYmxlZFtsb2dnZXJOYW1lXSA8PSBUUkFDRV9MRVZFTCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogU2tpbGxldCBpcyBhbiBMTE0tb3B0aW1pemVkIHN0cmVhbWluZyBKU09OIFBhcnNlciAtIHBlcmZlY3RseSBzdWl0ZWQgZm9yIHN0cmVhbWluZyBob3QgYW5kIGZyZXNoIEpTT04uXG4gKlxuICogUG9ydGlvbnMgb2YgdGhpcyBjb2RlIGFyZSBkZXJpdmVkIGZyb20gcGFydGlhbC1qc29uIChNSVQgTGljZW5zZSkgKGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9tcGxhdGUvcGFydGlhbC1qc29uLXBhcnNlci1qcykuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBmdWxsIGxpY2Vuc2UgdGV4dC5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqIEBhdXRob3IgTGl2ZUxvdmVBcHAsIExMQ1xuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWxvdmVhcHAvaGFzaGJyb3duXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9tcGxhdGUvcGFydGlhbC1qc29uLXBhcnNlci1qc1xuICovXG5jb25zdCBMT0dfU0VUVElOR1MgPSB7XG4gIGFsbDogTk9ORV9MRVZFTFxufTtcbmNsYXNzIFBhcnRpYWxKU09OIGV4dGVuZHMgRXJyb3Ige31cbmNsYXNzIE1hbGZvcm1lZEpTT04gZXh0ZW5kcyBFcnJvciB7fVxuY2xhc3MgSW5jb21wbGV0ZU5vblN0cmVhbWluZ09iamVjdCBleHRlbmRzIEVycm9yIHt9XG5jbGFzcyBVbmV4cGVjdGVkU3RyZWFtaW5nVHlwZSBleHRlbmRzIEVycm9yIHt9XG5mdW5jdGlvbiBzaG91bGRCZVdyYXBwZWRQcmltaXRpdmUoc2NoZW1hKSB7XG4gIGlmIChpc0FueU9mVHlwZShzY2hlbWEpIHx8IGlzT2JqZWN0VHlwZShzY2hlbWEpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuY29uc3QgYnVpbGREaXNjcmltaW5hdG9yTWFwID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBmb3IgKGNvbnN0IG9wdCBvZiBvcHRpb25zKSB7XG4gICAgaWYgKCFpc09iamVjdFR5cGUob3B0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNoYXBlID0gb3B0W2ludGVybmFsXS5kZWZpbml0aW9uLnNoYXBlO1xuICAgIC8vIEZpbmQgbGl0ZXJhbCBwcm9wZXJ0aWVzIG9uIHRoaXMgb2JqZWN0IG9wdGlvblxuICAgIGNvbnN0IGxpdGVyYWxFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoc2hhcGUpLmZpbHRlcigoWywgdl0pID0+IGlzTGl0ZXJhbFR5cGUodikpO1xuICAgIC8vIE11c3QgaGF2ZSBleGFjdGx5IG9uZSBsaXRlcmFsIGZvciB1bmFtYmlndW91cyBkaXNjcmltaW5hdGlvblxuICAgIGlmIChsaXRlcmFsRW50cmllcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBbbGl0ZXJhbEtleSwgbGl0ZXJhbFNjaGVtYV0gPSBsaXRlcmFsRW50cmllc1swXTtcbiAgICBjb25zdCBsaXRlcmFsVmFsdWUgPSBsaXRlcmFsU2NoZW1hW2ludGVybmFsXS5kZWZpbml0aW9uLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgbGl0ZXJhbFZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgLy8gT25seSBzdXBwb3J0IHN0cmluZyBkaXNjcmltaW5hdG9yc1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBsaXRlcmFsVmFsdWUpKSB7XG4gICAgICAvLyBEdXBsaWNhdGUgZGlzY3JpbWluYXRvciB2YWx1ZSAtPiBhbWJpZ3VvdXNcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtYXBbbGl0ZXJhbFZhbHVlXSA9IHtcbiAgICAgIHNjaGVtYTogb3B0LFxuICAgICAgbGl0ZXJhbEtleSxcbiAgICAgIGxpdGVyYWxWYWx1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkubGVuZ3RoID09PSBvcHRpb25zLmxlbmd0aCA/IG1hcCA6IG51bGw7XG59O1xuZnVuY3Rpb24gcGFyc2VKU09OKGpzb25TdHJpbmcsIHNjaGVtYSwgYXNzdW1lRmluaXNoZWRNZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YganNvblN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3Rpbmcgc3RyLCBnb3QgJHt0eXBlb2YganNvblN0cmluZ31gKTtcbiAgfVxuICBpZiAoIWpzb25TdHJpbmcudHJpbSgpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBfcGFyc2VKU09OKGpzb25TdHJpbmcudHJpbSgpLCBzY2hlbWEsIGFzc3VtZUZpbmlzaGVkTWVzc2FnZSk7XG59XG5jb25zdCBfcGFyc2VKU09OID0gKGpzb25TdHJpbmcsIHNjaGVtYSwgYXNzdW1lRmluaXNoZWRNZXNzYWdlKSA9PiB7XG4gIGNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoTE9HX1NFVFRJTkdTKTtcbiAgbG9nZ2VyLmZvcignX3BhcnNlSlNPTicpLmluZm8oJ0luIF9wYXJzZUpzb24nKTtcbiAgLy8gU2luY2UgZWFjaCBwYXJzZSBydW4gaXMgZWZmZWN0aXZlbHkgc3RhcnRpbmcgb3ZlciwgdGhpcyBzdHJpbmcgc2hvdWxkIGluZGljYXRlXG4gIC8vIGhvdyBmYXIgd2UgY2FuIGV4cGVjdCB0byBnZXQgdGhpcyB0aW1lXG4gIGxvZ2dlci5mb3IoJ19wYXJzZUpTT04nKS5pbmZvKGpzb25TdHJpbmcpO1xuICBjb25zdCBsZW5ndGggPSBqc29uU3RyaW5nLmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgLy8gVHJhY2sgY3VycmVudCBvYmplY3QvYXJyYXkgc28gd2UgY2FuIG1vdmUgdXAgYW5kIGRvd24gdGhlIGRvY3VtZW50IHN0YWNrIGFzIHdlIGdvXG4gIGNvbnN0IGNvbnRhaW5lclN0YWNrID0gW3NjaGVtYV07XG4gIGNvbnN0IG1hcmtQYXJ0aWFsSlNPTiA9IG1zZyA9PiB7XG4gICAgdGhyb3cgbmV3IFBhcnRpYWxKU09OKGAke21zZ30gYXQgcG9zaXRpb24gJHtpbmRleH1gKTtcbiAgfTtcbiAgY29uc3QgdGhyb3dNYWxmb3JtZWRFcnJvciA9IG1zZyA9PiB7XG4gICAgdGhyb3cgbmV3IE1hbGZvcm1lZEpTT04oYCR7bXNnfSBhdCBwb3NpdGlvbiAke2luZGV4fWApO1xuICB9O1xuICBjb25zdCBwYXJzZUFueSA9IChjdXJyZW50S2V5LCBhbGxvd3NJbmNvbXBsZXRlLCBpbnNpZGVBcnJheSwgbGl0ZXJhbEtleSkgPT4ge1xuICAgIHNraXBCbGFuaygpO1xuICAgIGxvZ2dlci5mb3IoJ3BhcnNlQW55JykuaW5mbyhgUmVtYWluaW5nIHN0cmluZzogJHtqc29uU3RyaW5nLnNsaWNlKGluZGV4KX1gKTtcbiAgICBjb25zdCBjdXJyZW50TGFzdENvbnRhaW5lciA9IGNvbnRhaW5lclN0YWNrW2NvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGxvZ2dlci5mb3IoJ3BhcnNlQW55JykuZGVidWcoJ0N1cnJlbnQgbGFzdCBjb250YWluZXI6Jyk7XG4gICAgbG9nZ2VyLmZvcigncGFyc2VBbnknKS5kZWJ1ZyhjdXJyZW50TGFzdENvbnRhaW5lcik7XG4gICAgaWYgKGluZGV4ID49IGxlbmd0aCkgbWFya1BhcnRpYWxKU09OKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJ1wiJykge1xuICAgICAgcmV0dXJuIHBhcnNlU3RyKGFsbG93c0luY29tcGxldGUpO1xuICAgIH1cbiAgICBpZiAoanNvblN0cmluZ1tpbmRleF0gPT09ICd7Jykge1xuICAgICAgLypcbiAgICAgICAgSWYgdGhlIHRvcC1sZXZlbCBzY2hlbWEgaXMgYSBwcmltaXRpdmUgdGhhdCBzaG91bGQgYmUgb2JqZWN0LXdyYXBwZWQsIHdlXG4gICAgICAgIGFzc3VtZSBhIHdyYXBwZWQgcHJpbWl0aXZlIGlzIHN0YXJ0aW5nXG4gICAgICAgICAgICAgICBJZiB0aGUgY3VycmVudCBjb250YWluZXIgaXMgYW4gYXJyYXksIHdlIGFzc3VtZSBhbiBhbnlPZiB3cmFwcGVyIGlzIHN0YXJ0aW5nLlxuICAgICAgICBcbiAgICAgICAgRWxzZSwgd2UgcGFyc2UgYXMgYSByZWd1bGFyIG9iamVjdC5cbiAgICAgICovXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50TGFzdENvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQW55T2YoY3VycmVudEtleSk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZEJlV3JhcHBlZFByaW1pdGl2ZShjdXJyZW50TGFzdENvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlV3JhcHBlZFByaW1pdGl2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlT2JqKGN1cnJlbnRLZXksIGluc2lkZUFycmF5LCBsaXRlcmFsS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGpzb25TdHJpbmdbaW5kZXhdID09PSAnWycpIHtcbiAgICAgIHJldHVybiBwYXJzZUFycihjdXJyZW50S2V5LCBhbGxvd3NJbmNvbXBsZXRlKTtcbiAgICB9XG4gICAgaWYgKGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIDQpID09PSAnbnVsbCcpIHtcbiAgICAgIGluZGV4ICs9IDQ7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIDQpID09PSAndHJ1ZScpIHtcbiAgICAgIGluZGV4ICs9IDQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIDUpID09PSAnZmFsc2UnKSB7XG4gICAgICBpbmRleCArPSA1O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VOdW0oKTtcbiAgfTtcbiAgY29uc3QgcGFyc2VTdHIgPSBhbGxvd3NJbmNvbXBsZXRlID0+IHtcbiAgICBpZiAoY29udGFpbmVyU3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBhdCB0b3AgbGV2ZWwsIHNvIHNlZSBpZiB0aGUgdGhlIHNjaGVtYSBhbGxvd3Mgc3RyZWFtaW5nXG4gICAgICBhbGxvd3NJbmNvbXBsZXRlID0gaXNTdHJlYW1pbmcoc2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSBpbmRleDtcbiAgICAvLyBJcyB0aGUgbmV4dCBjaGFyYWN0ZXIgYSBzdHJpbmc/XG4gICAgLy8gcGFyc2VBbnkgY2hlY2tzIGJlZm9yZSBjYWxsaW5nIHBhcnNlU3RyLCBidXQgZnVuY3Rpb25zIHBhcnNpbmdcbiAgICAvLyBrZXkgbmFtZXMgKGkuZS4gcGFyc2VPYmopIGRvIG5vdCwgYW5kIHdlIG5lZWQgdG8gZGV0ZWN0IHBvdGVudGlhbGx5XG4gICAgLy8gbWFsZm9ybWVkIEpTT04gaW1tZWRpYXRlbHkgZm9sbG93aW5nIGEgY29tbWFcbiAgICBpZiAoanNvblN0cmluZ1tzdGFydF0gIT09ICdcIicpIHtcbiAgICAgIHRocm93TWFsZm9ybWVkRXJyb3IoJ1N0cmluZyBleHBlY3RlZCBidXQgbm90IHN0YXJ0ZWQnKTtcbiAgICB9XG4gICAgbGV0IGVzY2FwZSA9IGZhbHNlO1xuICAgIGluZGV4Kys7IC8vIHNraXAgaW5pdGlhbCBxdW90ZVxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiAoanNvblN0cmluZ1tpbmRleF0gIT09ICdcIicgfHwgZXNjYXBlICYmIGpzb25TdHJpbmdbaW5kZXggLSAxXSA9PT0gJ1xcXFwnKSkge1xuICAgICAgZXNjYXBlID0ganNvblN0cmluZ1tpbmRleF0gPT09ICdcXFxcJyA/ICFlc2NhcGUgOiBmYWxzZTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIGlmIChqc29uU3RyaW5nLmNoYXJBdChpbmRleCkgPT0gJ1wiJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZy5zdWJzdHJpbmcoc3RhcnQsICsraW5kZXggLSBOdW1iZXIoZXNjYXBlKSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvd01hbGZvcm1lZEVycm9yKFN0cmluZyhlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbGxvd3NJbmNvbXBsZXRlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgaW5kZXggLSBOdW1iZXIoZXNjYXBlKSkgKyAnXCInKTtcbiAgICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAgIC8vIFN5bnRheEVycm9yOiBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZyhzdGFydCwganNvblN0cmluZy5sYXN0SW5kZXhPZignXFxcXCcpKSArICdcIicpO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrUGFydGlhbEpTT04oJ1VudGVybWluYXRlZCBzdHJpbmcgbGl0ZXJhbCcpO1xuICB9O1xuICBjb25zdCBoYW5kbGVJbmNvbXBsZXRlV3JhcHBlZFByaW1pdGl2ZSA9IHZhbCA9PiB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW5jb21wbGV0ZU5vblN0cmVhbWluZ09iamVjdCgnSW5jb21wbGV0ZSB3cmFwcGVkIHByaW1pdGl2ZSBvYmplY3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgY29uc3QgcGFyc2VXcmFwcGVkUHJpbWl0aXZlID0gKCkgPT4ge1xuICAgIGxvZ2dlci5mb3IoJ3BhcnNlV3JhcHBlZFByaW1pdGl2ZScpLmluZm8oYFBhcnNpbmcgd3JhcHBlZCBwcmltaXRpdmUgb2JqZWN0YCk7XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBpbml0aWFsIGJyYWNlXG4gICAgc2tpcEJsYW5rKCk7XG4gICAgbGV0IHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoanNvblN0cmluZ1tpbmRleF0gIT09ICd9Jykge1xuICAgICAgICBza2lwQmxhbmsoKTtcbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVJbmNvbXBsZXRlV3JhcHBlZFByaW1pdGl2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VTdHIoZmFsc2UpO1xuICAgICAgICBpZiAoa2V5ICE9PSBQUklNSVRJVkVfV1JBUFBFUl9GSUVMRF9OQU1FKSB7XG4gICAgICAgICAgLy8gSG93IGRpZCB3ZSBnZXQgaGVyZSBpZiB0aGlzIGlzbid0IHJlYWxseSBhIHdyYXBwZWQgcHJpbWl0aXZlP1xuICAgICAgICAgIHRocm93TWFsZm9ybWVkRXJyb3IoYFdyYXBwZWQgcHJpbWl0aXZlIGhhcyB1bmV4cGVjdGVkIGtleSBuYW1lOiAke2tleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBza2lwQmxhbmsoKTtcbiAgICAgICAgaW5kZXgrKzsgLy8gc2tpcCBjb2xvblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlV3JhcHBlZFByaW1pdGl2ZScpLmRlYnVnKGBIYW5kbGluZyBrZXk6ICR7a2V5fWApO1xuICAgICAgICAgIGNvbnN0IG1hdGNoaW5nU2NoZW1hID0gY29udGFpbmVyU3RhY2tbY29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgbG9nZ2VyLmZvcigncGFyc2VXcmFwcGVkUHJpbWl0aXZlJykuZGVidWcoJ0ZvdW5kIHRvcC1sZXZlbCBzY2hlbWE6Jyk7XG4gICAgICAgICAgbG9nZ2VyLmZvcigncGFyc2VXcmFwcGVkUHJpbWl0aXZlJykuZGVidWcobWF0Y2hpbmdTY2hlbWEpO1xuICAgICAgICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIG9iamVjdCwgc28gZG9uJ3QgcGFzcyB0aGUga2V5IG5hbWVcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlQW55KCcnLCBpc1N0cmVhbWluZyhtYXRjaGluZ1NjaGVtYSksIGZhbHNlLCB1bmRlZmluZWQpO1xuICAgICAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlV3JhcHBlZFByaW1pdGl2ZScpLmRlYnVnKCdWYWx1ZTonKTtcbiAgICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZVdyYXBwZWRQcmltaXRpdmUnKS5kZWJ1Zyh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZVdyYXBwZWRQcmltaXRpdmUnKS5lcnJvcihlKTtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlSW5jb21wbGV0ZVdyYXBwZWRQcmltaXRpdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHNraXBCbGFuaygpO1xuICAgICAgICBpZiAoanNvblN0cmluZ1tpbmRleF0gPT09ICcsJykgaW5kZXgrKzsgLy8gc2tpcCBjb21tYVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlV3JhcHBlZFByaW1pdGl2ZScpLmVycm9yKGUpO1xuICAgICAgcmV0dXJuIGhhbmRsZUluY29tcGxldGVXcmFwcGVkUHJpbWl0aXZlKHZhbHVlKTtcbiAgICB9XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBmaW5hbCBicmFjZVxuICAgIGNvbnN0IGNvbXBsZXRlZENvbnRhaW5lciA9IGNvbnRhaW5lclN0YWNrLnBvcCgpO1xuICAgIGxvZ2dlci5mb3IoJ3BhcnNlV3JhcHBlZFByaW1pdGl2ZScpLmluZm8oYENvbXBsZXRlZCB3cmFwcGVkIHByaW1pdGl2ZSBjb250YWluZXI6ICR7Y29tcGxldGVkQ29udGFpbmVyID09PSBudWxsIHx8IGNvbXBsZXRlZENvbnRhaW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcGxldGVkQ29udGFpbmVyW2ludGVybmFsXS5kZWZpbml0aW9uLmRlc2NyaXB0aW9ufWApO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlSW5jb21wbGV0ZUFueU9mID0gdmFsID0+IHtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbmNvbXBsZXRlTm9uU3RyZWFtaW5nT2JqZWN0KCdJbmNvbXBsZXRlIGFueU9mIG9iamVjdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9O1xuICBjb25zdCBwYXJzZUFueU9mID0gcGFyZW50S2V5ID0+IHtcbiAgICB2YXIgX2E7XG4gICAgbG9nZ2VyLmZvcigncGFyc2VBbnlPZicpLmluZm8oYFBhcnNpbmcgYW55T2Ygd2l0aCBwYXJlbnQ6ICR7cGFyZW50S2V5fWApO1xuICAgIGluZGV4Kys7IC8vIHNraXAgaW5pdGlhbCBicmFjZVxuICAgIHNraXBCbGFuaygpO1xuICAgIGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBsZXQgY3VycmVudENvbnRhaW5lclN0YWNrSW5kZXggPSBjb250YWluZXJTdGFjay5sZW5ndGggLSAxO1xuICAgIGNvbnN0IG9wdGlvbnNGb3JNYXAgPSAoX2EgPSBjb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2tJbmRleF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgIGNvbnN0IGxpdGVyYWxEaXNjcmltaW5hdG9yTWFwID0gQXJyYXkuaXNBcnJheShvcHRpb25zRm9yTWFwKSA/IGJ1aWxkRGlzY3JpbWluYXRvck1hcChvcHRpb25zRm9yTWFwKSA6IG51bGw7XG4gICAgY29uc3QgZ2V0TWF0Y2hpbmdTY2hlbWFGb3JEaXNjcmltaW5hdG9yID0ga2V5ID0+IHtcbiAgICAgIGlmIChsaXRlcmFsRGlzY3JpbWluYXRvck1hcCAmJiBrZXkgaW4gbGl0ZXJhbERpc2NyaW1pbmF0b3JNYXApIHtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWxEaXNjcmltaW5hdG9yTWFwW2tleV07XG4gICAgICB9XG4gICAgICAvLyBGYWxsYmFjayB0byBudW1lcmljIGRpc2NyaW1pbmF0b3JcbiAgICAgIGNvbnN0IG51bWVyaWNJbmRleCA9IHBhcnNlSW50KGtleSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zRm9yTWFwKSkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBvcHRpb25zRm9yTWFwW251bWVyaWNJbmRleF07XG4gICAgICAgIHJldHVybiBzY2hlbWEgPyB7XG4gICAgICAgICAgc2NoZW1hXG4gICAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlIChqc29uU3RyaW5nW2luZGV4XSAhPT0gJ30nKSB7XG4gICAgICAgIHNraXBCbGFuaygpO1xuICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUluY29tcGxldGVBbnlPZih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VTdHIoZmFsc2UpO1xuICAgICAgICBza2lwQmxhbmsoKTtcbiAgICAgICAgaW5kZXgrKzsgLy8gc2tpcCBjb2xvblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlQW55T2YnKS5kZWJ1ZyhgSGFuZGxpbmcgZGlzY3JpbWluYXRvcjogJHtrZXl9YCk7XG4gICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBnZXRNYXRjaGluZ1NjaGVtYUZvckRpc2NyaW1pbmF0b3Ioa2V5KTtcbiAgICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZUFueU9mJykuZGVidWcoYEZvdW5kIG1hdGNoaW5nIHNjaGVtYSBpbiBjdXJyZW50IGNvbnRhaW5lciBmb3IgJHtrZXl9OiAkeyEhKG1hdGNoaW5nICYmIG1hdGNoaW5nLnNjaGVtYSl9YCk7XG4gICAgICAgICAgaWYgKG1hdGNoaW5nID09PSBudWxsIHx8IG1hdGNoaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaGluZy5zY2hlbWEpIHtcbiAgICAgICAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlQW55T2YnKS5kZWJ1ZygnQWRkaW5nIHNjaGVtYSBmb3IgZGlzY3JpbWluYXRvcicpO1xuICAgICAgICAgICAgbG9nZ2VyLmZvcigncGFyc2VBbnlPZicpLmRlYnVnKG1hdGNoaW5nLnNjaGVtYSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbWF0Y2hpbmcgc2NoZW1hIGlzIGl0c2VsZiBhbiBhbnlPZiwgd2UgbmVlZCB0byBwdXNoIGl0cyBvcHRpb25zIGFycmF5XG4gICAgICAgICAgICAvLyB0byB0aGUgc2NoZW1hIHN0YWNrIGluc3RlYWQgb2YgdGhlIHNjaGVtYVxuICAgICAgICAgICAgaWYgKGlzQW55T2ZUeXBlKG1hdGNoaW5nLnNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyU3RhY2sucHVzaChtYXRjaGluZy5zY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24ub3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250YWluZXJTdGFjay5wdXNoKG9iamVjdCQxKGBBbnlPZiBXcmFwcGVyIGZvciAke2tleX1gLCB7XG4gICAgICAgICAgICAgICAgW2tleV06IG1hdGNoaW5nLnNjaGVtYVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyU3RhY2tJbmRleCA9IGNvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQW55KGtleSwgdHJ1ZSwgZmFsc2UsIG1hdGNoaW5nID09PSBudWxsIHx8IG1hdGNoaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaGluZy5saXRlcmFsS2V5KTtcbiAgICAgICAgICAgIC8vIElmIHdlIG1hdGNoZWQgdmlhIGxpdGVyYWwgZGlzY3JpbWluYXRvciBhbmQgdGhlIGlubmVyIG9iamVjdCBkb2Vzbid0XG4gICAgICAgICAgICAvLyBpbmNsdWRlIHRoZSBsaXRlcmFsIGZpZWxkLCBpbmplY3QgaXQgc28gdGhlIHBhcnNlZCByZXN1bHQgY29uZm9ybXNcbiAgICAgICAgICAgIC8vIHRvIHRoZSBkZWNsYXJlZCBzY2hlbWEuXG4gICAgICAgICAgICBpZiAobGl0ZXJhbERpc2NyaW1pbmF0b3JNYXAgJiYgbWF0Y2hpbmcubGl0ZXJhbEtleSAmJiBtYXRjaGluZy5saXRlcmFsVmFsdWUgJiYgdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICEobWF0Y2hpbmcubGl0ZXJhbEtleSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWVbbWF0Y2hpbmcubGl0ZXJhbEtleV0gPSBtYXRjaGluZy5saXRlcmFsVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZUFueU9mJykuZGVidWcoJ1ZhbHVlOicpO1xuICAgICAgICAgICAgbG9nZ2VyLmZvcigncGFyc2VBbnlPZicpLmRlYnVnKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dNYWxmb3JtZWRFcnJvcihgTm8gc2NoZW1hIGZvdW5kIGZvciBkaXNjcmltaW5hdG9yOiAke2tleX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZUFueU9mJykuZXJyb3IoZSk7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUluY29tcGxldGVBbnlPZih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEJsYW5rKCk7XG4gICAgICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJywnKSBpbmRleCsrOyAvLyBza2lwIGNvbW1hXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmZvcigncGFyc2VBbnlPZicpLmVycm9yKGUpO1xuICAgICAgcmV0dXJuIGhhbmRsZUluY29tcGxldGVBbnlPZih2YWx1ZSk7XG4gICAgfVxuICAgIGluZGV4Kys7IC8vIHNraXAgZmluYWwgYnJhY2VcbiAgICBjb25zdCBjb21wbGV0ZWRDb250YWluZXIgPSBjb250YWluZXJTdGFjay5wb3AoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb21wbGV0ZWRDb250YWluZXIpKSB7XG4gICAgICBsb2dnZXIuZm9yKCdwYXJzZUFueU9mJykuZGVidWcoYENvbXBsZXRlZCBuZXN0ZWQgYW55T2YgY29udGFpbmVyYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlQW55T2YnKS5kZWJ1ZyhgQ29tcGxldGVkIGFueU9mIGNvbnRhaW5lcjogJHtjb21wbGV0ZWRDb250YWluZXIgPT09IG51bGwgfHwgY29tcGxldGVkQ29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wbGV0ZWRDb250YWluZXJbaW50ZXJuYWxdLmRlZmluaXRpb24uZGVzY3JpcHRpb259YCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlSW5jb21wbGV0ZU9iamVjdCA9IChjdXJyZW50Q29udGFpbmVyU3RhY2tJbmRleCwgb2JqLCBsaXRlcmFsS2V5KSA9PiB7XG4gICAgY29uc3QgY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFja0luZGV4XTtcbiAgICBpZiAoaXNTdHJlYW1pbmcoY3VycmVudENvbnRhaW5lcikpIHtcbiAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlT2JqJykuZGVidWcoJ0luZGV4ID49IGxlbmd0aDogcmV0dXJuaW5nIHBhcnRpYWwgb2JqZWN0Jyk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBsb2dnZXIuZm9yKCdwYXJzZU9iaicpLmRlYnVnKCdJbmRleCA+PSBsZW5ndGg6IG9wdGluZyBub3QgdG8gcmV0dXJuIHBhcnRpYWwgb2JqIGlmIG5vbi1zdHJlYW1pbmcgcHJvcGVydGllcyBhcmUgbWlzc2luZycpO1xuICAgIC8vIEFyZSBhbGwgbm9uLXN0cmVhbWluZyBmaWVsZHMgcHJlc2VudD9cbiAgICBpZiAoT2JqZWN0LmVudHJpZXMoY3VycmVudENvbnRhaW5lcltpbnRlcm5hbF0uZGVmaW5pdGlvbi5zaGFwZSkuZXZlcnkoKFtrZXksIHN1YlNjaGVtYV0pID0+IHtcbiAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlT2JqJykuZGVidWcoYGtleSAke2tleX0gaXMgc3RyZWFtaW5nOiAke2lzU3RyZWFtaW5nKHN1YlNjaGVtYSl9IGFuZCBwcmVzZW50OiAke2tleSBpbiBvYmp9YCk7XG4gICAgICBpZiAoa2V5ID09PSBsaXRlcmFsS2V5KSB7XG4gICAgICAgIC8vIEEgbGl0ZXJhbCBrZXkgZXh0cmFjdGVkIGZyb20gYW4gYW55T2YgdG8gYmUgYSBkaXNjcmltaW5hdG9yIHdvbid0IGJlIGluIHRoZVxuICAgICAgICAvLyBvYmplY3QgdW50aWwgYWZ0ZXIgaXQgaXMgZmluaXNoZWQgcGFyc2luZywgc28gc2tpcCBjaGVja2luZyBmb3IgaXQuXG4gICAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlT2JqJykuZGVidWcoYGtleSAke2tleX0gaXMgYW4gZXh0cmFjdGVkIGRpc2NyaW1pbmF0b3IsIHNvIGl0IHdpbGwgbm90IGJlIHByZXNlbnRgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGlzIGtleSBpcyBzdHJlYW1pbmcgYW5kIG5vdCBwcmVzZW50LCBhZGQgYW4gXCJlbXB0eVwiIHZhbHVlXG4gICAgICBpZiAoaXNTdHJlYW1pbmcoc3ViU2NoZW1hKSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gb2JqKSkge1xuICAgICAgICAgIGlmIChpc1N0cmluZ1R5cGUoc3ViU2NoZW1hKSB8fCBpc0xpdGVyYWxUeXBlKHN1YlNjaGVtYSkgfHwgaXNFbnVtVHlwZShzdWJTY2hlbWEpKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheVR5cGUoc3ViU2NoZW1hKSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBbXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0VHlwZShzdWJTY2hlbWEpKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZFN0cmVhbWluZ1R5cGUoJ1VuZXhwZWN0ZWQgc2NoZW1hIHR5cGUgZm9yIGEgc3RyZWFtaW5nIHByb3AnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBrZXkgc2NoZW1hIGlzIGFuIGFueU9mIGFuZCBpbmNsdWRlcyBudWxsaXNoLCBkZWZhdWx0IHRvIG51bGxcbiAgICAgIGlmIChpc0FueU9mVHlwZShzdWJTY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBzdWJTY2hlbWFbaW50ZXJuYWxdLmRlZmluaXRpb24ub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMuc29tZShvcHQgPT4gaXNOdWxsVHlwZShvcHQpKSkge1xuICAgICAgICAgIG9ialtrZXldID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSW5jb21wbGV0ZU5vblN0cmVhbWluZ09iamVjdCgnSW5jb21wbGV0ZSBidXQgbm9uLXN0cmVhbWluZyBvYmplY3QgZm91bmQnKTtcbiAgfTtcbiAgY29uc3QgcGFyc2VPYmogPSAocGFyZW50S2V5LCBpbnNpZGVBcnJheSwgbGl0ZXJhbEtleSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbG9nZ2VyLmZvcigncGFyc2VPYmonKS5pbmZvKGBQYXJzaW5nIG9iamVjdCB3aXRoIHBhcmVudDogJHtwYXJlbnRLZXl9YCk7XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBpbml0aWFsIGJyYWNlXG4gICAgc2tpcEJsYW5rKCk7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgbGV0IGluQW55T2ZXcmFwcGVyID0gZmFsc2U7XG4gICAgLy8gSWYgd2UgYXJlIG5vdCBpbiBhbiBhcnJheSwgZmluZCBrZXkgaW4gY3VycmVudCBsZXZlbCBvZiBkb2N1bWVudCBzdG9jaywgYW5kIGFkZCB0byBzdGFja1xuICAgIGlmIChwYXJlbnRLZXkgIT09ICcnKSB7XG4gICAgICAvLyBBcmUgd2UgaW4gYW55IGFueU9mP1xuICAgICAgY29uc3QgY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lclN0YWNrW2NvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gTm90IGFuIGFueU9mLCBzbyBtb3ZlIGRvd24gYSBsZXZlbFxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGN1cnJlbnRDb250YWluZXIpKSB7XG4gICAgICAgIC8vIElmIHBhcmVudEtleSBpcyBzZXQsIHdlIGFyZSBub3QgaW4gYW4gYXJyYXksIHNvIGdldCB0aGUgbmV4dCBzdGFjayBjb250YWluZXJcbiAgICAgICAgLy8gKGFycmF5cyBoYW5kbGUgaXQgZGlmZmVyZW50bHksIHNvIHRoZXkgY2FuIGRvIGNsZWFuIHVwIHdoZW4gdGhlIGFycmF5IGlzIGNvbXBsZXRlKVxuICAgICAgICBjb25zdCBuZXh0Q29udGFpbmVyID0gY3VycmVudENvbnRhaW5lcltpbnRlcm5hbF0uZGVmaW5pdGlvbi5zaGFwZVtwYXJlbnRLZXldO1xuICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZU9iaicpLmRlYnVnKGBTdGFydGluZyBuZXcgb2JqZWN0IHdpdGgga2V5OiAke3BhcmVudEtleX1gKTtcbiAgICAgICAgbG9nZ2VyLmZvcigncGFyc2VPYmonKS5kZWJ1ZyhuZXh0Q29udGFpbmVyKTtcbiAgICAgICAgaWYgKG5leHRDb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93TWFsZm9ybWVkRXJyb3IoYEtleTogJHtwYXJlbnRLZXl9IG5vdCBleHBlY3RlZCBpbiBjb250YWluZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXJTdGFjay5wdXNoKG5leHRDb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyU3RhY2tJbmRleCA9IGNvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDE7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlIChqc29uU3RyaW5nW2luZGV4XSAhPT0gJ30nKSB7XG4gICAgICAgIHNraXBCbGFuaygpO1xuICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUluY29tcGxldGVPYmplY3QoY3VycmVudENvbnRhaW5lclN0YWNrSW5kZXgsIG9iaiwgbGl0ZXJhbEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VTdHIoZmFsc2UpO1xuICAgICAgICBza2lwQmxhbmsoKTtcbiAgICAgICAgaW5kZXgrKzsgLy8gc2tpcCBjb2xvblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlT2JqJykuZGVidWcoYEhhbmRsaW5nIGtleTogJHtrZXl9YCk7XG4gICAgICAgICAgY29uc3QgY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFja0luZGV4XTtcbiAgICAgICAgICAvLyBJcyB0aGlzIGFuIGFueU9mICh3aGljaCBjYW4gaGFwcGVuIGZvciBuZXN0ZWQgYW55T2ZzKVxuICAgICAgICAgIGlmIChpc0FueU9mVHlwZShjdXJyZW50Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgLy8gUHJvcGVydHkgaXMgYW55T2YsIHNvIHB1c2ggb3B0aW9uIGxpc3QgdG8gY29udGFpbmVyIHN0YWNrXG4gICAgICAgICAgICBjb250YWluZXJTdGFjay5wdXNoKGN1cnJlbnRDb250YWluZXJbaW50ZXJuYWxdLmRlZmluaXRpb24ub3B0aW9ucyk7XG4gICAgICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZU9iaicpLmRlYnVnKGBPYmplY3Qga2V5ICR7a2V5fSBpbiBjb250YWluZXIgJHtjdXJyZW50Q29udGFpbmVyU3RhY2tJbmRleH0gaXMgYW55T2ZgKTtcbiAgICAgICAgICAgIC8vIEFueU9mcyBhcmUgbmV2ZXIgZGlyZWN0bHkgc3RyZWFtaW5nXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlQW55KGtleSwgZmFsc2UsIGZhbHNlLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgaW5BbnlPZldyYXBwZXIgPSB0cnVlO1xuICAgICAgICAgICAgbG9nZ2VyLmZvcigncGFyc2VPYmonKS5kZWJ1ZygnVmFsdWU6Jyk7XG4gICAgICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZU9iaicpLmRlYnVnKHZhbHVlKTtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByZWd1bGFyIG9iamVjdCwgc28gZmluZCB0aGUgc2NoZW1hIGZvciB0aGUga2V5XG4gICAgICAgICAgICBjb25zdCBzY2hlbWFGcmFnbWVudEZvcktleSA9IGN1cnJlbnRDb250YWluZXJbaW50ZXJuYWxdLmRlZmluaXRpb24uc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGlmIChpc0FueU9mVHlwZShzY2hlbWFGcmFnbWVudEZvcktleSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvcGVydHkgaXMgYW55T2YsIHNvIHB1c2ggb3B0aW9uIGxpc3QgdG8gY29udGFpbmVyIHN0YWNrXG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0YWNrLnB1c2goc2NoZW1hRnJhZ21lbnRGb3JLZXlbaW50ZXJuYWxdLmRlZmluaXRpb24ub3B0aW9ucyk7XG4gICAgICAgICAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlT2JqJykuZGVidWcoYE9iamVjdCBrZXkgJHtrZXl9IGluIGNvbnRhaW5lciAke2N1cnJlbnRDb250YWluZXJTdGFja0luZGV4fSBpcyBhbnlPZmApO1xuICAgICAgICAgICAgICAvLyBBbnlPZnMgYXJlIG5ldmVyIGRpcmVjdGx5IHN0cmVhbWluZ1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlQW55KGtleSwgZmFsc2UsIGZhbHNlLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICBpbkFueU9mV3JhcHBlciA9IHRydWU7XG4gICAgICAgICAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlT2JqJykuZGVidWcoJ1ZhbHVlOicpO1xuICAgICAgICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZU9iaicpLmRlYnVnKHZhbHVlKTtcbiAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRLZXlBbGxvd3NJbmNvbXBsZXRlID0gaXNTdHJlYW1pbmcoc2NoZW1hRnJhZ21lbnRGb3JLZXkpO1xuICAgICAgICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZU9iaicpLmRlYnVnKGBPYmplY3Qga2V5ICR7a2V5fSBpbiBjb250YWluZXIgJHtjdXJyZW50Q29udGFpbmVyU3RhY2tJbmRleH0gYWxsb3dzIGluY29tcGxldGU6ICR7Y3VycmVudEtleUFsbG93c0luY29tcGxldGV9YCk7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VBbnkoa2V5LCBjdXJyZW50S2V5QWxsb3dzSW5jb21wbGV0ZSwgZmFsc2UsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlT2JqJykuZGVidWcoJ1ZhbHVlOicpO1xuICAgICAgICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZU9iaicpLmRlYnVnKHZhbHVlKTtcbiAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZU9iaicpLmVycm9yKGUpO1xuICAgICAgICAgIHJldHVybiBoYW5kbGVJbmNvbXBsZXRlT2JqZWN0KGN1cnJlbnRDb250YWluZXJTdGFja0luZGV4LCBvYmosIGxpdGVyYWxLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHNraXBCbGFuaygpO1xuICAgICAgICBpZiAoanNvblN0cmluZ1tpbmRleF0gPT09ICcsJykgaW5kZXgrKzsgLy8gc2tpcCBjb21tYVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlT2JqJykuZXJyb3IoZSk7XG4gICAgICByZXR1cm4gaGFuZGxlSW5jb21wbGV0ZU9iamVjdChjdXJyZW50Q29udGFpbmVyU3RhY2tJbmRleCwgb2JqLCBsaXRlcmFsS2V5KTtcbiAgICB9XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBmaW5hbCBicmFjZVxuICAgIC8vIEFyZSB3ZSBpbnNpZGUgYW4gYXJyYXk/ICBUaGV5IGhhbmRsZSBhZGRpbmcvcmVtb3Zpbmcgc3RhY2sgY29udGFpbmVycyBmb3IgdGhlbXNlbHZlc1xuICAgIGlmICghaW5zaWRlQXJyYXkgfHwgaW5BbnlPZldyYXBwZXIpIHtcbiAgICAgIC8vIElmIHdlIGp1c3QgY29tcGxldGVkIGFuIGFueU9mIHdyYXBwZXIsIHdlIG5lZWQgdG8gcG9wIHRoZSBvcHRpb25zIGFycmF5IG9mZiB0aGUgc3RhY2tcbiAgICAgIGlmICghaW5zaWRlQXJyYXkgJiYgaW5BbnlPZldyYXBwZXIpIHtcbiAgICAgICAgY29uc3QgY29tcGxldGVkQ29udGFpbmVyID0gY29udGFpbmVyU3RhY2sucG9wKCk7XG4gICAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlT2JqJykuZGVidWcoYEFsc28gY29tcGxldGVkIGFueU9mIGNvbnRhaW5lcjogJHtjb21wbGV0ZWRDb250YWluZXJ9YCk7XG4gICAgICB9XG4gICAgICAvLyBEb25lIHdpdGggdGhpcyBjb250YWluZXIsIHNvIHBvcCBvZmYgc3RhY2tcbiAgICAgIGNvbnN0IGNvbXBsZXRlZENvbnRhaW5lciA9IGNvbnRhaW5lclN0YWNrLnBvcCgpO1xuICAgICAgbG9nZ2VyLmZvcigncGFyc2VPYmonKS5kZWJ1ZyhgQ29tcGxldGVkIG9iamVjdCBjb250YWluZXI6ICR7KF9iID0gKF9hID0gY29tcGxldGVkQ29udGFpbmVyID09PSBudWxsIHx8IGNvbXBsZXRlZENvbnRhaW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcGxldGVkQ29udGFpbmVyW2ludGVybmFsXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlZmluaXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXNjcmlwdGlvbn1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmZvcigncGFyc2VPYmonKS5kZWJ1ZygnSW5zaWRlIGFycmF5LiBPYmplY3QgY29tcGxldGVkLCBidXQga2VlcGluZyBjb250YWluZXIgc3RhY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbiAgY29uc3QgcGFyc2VBcnIgPSAoY3VycmVudEtleSwgYWxsb3dzSW5jb21wbGV0ZSkgPT4ge1xuICAgIGlmIChjb250YWluZXJTdGFjay5sZW5ndGggPT09IDEgJiYgaXNBcnJheVR5cGUoY29udGFpbmVyU3RhY2tbMF0pKSB7XG4gICAgICAvLyBTZWUgaWYgdGhlIHRoZSBzY2hlbWEgYWxsb3dzIHN0cmVhbWluZ1xuICAgICAgYWxsb3dzSW5jb21wbGV0ZSA9IGlzU3RyZWFtaW5nKHNjaGVtYSk7XG4gICAgfVxuICAgIGluZGV4Kys7IC8vIHNraXAgaW5pdGlhbCBicmFja2V0XG4gICAgbG9nZ2VyLmZvcigncGFyc2VBcnInKS5pbmZvKCdwYXJzZUFycjogU3RhcnQnKTtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBsZXQgYXJyYXlDb250YWluZXIgPSBjb250YWluZXJTdGFja1tjb250YWluZXJTdGFjay5sZW5ndGggLSAxXVtpbnRlcm5hbF0uZGVmaW5pdGlvbi5lbGVtZW50O1xuICAgIGlmIChjdXJyZW50S2V5KSB7XG4gICAgICBhcnJheUNvbnRhaW5lciA9IGNvbnRhaW5lclN0YWNrW2NvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdW2ludGVybmFsXS5kZWZpbml0aW9uLnNoYXBlW2N1cnJlbnRLZXldW2ludGVybmFsXS5kZWZpbml0aW9uLmVsZW1lbnQ7XG4gICAgfVxuICAgIGxvZ2dlci5mb3IoJ3BhcnNlQXJyJykuZGVidWcoJ0FycmF5IGNvbnRhaW5lcjogJyk7XG4gICAgbG9nZ2VyLmZvcigncGFyc2VBcnInKS5kZWJ1ZyhhcnJheUNvbnRhaW5lcik7XG4gICAgbG9nZ2VyLmZvcigncGFyc2VBcnInKS5kZWJ1ZyhgQWxsb3dzIHN0cmVhbWluZz8gJHthbGxvd3NJbmNvbXBsZXRlfWApO1xuICAgIC8vIGxvZ2dlci5sb2coYElzIGFueU9mPyAke3MuaXNBbnlPZlR5cGUoYXJyYXlDb250YWluZXIpfWApO1xuICAgIGxldCBjb250YWluZXJOZWVkc1BvcHBpbmcgPSBmYWxzZTtcbiAgICBsZXQgY29udGVudHNBbGxvd0luY29tcGxldGUgPSBmYWxzZTtcbiAgICAvLyBJZiB0aGlzIGFycmF5IGlzIG9mIG9iamVjdHMsIHB1c2ggdGhlIGNvbnRhaW5lciBvbnRvIHRoZSBzdGFja1xuICAgIGlmIChpc09iamVjdFR5cGUoYXJyYXlDb250YWluZXIpKSB7XG4gICAgICBsb2dnZXIuZm9yKCdwYXJzZUFycicpLmRlYnVnKCdBcnJheSBjb250YWluZXIgaXMgb2JqZWN0IHR5cGUnKTtcbiAgICAgIGNvbnRhaW5lclN0YWNrLnB1c2goYXJyYXlDb250YWluZXIpO1xuICAgICAgY29udGFpbmVyTmVlZHNQb3BwaW5nID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQW55T2ZUeXBlKGFycmF5Q29udGFpbmVyKSkge1xuICAgICAgbG9nZ2VyLmZvcigncGFyc2VBcnInKS5kZWJ1ZygnQXJyYXkgY29udGFpbmVyIGlzIGFueU9mLiBQdXNoaW5nIGFueU9mIGFycmF5IHRvIGNvbnRhaW5lciBzdGFjaycpO1xuICAgICAgY29udGFpbmVyU3RhY2sucHVzaChhcnJheUNvbnRhaW5lcltpbnRlcm5hbF0uZGVmaW5pdGlvbi5vcHRpb25zKTtcbiAgICAgIGNvbnRhaW5lck5lZWRzUG9wcGluZyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlQXJyJykuZGVidWcoJ0FycmF5IGNvbnRhaW5lciBpcyBwcmltaXRpdmUnKTtcbiAgICAgIC8vIEl0J3Mgbm90IGFuIG9iamVjdCwgc28gY2hlY2sgaWYgaXQgaXMgYSBzdHJlYW1pbmcgcHJpbWl0aXZlXG4gICAgICBjb250ZW50c0FsbG93SW5jb21wbGV0ZSA9IGlzU3RyZWFtaW5nKGFycmF5Q29udGFpbmVyKTtcbiAgICAgIGxvZ2dlci5mb3IoJ3BhcnNlQXJyJykuZGVidWcoYEFycmF5IHByaW1pdGl2ZSBjb250ZW50IGFsbG93cyBzdHJlYW1pbmc6ICR7Y29udGVudHNBbGxvd0luY29tcGxldGV9YCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoanNvblN0cmluZ1tpbmRleF0gIT09ICddJykge1xuICAgICAgICBsb2dnZXIuZm9yKCdwYXJzZUFycicpLmRlYnVnKGBBcnJheSBjb250ZW50IGFsbG93cyBpbmNvbXBsZXRlOiAke2NvbnRlbnRzQWxsb3dJbmNvbXBsZXRlfWApO1xuICAgICAgICBhcnIucHVzaChwYXJzZUFueSgnJywgY29udGVudHNBbGxvd0luY29tcGxldGUsIHRydWUsIHVuZGVmaW5lZCkpO1xuICAgICAgICBza2lwQmxhbmsoKTtcbiAgICAgICAgaWYgKGpzb25TdHJpbmdbaW5kZXhdID09PSAnLCcpIHtcbiAgICAgICAgICBpbmRleCsrOyAvLyBza2lwIGNvbW1hXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChfYSkge1xuICAgICAgLy8gbG9nZ2VyLmZvcigncGFyc2VBcnInKS5lcnJvcihlKTtcbiAgICAgIGlmIChhbGxvd3NJbmNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG4gICAgICBtYXJrUGFydGlhbEpTT04oXCJFeHBlY3RlZCAnXScgYXQgZW5kIG9mIGFycmF5XCIpO1xuICAgIH1cbiAgICBpbmRleCsrOyAvLyBza2lwIGZpbmFsIGJyYWNrZXRcbiAgICAvLyBBcnJheSB3YXMgY29tcGxldGVkLCBzbyBwdXQgY29udGFpbmVyIG9mZiBpZiBuZWVkZWRcbiAgICBpZiAoY29udGFpbmVyTmVlZHNQb3BwaW5nKSB7XG4gICAgICBjb250YWluZXJTdGFjay5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcbiAgY29uc3QgcGFyc2VOdW0gPSAoKSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBpZiAoanNvblN0cmluZyA9PT0gJy0nKSB0aHJvd01hbGZvcm1lZEVycm9yKFwiTm90IHN1cmUgd2hhdCAnLScgaXNcIik7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBKU09OIHN0cmluZyBzdGFydHMgd2l0aCBhIG51bWJlciwgc28gd2UnbGwgdHJ5IHRvIHBhcnNlIHRoZSB3aG9sZSB0aGluZyBhcyBvbmUuXG4gICAgICAgIC8vIFRodXMsIHNldCBpbmRleCB0byBsZW5ndGguXG4gICAgICAgIGluZGV4ID0ganNvblN0cmluZy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvd01hbGZvcm1lZEVycm9yKFN0cmluZyhlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXg7XG4gICAgaWYgKGpzb25TdHJpbmdbaW5kZXhdID09PSAnLScpIGluZGV4Kys7XG4gICAgd2hpbGUgKGpzb25TdHJpbmdbaW5kZXhdICYmICcsXX0nLmluZGV4T2YoanNvblN0cmluZ1tpbmRleF0pID09PSAtMSkgaW5kZXgrKztcbiAgICBpZiAoaW5kZXggPT0gbGVuZ3RoKSBtYXJrUGFydGlhbEpTT04oJ1VudGVybWluYXRlZCBudW1iZXIgbGl0ZXJhbCcpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgaW5kZXgpKTtcbiAgICB9IGNhdGNoIChfYSkge1xuICAgICAgaWYgKGpzb25TdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBpbmRleCkgPT09ICctJykgbWFya1BhcnRpYWxKU09OKFwiTm90IHN1cmUgd2hhdCAnLScgaXNcIik7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZyhzdGFydCwganNvblN0cmluZy5sYXN0SW5kZXhPZignZScpKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93TWFsZm9ybWVkRXJyb3IoU3RyaW5nKGUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHNraXBCbGFuayA9ICgpID0+IHtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGggJiYgJyBcXG5cXHJcXHQnLmluY2x1ZGVzKGpzb25TdHJpbmdbaW5kZXhdKSkge1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH07XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VBbnkoJycsIGZhbHNlLCBmYWxzZSwgdW5kZWZpbmVkKTtcbiAgICAvLyBXZSByZXR1cm5lZCwgYnV0IGhhdmUgd2Ugbm90IGNvbnN1bWVkIHRoZSB3aG9sZSBsZW5ndGg/XG4gICAgLy8gV2Ugb25seSBjaGVjayB0aGlzIG9uIGZpbmlzaGVkIG1lc3NhZ2VzIHNvIGFzIG5vdCB0byBzcGFtXG4gICAgLy8gdGhlIHdhcm5pbmcgb24gZWFjaCBmZXctY2hhcmFjdGVyIGNodW5rIG9mIGEgc3RyZWFtaW5nXG4gICAgLy8gbWVzc2FnZS5cbiAgICBpZiAoYXNzdW1lRmluaXNoZWRNZXNzYWdlICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAvLyBOQjogV2UgY2FsbCBjb25zb2xlLndhcm4gZGlyZWN0bHkgaGVyZSBpbnN0ZWFkIG9mIHVzaW5nIHRoZVxuICAgICAgLy8gbG9nZ2VyIG1lY2hhbmlzbSwgYmVjYXVzZSBnZXR0aW5nIGhlcmUgYWxtb3N0IGFsd2F5cyBtZWFucyB0aGVcbiAgICAgIC8vIExMTSBoYWxsdWNpbmF0ZWQsIGFkZGluZyBleHRyYSBzdHVmZiBhZnRlciB0aGUgcmVzcG9uc2Ugb3IgZW5jb2RlZFxuICAgICAgLy8gaXQgaW4gYSBzdHJhbmdlIHdheSAobGlrZSBlc2NhcGluZyBwYXJ0IG9yIGFsbCBvZiB0aGUgSlNPTikuXG4gICAgICBjb25zb2xlLndhcm4oYEV4dHJhIGRhdGEgZGV0ZWN0ZWQgYWZ0ZXIgcGFyc2luZy5cXG5cblBhcnNlZDogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfVxcblxuTGVmdCBvdmVyOiAke2pzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4KX1cXG5cblRoaXMgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGV4dHJhIG9yIGluY29ycmVjdGx5IGZvcm1hdHRlZCBkYXRhIGJlaW5nIHJldHVybmVkIGJ5IHRoZSBcbkxMTSwgZGVzcGl0ZSByZXF1ZXN0aW5nIGRhdGEgd2l0aCBhIHBhcnRpY3VsYXIgc3RydWN0dXJlLlxuXG5EaWZmZXJlbnQgbW9kZWxzLCBieSBkZWZhdWx0LCBoYW5kbGUgY29tcGxleCBzdHJ1Y3R1cmVkIGRhdGEgd2l0aCB2YXJpZWQgbGV2ZWxzIG9mIGFjY3VyYWN5LlxuXG5Nb2RlbCBiZWhhdmlvciBjYW4gdHlwaWNhbGx5IGJlIGltcHJvdmVkIGJ5OlxuLSBBZGRpbmcgMS0zIGV4YW1wbGVzIG9mIGNvcnJlY3Qgb3V0cHV0IHRvIHlvdXIgcHJvbXB0IChha2EgZmV3LXNob3QpLlxuLSBBZGRpbmcgZ3VhcmRyYWlscyB0byB0aGUgcHJvbXB0IGxpa2UgXCJEbyBub3QgZXNjYXBlIHRvb2wgZnVuY3Rpb24gYXJndW1lbnRzLlwiXG5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgSW5jb21wbGV0ZU5vblN0cmVhbWluZ09iamVjdCkge1xuICAgICAgbG9nZ2VyLmZvcignX3BhcnNlSlNPTicpLmVycm9yKCdHb3QgaW5jb21wbGV0ZSBvYmplY3QgZXJyb3IgYXQgdG9wIGxldmVsJyk7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChlIGluc3RhbmNlb2YgUGFydGlhbEpTT04pIHtcbiAgICAgIGxvZ2dlci5mb3IoJ19wYXJzZUpTT04nKS5lcnJvcignR290IHVudGVybWluYXRlZCBjb250YWluZXInKTtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBNYWxmb3JtZWRKU09OKSB7XG4gICAgICBpZiAoZS5tZXNzYWdlLmluY2x1ZGVzKCdFeHBvbmVudCBwYXJ0IGlzIG1pc3NpbmcgYSBudW1iZXInKSkge1xuICAgICAgICBsb2dnZXIuZm9yKCdfcGFyc2VKU09OJykuZXJyb3IoJ0ZvdW5kIG51bWJlciB3aXRoIGV4cG9uZW50IHNhbnMgbnVtYmVyJyk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmIChlLm1lc3NhZ2UuaW5jbHVkZXMoJ1VudGVybWluYXRlZCBmcmFjdGlvbmFsIG51bWJlcicpKSB7XG4gICAgICAgIGxvZ2dlci5mb3IoJ19wYXJzZUpTT04nKS5lcnJvcignRm91bmQgbnVtYmVyIHdpdGggZGVjaW1hbCBwb2ludCBzYW5zIG51bWJlcnMnKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5jbGFzcyBTdHJlYW1TY2hlbWFQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICB0aGlzLmRhdGFTdHJpbmcgPSAnJztcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgfVxuICBwYXJzZShpdGVtLCBhc3N1bWVGaW5pc2hlZE1lc3NhZ2UpIHtcbiAgICB0aGlzLmRhdGFTdHJpbmcgKz0gaXRlbTtcbiAgICBjb25zdCBjdXJyUmVzdWx0ID0gcGFyc2VKU09OKHRoaXMuZGF0YVN0cmluZywgdGhpcy5zY2hlbWEsIGFzc3VtZUZpbmlzaGVkTWVzc2FnZSk7XG4gICAgcmV0dXJuIGN1cnJSZXN1bHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHZpZXcgbWVzc2FnZSB0byBhbiBpbnRlcm5hbCBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIHZpZXcgbWVzc2FnZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGludGVybmFsIG1lc3NhZ2UuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdG9JbnRlcm5hbE1lc3NhZ2VzRnJvbVZpZXcobWVzc2FnZSkge1xuICBzd2l0Y2ggKG1lc3NhZ2Uucm9sZSkge1xuICAgIGNhc2UgJ3VzZXInOlxuICAgICAge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50XG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIGNhc2UgJ2Fzc2lzdGFudCc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgICB0b29sQ2FsbElkczogbWVzc2FnZS50b29sQ2FsbHMubWFwKHRvb2xDYWxsID0+IHRvb2xDYWxsLnRvb2xDYWxsSWQpXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBpbnRlcm5hbCBtZXNzYWdlIHRvIGEgdmlldyBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGludGVybmFsIG1lc3NhZ2UgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB2aWV3IG1lc3NhZ2UuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdG9WaWV3TWVzc2FnZXNGcm9tSW50ZXJuYWwobWVzc2FnZSwgdG9vbENhbGxzLCB0b29scywgb3V0cHV0U2NoZW1hLCBzdHJlYW1pbmcgPSB0cnVlKSB7XG4gIHN3aXRjaCAobWVzc2FnZS5yb2xlKSB7XG4gICAgY2FzZSAndXNlcic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnRcbiAgICAgICAgfV07XG4gICAgICB9XG4gICAgY2FzZSAnZXJyb3InOlxuICAgICAge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICByb2xlOiAnZXJyb3InLFxuICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudFxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICBjYXNlICdhc3Npc3RhbnQnOlxuICAgICAge1xuICAgICAgICBjb25zdCB0YXRlciA9IG91dHB1dFNjaGVtYSA/IG5ldyBTdHJlYW1TY2hlbWFQYXJzZXIob3V0cHV0U2NoZW1hKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSAnc3RyaW5nJyAmJiB0YXRlcikge1xuICAgICAgICAgIGNvbnRlbnQgPSB0YXRlci5wYXJzZShtZXNzYWdlLmNvbnRlbnQsICFzdHJlYW1pbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuY29udGVudCAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNvbnRlbnQgPSBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICB0b29sQ2FsbHM6IG1lc3NhZ2UudG9vbENhbGxJZHMuZmxhdE1hcCh0b29sQ2FsbElkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzW3Rvb2xDYWxsSWRdO1xuICAgICAgICAgICAgY29uc3QgdG9vbCA9IHRvb2xzLmZpbmQodG9vbCA9PiB0b29sLm5hbWUgPT09IHRvb2xDYWxsLm5hbWUpO1xuICAgICAgICAgICAgaWYgKCF0b29sKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b29sQXJncyA9IHRvb2xDYWxsLmFyZ3VtZW50cztcbiAgICAgICAgICAgIC8vIE9sbGFtYSB3aWxsIHJldHVybiBQT0pPc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sQ2FsbC5hcmd1bWVudHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHRvb2xBcmdzID0gSlNPTi5zdHJpbmdpZnkodG9vbENhbGwuYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodG9vbENhbGwuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAndG9vbCcsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBpc0hhc2hicm93blR5cGUodG9vbC5zY2hlbWEpID8gbmV3IFN0cmVhbVNjaGVtYVBhcnNlcih0b29sLnNjaGVtYSkucGFyc2UodG9vbEFyZ3MsICFzdHJlYW1pbmcpIDogSlNPTi5wYXJzZSh0b29sQXJncyksXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBpbnRlcm5hbCBtb2RlbHMgZG9uJ3QgdXNlIGEgdW5pb24sIHNpbmNlIHRoYXQgdGVuZHMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxpY2F0ZSByZWR1Y2VyIGxvZ2ljLiBUaGlzIGlzIG5lY2Vzc2FyeSB0byB1cGxpZnQgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVybmFsIG1vZGVsIGludG8gdGhlIHZpZXcgdW5pb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdG9vbENhbGwucmVzdWx0XG4gICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAndG9vbCcsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogdG9vbENhbGwucHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGlzSGFzaGJyb3duVHlwZSh0b29sLnNjaGVtYSkgPyBuZXcgU3RyZWFtU2NoZW1hUGFyc2VyKHRvb2wuc2NoZW1hKS5wYXJzZSh0b29sQXJncywgIXN0cmVhbWluZykgOiBudWxsXG4gICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfV07XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGludGVybmFsIG1lc3NhZ2UgdG8gYW4gQVBJIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgaW50ZXJuYWwgbWVzc2FnZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHRvb2xDYWxscyAtIFRoZSB0b29sIGNhbGxzIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgQVBJIG1lc3NhZ2UuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdG9BcGlNZXNzYWdlc0Zyb21JbnRlcm5hbChtZXNzYWdlLCB0b29sQ2FsbHMpIHtcbiAgc3dpdGNoIChtZXNzYWdlLnJvbGUpIHtcbiAgICBjYXNlICd1c2VyJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgIGNvbnRlbnQ6IHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09ICdzdHJpbmcnID8gbWVzc2FnZS5jb250ZW50IDogSlNPTi5zdHJpbmdpZnkobWVzc2FnZS5jb250ZW50KVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICBjYXNlICdhc3Npc3RhbnQnOlxuICAgICAge1xuICAgICAgICBjb25zdCB0b29sQ2FsbHNGb3JNZXNzYWdlID0gdG9vbENhbGxzLmZpbHRlcih0b29sQ2FsbCA9PiBtZXNzYWdlLnRvb2xDYWxsSWRzLmluY2x1ZGVzKHRvb2xDYWxsLmlkKSk7XG4gICAgICAgIGNvbnN0IHRvb2xNZXNzYWdlcyA9IHRvb2xDYWxsc0Zvck1lc3NhZ2UuZmxhdE1hcCh0b29sQ2FsbCA9PiB7XG4gICAgICAgICAgaWYgKHRvb2xDYWxsLnN0YXR1cyAhPT0gJ2RvbmUnIHx8ICF0b29sQ2FsbC5yZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICByb2xlOiAndG9vbCcsXG4gICAgICAgICAgICBjb250ZW50OiB0b29sQ2FsbC5yZXN1bHQsXG4gICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC5uYW1lXG4gICAgICAgICAgfV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgICAgdG9vbENhbGxzOiB0b29sQ2FsbHNGb3JNZXNzYWdlLm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgbmFtZTogdG9vbENhbGwubmFtZSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzOiB0b29sQ2FsbC5hcmd1bWVudHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSlcbiAgICAgICAgfSwgLi4udG9vbE1lc3NhZ2VzXTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gIH1cbn1cbi8qKlxuICogQ29udmVydHMgYW4gaW50ZXJuYWwgdG9vbCB0byBhbiBBUEkgdG9vbC5cbiAqXG4gKiBAcGFyYW0gdG9vbCAtIFRoZSBpbnRlcm5hbCB0b29sIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgQVBJIHRvb2wuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdG9BcGlUb29sc0Zyb21JbnRlcm5hbCh0b29scywgZW11bGF0ZVN0cnVjdHVyZWRPdXRwdXQsIG91dHB1dFNjaGVtYSkge1xuICBjb25zdCBhcGlUb29scyA9IHRvb2xzLm1hcCh0b29sID0+ICh7XG4gICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sXG4gICAgbmFtZTogdG9vbC5uYW1lLFxuICAgIHBhcmFtZXRlcnM6IGlzSGFzaGJyb3duVHlwZSh0b29sLnNjaGVtYSkgPyB0b0pzb25TY2hlbWEodG9vbC5zY2hlbWEpIDogdG9vbC5zY2hlbWFcbiAgfSkpO1xuICBpZiAoZW11bGF0ZVN0cnVjdHVyZWRPdXRwdXQpIHtcbiAgICBhcGlUb29scy5wdXNoKHtcbiAgICAgIGRlc2NyaXB0aW9uOiAnVGhpcyBzaG91bGQgYmUgeW91ciBmaW5hbCB0b29sIGNhbGwuIEdlbmVyYXRlIGEgcmVzcG9uc2UgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBzY2hlbWEuJyxcbiAgICAgIG5hbWU6ICdvdXRwdXQnLFxuICAgICAgcGFyYW1ldGVyczogdG9Kc29uU2NoZW1hKG91dHB1dFNjaGVtYSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYXBpVG9vbHM7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIEFQSSB0b29sIGNhbGwgdG8gYW4gaW50ZXJuYWwgdG9vbCBjYWxsLlxuICpcbiAqIEBwYXJhbSB0b29sQ2FsbCAtIFRoZSBBUEkgdG9vbCBjYWxsIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgaW50ZXJuYWwgdG9vbCBjYWxscy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0b0ludGVybmFsVG9vbENhbGxzRnJvbUFwaSh0b29sQ2FsbCkge1xuICBpZiAodG9vbENhbGwuZnVuY3Rpb24ubmFtZSA9PT0gJ291dHB1dCcpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFt7XG4gICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgIG5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgYXJndW1lbnRzOiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgc3RhdHVzOiAncGVuZGluZydcbiAgfV07XG59XG4vKipcbiAqIENvbnZlcnRzIGEgdmlldyBtZXNzYWdlIHRvIGFuIGludGVybmFsIHRvb2wgY2FsbC5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSB2aWV3IG1lc3NhZ2UgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBpbnRlcm5hbCB0b29sIGNhbGxzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZXJuYWxUb29sQ2FsbHNGcm9tVmlldyhtZXNzYWdlcykge1xuICByZXR1cm4gbWVzc2FnZXMuZmxhdE1hcChtZXNzYWdlID0+IHtcbiAgICBpZiAobWVzc2FnZS5yb2xlICE9PSAnYXNzaXN0YW50Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZS50b29sQ2FsbHMubWFwKHRvb2xDYWxsID0+IHtcbiAgICAgIHN3aXRjaCAodG9vbENhbGwuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbC5uYW1lLFxuICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxsLmFyZ3MpLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdkb25lJyxcbiAgICAgICAgICAgICAgcmVzdWx0OiB0b29sQ2FsbC5yZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgbmFtZTogdG9vbENhbGwubmFtZSxcbiAgICAgICAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkodG9vbENhbGwuYXJncylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gQVBJIGFzc2lzdGFudCBtZXNzYWdlIHRvIGFuIGludGVybmFsIGFzc2lzdGFudCBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIEFQSSBhc3Npc3RhbnQgbWVzc2FnZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGludGVybmFsIGFzc2lzdGFudCBtZXNzYWdlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZXJuYWxNZXNzYWdlc0Zyb21BcGkobWVzc2FnZSkge1xuICB2YXIgX2EsIF9iO1xuICBpZiAobWVzc2FnZS5yb2xlID09PSAndG9vbCcpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKG1lc3NhZ2Uucm9sZSA9PT0gJ3VzZXInKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICByb2xlOiAndXNlcicsXG4gICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnRcbiAgICB9XTtcbiAgfVxuICBpZiAobWVzc2FnZS5yb2xlID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICByb2xlOiAnZXJyb3InLFxuICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50XG4gICAgfV07XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0gKF9hID0gbWVzc2FnZS50b29sQ2FsbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maW5kKHRvb2xDYWxsID0+IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUgPT09ICdvdXRwdXQnKTtcbiAgY29uc3QgY29udGVudCA9IG91dHB1dCA/IG91dHB1dC5mdW5jdGlvbi5hcmd1bWVudHMgOiBtZXNzYWdlLmNvbnRlbnQ7XG4gIHJldHVybiBbe1xuICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgIGNvbnRlbnQsXG4gICAgdG9vbENhbGxJZHM6ICgoX2IgPSBtZXNzYWdlLnRvb2xDYWxscykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbHRlcih0b29sQ2FsbCA9PiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lICE9PSAnb3V0cHV0JykubWFwKHRvb2xDYWxsID0+IHRvb2xDYWxsLmlkKSkgfHwgW11cbiAgfV07XG59XG5cbnZhciBpbnRlcm5hbF9oZWxwZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB0b0FwaU1lc3NhZ2VzRnJvbUludGVybmFsOiB0b0FwaU1lc3NhZ2VzRnJvbUludGVybmFsLFxuICAgIHRvQXBpVG9vbHNGcm9tSW50ZXJuYWw6IHRvQXBpVG9vbHNGcm9tSW50ZXJuYWwsXG4gICAgdG9JbnRlcm5hbE1lc3NhZ2VzRnJvbUFwaTogdG9JbnRlcm5hbE1lc3NhZ2VzRnJvbUFwaSxcbiAgICB0b0ludGVybmFsTWVzc2FnZXNGcm9tVmlldzogdG9JbnRlcm5hbE1lc3NhZ2VzRnJvbVZpZXcsXG4gICAgdG9JbnRlcm5hbFRvb2xDYWxsc0Zyb21BcGk6IHRvSW50ZXJuYWxUb29sQ2FsbHNGcm9tQXBpLFxuICAgIHRvSW50ZXJuYWxUb29sQ2FsbHNGcm9tVmlldzogdG9JbnRlcm5hbFRvb2xDYWxsc0Zyb21WaWV3LFxuICAgIHRvVmlld01lc3NhZ2VzRnJvbUludGVybmFsOiB0b1ZpZXdNZXNzYWdlc0Zyb21JbnRlcm5hbFxufSk7XG5cbnZhciBwdWJsaWNfYXBpID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBBcGk6IGFwaV9tb2RlbHMsXG4gICAgSW50ZXJuYWw6IGludGVybmFsX21vZGVscyxcbiAgICBoZWxwZXJzOiBpbnRlcm5hbF9oZWxwZXJzXG59KTtcblxuY29uc3QgaW5pdGlhbFN0YXRlJDQgPSB7XG4gIGFwaVVybDogJycsXG4gIG1vZGVsOiAnJyxcbiAgc3lzdGVtOiAnJyxcbiAgZGVib3VuY2U6IDE1MCxcbiAgZW11bGF0ZVN0cnVjdHVyZWRPdXRwdXQ6IGZhbHNlLFxuICByZXRyaWVzOiAwXG59O1xuY29uc3QgcmVkdWNlciQ1ID0gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUkNCwgb24oZGV2QWN0aW9ucy5pbml0LCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgYXBpVXJsOiBhY3Rpb24ucGF5bG9hZC5hcGlVcmwsXG4gICAgbW9kZWw6IGFjdGlvbi5wYXlsb2FkLm1vZGVsLFxuICAgIHN5c3RlbTogYWN0aW9uLnBheWxvYWQuc3lzdGVtLFxuICAgIGRlYm91bmNlOiAoX2EgPSBhY3Rpb24ucGF5bG9hZC5kZWJvdW5jZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3RhdGUuZGVib3VuY2UsXG4gICAgcmVzcG9uc2VTY2hlbWE6IGFjdGlvbi5wYXlsb2FkLnJlc3BvbnNlU2NoZW1hLFxuICAgIG1pZGRsZXdhcmU6IGFjdGlvbi5wYXlsb2FkLm1pZGRsZXdhcmUsXG4gICAgZW11bGF0ZVN0cnVjdHVyZWRPdXRwdXQ6IChfYiA9IGFjdGlvbi5wYXlsb2FkLmVtdWxhdGVTdHJ1Y3R1cmVkT3V0cHV0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBzdGF0ZS5lbXVsYXRlU3RydWN0dXJlZE91dHB1dCxcbiAgICByZXRyaWVzOiAoX2MgPSBhY3Rpb24ucGF5bG9hZC5yZXRyaWVzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBzdGF0ZS5yZXRyaWVzXG4gIH0pO1xufSksIG9uKGRldkFjdGlvbnMudXBkYXRlT3B0aW9ucywgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCBhY3Rpb24ucGF5bG9hZCk7XG59KSk7XG5jb25zdCBzZWxlY3RBcGlVcmwkMSA9IHN0YXRlID0+IHN0YXRlLmFwaVVybDtcbmNvbnN0IHNlbGVjdE1vZGVsJDEgPSBzdGF0ZSA9PiBzdGF0ZS5tb2RlbDtcbmNvbnN0IHNlbGVjdFN5c3RlbSQxID0gc3RhdGUgPT4gc3RhdGUuc3lzdGVtO1xuY29uc3Qgc2VsZWN0RGVib3VuY2UkMSA9IHN0YXRlID0+IHN0YXRlLmRlYm91bmNlO1xuY29uc3Qgc2VsZWN0UmVzcG9uc2VTY2hlbWEkMSA9IHN0YXRlID0+IHN0YXRlLnJlc3BvbnNlU2NoZW1hO1xuY29uc3Qgc2VsZWN0TWlkZGxld2FyZSQxID0gc3RhdGUgPT4gc3RhdGUubWlkZGxld2FyZTtcbmNvbnN0IHNlbGVjdEVtdWxhdGVTdHJ1Y3R1cmVkT3V0cHV0JDEgPSBzdGF0ZSA9PiBzdGF0ZS5lbXVsYXRlU3RydWN0dXJlZE91dHB1dDtcbmNvbnN0IHNlbGVjdFJldHJpZXMkMSA9IHN0YXRlID0+IHN0YXRlLnJldHJpZXM7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSQzID0ge1xuICBtZXNzYWdlczogW11cbn07XG5jb25zdCByZWR1Y2VyJDQgPSBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSQzLCBvbihkZXZBY3Rpb25zLmluaXQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2VzID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZXM7XG4gIGlmICghbWVzc2FnZXMpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgbWVzc2FnZXM6IG1lc3NhZ2VzLmZsYXRNYXAobWVzc2FnZSA9PiB0b0ludGVybmFsTWVzc2FnZXNGcm9tVmlldyhtZXNzYWdlKSlcbiAgfSk7XG59KSwgb24oYXBpQWN0aW9ucy5nZW5lcmF0ZU1lc3NhZ2VTdWNjZXNzLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBjb25zdCBtZXNzYWdlID0gYWN0aW9uLnBheWxvYWQ7XG4gIGNvbnN0IGludGVybmFsTWVzc2FnZXMgPSB0b0ludGVybmFsTWVzc2FnZXNGcm9tQXBpKG1lc3NhZ2UpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICBtZXNzYWdlczogWy4uLnN0YXRlLm1lc3NhZ2VzLCAuLi5pbnRlcm5hbE1lc3NhZ2VzXVxuICB9KTtcbn0pLCBvbihhcGlBY3Rpb25zLmdlbmVyYXRlTWVzc2FnZUVycm9yLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBjb25zdCBtZXNzYWdlID0gYWN0aW9uLnBheWxvYWQ7XG4gIGNvbnN0IGVycm9yTWVzc2FnZSA9IHtcbiAgICByb2xlOiAnZXJyb3InLFxuICAgIGNvbnRlbnQ6IG1lc3NhZ2UubWVzc2FnZVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICBtZXNzYWdlczogWy4uLnN0YXRlLm1lc3NhZ2VzLCBlcnJvck1lc3NhZ2VdXG4gIH0pO1xufSksIG9uKGRldkFjdGlvbnMuc2V0TWVzc2FnZXMsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2VzID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZXM7XG4gIGNvbnN0IGludGVybmFsTWVzc2FnZXMgPSBtZXNzYWdlcy5mbGF0TWFwKG1lc3NhZ2UgPT4gdG9JbnRlcm5hbE1lc3NhZ2VzRnJvbVZpZXcobWVzc2FnZSkpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICBtZXNzYWdlczogaW50ZXJuYWxNZXNzYWdlc1xuICB9KTtcbn0pLCBvbihkZXZBY3Rpb25zLnNlbmRNZXNzYWdlLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBjb25zdCBtZXNzYWdlID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZTtcbiAgY29uc3QgaW50ZXJuYWxNZXNzYWdlcyA9IHRvSW50ZXJuYWxNZXNzYWdlc0Zyb21WaWV3KG1lc3NhZ2UpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICBtZXNzYWdlczogWy4uLnN0YXRlLm1lc3NhZ2VzLCAuLi5pbnRlcm5hbE1lc3NhZ2VzXVxuICB9KTtcbn0pKTtcbmNvbnN0IHNlbGVjdE1lc3NhZ2VzJDEgPSBzdGF0ZSA9PiBzdGF0ZS5tZXNzYWdlcztcblxuY29uc3QgaW5pdGlhbFN0YXR1c1N0YXRlID0ge1xuICBpc1JlY2VpdmluZzogZmFsc2UsXG4gIGlzU2VuZGluZzogZmFsc2UsXG4gIGlzUnVubmluZ1Rvb2xDYWxsczogZmFsc2UsXG4gIGVycm9yOiB1bmRlZmluZWQsXG4gIGV4aGF1c3RlZFJldHJpZXM6IGZhbHNlXG59O1xuY29uc3QgcmVkdWNlciQzID0gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdHVzU3RhdGUsIG9uKGRldkFjdGlvbnMuaW5pdCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBtZXNzYWdlcyA9IChfYSA9IGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2VzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgaWYgKChsYXN0TWVzc2FnZSA9PT0gbnVsbCB8fCBsYXN0TWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdE1lc3NhZ2Uucm9sZSkgPT09ICd1c2VyJykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgaXNTZW5kaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufSksIG9uKGRldkFjdGlvbnMuc2VuZE1lc3NhZ2UsIGRldkFjdGlvbnMuc2V0TWVzc2FnZXMsIGRldkFjdGlvbnMucmVzZW5kTWVzc2FnZXMsIHN0YXRlID0+IHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgaXNTZW5kaW5nOiB0cnVlXG4gIH0pO1xufSksIG9uKGFwaUFjdGlvbnMuZ2VuZXJhdGVNZXNzYWdlU3RhcnQsIHN0YXRlID0+IHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgaXNTZW5kaW5nOiBmYWxzZSxcbiAgICBpc1JlY2VpdmluZzogdHJ1ZVxuICB9KTtcbn0pLCBvbihhcGlBY3Rpb25zLmdlbmVyYXRlTWVzc2FnZUNodW5rLCBzdGF0ZSA9PiB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgIGlzUmVjZWl2aW5nOiB0cnVlXG4gIH0pO1xufSksIG9uKGFwaUFjdGlvbnMuZ2VuZXJhdGVNZXNzYWdlU3VjY2Vzcywgc3RhdGUgPT4ge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICBpc1JlY2VpdmluZzogZmFsc2UsXG4gICAgaXNSdW5uaW5nVG9vbENhbGxzOiB0cnVlLFxuICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgZXhoYXVzdGVkUmV0cmllczogZmFsc2VcbiAgfSk7XG59KSwgb24oYXBpQWN0aW9ucy5nZW5lcmF0ZU1lc3NhZ2VFcnJvciwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgaXNSZWNlaXZpbmc6IGZhbHNlLFxuICAgIGlzU2VuZGluZzogZmFsc2UsXG4gICAgZXJyb3I6IGFjdGlvbi5wYXlsb2FkXG4gIH0pO1xufSksIG9uKGludGVybmFsQWN0aW9ucy5ydW5Ub29sQ2FsbHNTdWNjZXNzLCBzdGF0ZSA9PiB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgIGlzUnVubmluZ1Rvb2xDYWxsczogZmFsc2UsXG4gICAgaXNTZW5kaW5nOiB0cnVlXG4gIH0pO1xufSksIG9uKGludGVybmFsQWN0aW9ucy5ydW5Ub29sQ2FsbHNFcnJvciwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgaXNSdW5uaW5nVG9vbENhbGxzOiBmYWxzZSxcbiAgICBlcnJvcjogYWN0aW9uLnBheWxvYWRcbiAgfSk7XG59KSwgb24oYXBpQWN0aW9ucy5nZW5lcmF0ZU1lc3NhZ2VFeGhhdXN0ZWRSZXRyaWVzLCBzdGF0ZSA9PiB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgIGV4aGF1c3RlZFJldHJpZXM6IHRydWVcbiAgfSk7XG59KSwgb24oZGV2QWN0aW9ucy5zdG9wTWVzc2FnZUdlbmVyYXRpb24sIHN0YXRlID0+IHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgaXNSZWNlaXZpbmc6IGZhbHNlLFxuICAgIGlzU2VuZGluZzogZmFsc2UsXG4gICAgaXNSdW5uaW5nVG9vbENhbGxzOiBmYWxzZSxcbiAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgIGV4aGF1c3RlZFJldHJpZXM6IGZhbHNlXG4gIH0pO1xufSksIG9uKGludGVybmFsQWN0aW9ucy5za2lwcGVkVG9vbENhbGxzLCBzdGF0ZSA9PiB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgIGlzUnVubmluZ1Rvb2xDYWxsczogZmFsc2UsXG4gICAgaXNTZW5kaW5nOiBmYWxzZSxcbiAgICBpc1JlY2VpdmluZzogZmFsc2VcbiAgfSk7XG59KSk7XG5jb25zdCBzZWxlY3RJc1JlY2VpdmluZyQxID0gc3RhdGUgPT4gc3RhdGUuaXNSZWNlaXZpbmc7XG5jb25zdCBzZWxlY3RJc1NlbmRpbmckMSA9IHN0YXRlID0+IHN0YXRlLmlzU2VuZGluZztcbmNvbnN0IHNlbGVjdElzUnVubmluZ1Rvb2xDYWxscyQxID0gc3RhdGUgPT4gc3RhdGUuaXNSdW5uaW5nVG9vbENhbGxzO1xuY29uc3Qgc2VsZWN0RXJyb3IkMSA9IHN0YXRlID0+IHN0YXRlLmVycm9yO1xuY29uc3Qgc2VsZWN0RXhoYXVzdGVkUmV0cmllcyQxID0gc3RhdGUgPT4gc3RhdGUuZXhoYXVzdGVkUmV0cmllcztcblxuY29uc3QgaW5pdGlhbFN0YXRlJDIgPSB7XG4gIG1lc3NhZ2U6IG51bGwsXG4gIHRvb2xDYWxsczogW11cbn07XG5jb25zdCByZWR1Y2VyJDIgPSBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSQyLCBvbihhcGlBY3Rpb25zLmdlbmVyYXRlTWVzc2FnZUNodW5rLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICBjb25zdCBhcGlNZXNzYWdlID0gYWN0aW9uLnBheWxvYWQ7XG4gIGNvbnN0IFtpbnRlcm5hbE1lc3NhZ2VdID0gdG9JbnRlcm5hbE1lc3NhZ2VzRnJvbUFwaSh7XG4gICAgcm9sZTogKF9hID0gYXBpTWVzc2FnZS5yb2xlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnYXNzaXN0YW50JyxcbiAgICBjb250ZW50OiAoX2IgPSBhcGlNZXNzYWdlLmNvbnRlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgIHRvb2xDYWxsczogKF9jID0gYXBpTWVzc2FnZS50b29sQ2FsbHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdXG4gIH0pO1xuICBpZiAoIWludGVybmFsTWVzc2FnZSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAoaW50ZXJuYWxNZXNzYWdlLnJvbGUgIT09ICdhc3Npc3RhbnQnKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgIG1lc3NhZ2U6IGludGVybmFsTWVzc2FnZSxcbiAgICB0b29sQ2FsbHM6IChfZSA9IChfZCA9IGFjdGlvbi5wYXlsb2FkLnRvb2xDYWxscykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmZsYXRNYXAodG9JbnRlcm5hbFRvb2xDYWxsc0Zyb21BcGkpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBbXVxuICB9KTtcbn0pLCBvbihhcGlBY3Rpb25zLmdlbmVyYXRlTWVzc2FnZVN1Y2Nlc3MsIHN0YXRlID0+IHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgbWVzc2FnZTogbnVsbFxuICB9KTtcbn0pLCBvbihkZXZBY3Rpb25zLnN0b3BNZXNzYWdlR2VuZXJhdGlvbiwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgbWVzc2FnZTogYWN0aW9uLnBheWxvYWQgPyBudWxsIDogc3RhdGUubWVzc2FnZSxcbiAgICB0b29sQ2FsbHM6IFtdXG4gIH0pO1xufSkpO1xuY29uc3Qgc2VsZWN0UmF3U3RyZWFtaW5nTWVzc2FnZSA9IHN0YXRlID0+IHN0YXRlLm1lc3NhZ2U7XG5jb25zdCBzZWxlY3RSYXdTdHJlYW1pbmdUb29sQ2FsbHMgPSBzdGF0ZSA9PiBzdGF0ZS50b29sQ2FsbHM7XG5jb25zdCBzZWxlY3RTdHJlYW1pbmdNZXNzYWdlJDEgPSBzZWxlY3Qoc2VsZWN0UmF3U3RyZWFtaW5nTWVzc2FnZSwgc2VsZWN0UmF3U3RyZWFtaW5nVG9vbENhbGxzLCAobWVzc2FnZSwgdG9vbENhbGxzKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGlmICghbWVzc2FnZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgcm9sZTogKF9hID0gbWVzc2FnZS5yb2xlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnYXNzaXN0YW50JyxcbiAgICBjb250ZW50OiAoX2IgPSBtZXNzYWdlLmNvbnRlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgIHRvb2xDYWxsSWRzOiB0b29sQ2FsbHMubWFwKHRvb2xDYWxsID0+IHRvb2xDYWxsLmlkKVxuICB9O1xufSk7XG5jb25zdCBzZWxlY3RTdHJlYW1pbmdUb29sQ2FsbEVudGl0aWVzJDEgPSBzZWxlY3Qoc2VsZWN0UmF3U3RyZWFtaW5nVG9vbENhbGxzLCB0b29sQ2FsbHMgPT4ge1xuICByZXR1cm4gdG9vbENhbGxzLnJlZHVjZSgoYWNjLCB0b29sQ2FsbCkgPT4ge1xuICAgIGFjY1t0b29sQ2FsbC5pZF0gPSB0b29sQ2FsbDtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59KTtcblxuY29uc3QgYWRhcHRlciA9IGNyZWF0ZUVudGl0eUFkYXB0ZXIoe1xuICBzZWxlY3RJZDogdG9vbENhbGwgPT4gdG9vbENhbGwuaWRcbn0pO1xuY29uc3QgaW5pdGlhbFN0YXRlJDEgPSB7XG4gIGlkczogW10sXG4gIGVudGl0aWVzOiB7fVxufTtcbmNvbnN0IHJlZHVjZXIkMSA9IGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlJDEsIG9uKGRldkFjdGlvbnMuaW5pdCwgZGV2QWN0aW9ucy5zZXRNZXNzYWdlcywgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgY29uc3QgbWVzc2FnZXMgPSBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlcztcbiAgaWYgKCFtZXNzYWdlcykge1xuICAgIHJldHVybiBpbml0aWFsU3RhdGUkMTtcbiAgfVxuICByZXR1cm4gYWRhcHRlci5hZGRNYW55KGluaXRpYWxTdGF0ZSQxLCB0b0ludGVybmFsVG9vbENhbGxzRnJvbVZpZXcobWVzc2FnZXMpKTtcbn0pLCBvbihhcGlBY3Rpb25zLmdlbmVyYXRlTWVzc2FnZVN1Y2Nlc3MsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBhY3Rpb24ucGF5bG9hZDtcbiAgaWYgKCFtZXNzYWdlLnRvb2xDYWxscykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICByZXR1cm4gYWRhcHRlci5hZGRNYW55KHN0YXRlLCBtZXNzYWdlLnRvb2xDYWxscy5mbGF0TWFwKHRvSW50ZXJuYWxUb29sQ2FsbHNGcm9tQXBpKSk7XG59KSwgb24oaW50ZXJuYWxBY3Rpb25zLnJ1blRvb2xDYWxsc1N1Y2Nlc3MsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0b29sTWVzc2FnZXNcbiAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICBjb25zdCBjaGFuZ2VzID0gdG9vbE1lc3NhZ2VzLm1hcCh0b29sTWVzc2FnZSA9PiAoe1xuICAgIGlkOiB0b29sTWVzc2FnZS50b29sQ2FsbElkLFxuICAgIHVwZGF0ZXM6IHtcbiAgICAgIHJlc3VsdDogdG9vbE1lc3NhZ2UuY29udGVudCxcbiAgICAgIHN0YXR1czogJ2RvbmUnXG4gICAgfVxuICB9KSk7XG4gIHJldHVybiBhZGFwdGVyLnVwZGF0ZU1hbnkoc3RhdGUsIGNoYW5nZXMpO1xufSkpO1xuY29uc3Qgc2VsZWN0VG9vbENhbGxJZHMgPSBzdGF0ZSA9PiBzdGF0ZS5pZHM7XG5jb25zdCBzZWxlY3RUb29sQ2FsbEVudGl0aWVzJDEgPSBzdGF0ZSA9PiBzdGF0ZS5lbnRpdGllcztcbmNvbnN0IHNlbGVjdFRvb2xDYWxscyQxID0gc2VsZWN0KHNlbGVjdFRvb2xDYWxsSWRzLCBzZWxlY3RUb29sQ2FsbEVudGl0aWVzJDEsIChpZHMsIGVudGl0aWVzKSA9PiBpZHMubWFwKGlkID0+IGVudGl0aWVzW2lkXSkpO1xuY29uc3Qgc2VsZWN0UGVuZGluZ1Rvb2xDYWxscyQxID0gc2VsZWN0KHNlbGVjdFRvb2xDYWxscyQxLCB0b29sQ2FsbHMgPT4ge1xuICByZXR1cm4gdG9vbENhbGxzLmZpbHRlcih0b29sQ2FsbCA9PiB0b29sQ2FsbC5zdGF0dXMgPT09ICdwZW5kaW5nJyk7XG59KTtcblxuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBuYW1lczogW10sXG4gIGVudGl0aWVzOiB7fVxufTtcbmNvbnN0IHJlZHVjZXIgPSBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgb24oZGV2QWN0aW9ucy5pbml0LCBkZXZBY3Rpb25zLnVwZGF0ZU9wdGlvbnMsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IHRvb2xzID0gYWN0aW9uLnBheWxvYWQudG9vbHM7XG4gIGlmICghdG9vbHMgfHwgdG9vbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgIG5hbWVzOiB0b29scy5tYXAodG9vbCA9PiB0b29sLm5hbWUpLFxuICAgIGVudGl0aWVzOiB0b29scy5yZWR1Y2UoKGFjYywgdG9vbCkgPT4ge1xuICAgICAgYWNjW3Rvb2wubmFtZV0gPSB0b29sO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSlcbiAgfSk7XG59KSk7XG5jb25zdCBzZWxlY3RUb29sTmFtZXMgPSBzdGF0ZSA9PiBzdGF0ZS5uYW1lcztcbmNvbnN0IHNlbGVjdFRvb2xFbnRpdGllcyQxID0gc3RhdGUgPT4gc3RhdGUuZW50aXRpZXM7XG5jb25zdCBzZWxlY3RUb29scyQxID0gc2VsZWN0KHNlbGVjdFRvb2xOYW1lcywgc2VsZWN0VG9vbEVudGl0aWVzJDEsIChuYW1lcywgZW50aXRpZXMpID0+IG5hbWVzLm1hcChuYW1lID0+IGVudGl0aWVzW25hbWVdKSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IHJlZHVjZXJzID0ge1xuICBjb25maWc6IHJlZHVjZXIkNSxcbiAgbWVzc2FnZXM6IHJlZHVjZXIkNCxcbiAgc3RhdHVzOiByZWR1Y2VyJDMsXG4gIHN0cmVhbWluZ01lc3NhZ2U6IHJlZHVjZXIkMixcbiAgdG9vbENhbGxzOiByZWR1Y2VyJDEsXG4gIHRvb2xzOiByZWR1Y2VyXG59O1xuLyoqXG4gKiBNZXNzYWdlc1xuICovXG5jb25zdCBzZWxlY3RNZXNzYWdlc1N0YXRlID0gc3RhdGUgPT4gc3RhdGUubWVzc2FnZXM7XG5jb25zdCBzZWxlY3RNZXNzYWdlcyA9IHNlbGVjdChzZWxlY3RNZXNzYWdlc1N0YXRlLCBzZWxlY3RNZXNzYWdlcyQxKTtcbi8qKlxuICogU3RhdHVzXG4gKi9cbmNvbnN0IHNlbGVjdFN0YXR1c1N0YXRlID0gc3RhdGUgPT4gc3RhdGUuc3RhdHVzO1xuY29uc3Qgc2VsZWN0SXNSZWNlaXZpbmcgPSBzZWxlY3Qoc2VsZWN0U3RhdHVzU3RhdGUsIHNlbGVjdElzUmVjZWl2aW5nJDEpO1xuY29uc3Qgc2VsZWN0SXNTZW5kaW5nID0gc2VsZWN0KHNlbGVjdFN0YXR1c1N0YXRlLCBzZWxlY3RJc1NlbmRpbmckMSk7XG5jb25zdCBzZWxlY3RJc1J1bm5pbmdUb29sQ2FsbHMgPSBzZWxlY3Qoc2VsZWN0U3RhdHVzU3RhdGUsIHNlbGVjdElzUnVubmluZ1Rvb2xDYWxscyQxKTtcbmNvbnN0IHNlbGVjdEVycm9yID0gc2VsZWN0KHNlbGVjdFN0YXR1c1N0YXRlLCBzZWxlY3RFcnJvciQxKTtcbmNvbnN0IHNlbGVjdEV4aGF1c3RlZFJldHJpZXMgPSBzZWxlY3Qoc2VsZWN0U3RhdHVzU3RhdGUsIHNlbGVjdEV4aGF1c3RlZFJldHJpZXMkMSk7XG4vKipcbiAqIFN0cmVhbWluZyBNZXNzYWdlXG4gKi9cbmNvbnN0IHNlbGVjdFN0cmVhbWluZ01lc3NhZ2VTdGF0ZSA9IHN0YXRlID0+IHN0YXRlLnN0cmVhbWluZ01lc3NhZ2U7XG5jb25zdCBzZWxlY3RTdHJlYW1pbmdNZXNzYWdlID0gc2VsZWN0KHNlbGVjdFN0cmVhbWluZ01lc3NhZ2VTdGF0ZSwgc2VsZWN0U3RyZWFtaW5nTWVzc2FnZSQxKTtcbmNvbnN0IHNlbGVjdFN0cmVhbWluZ1Rvb2xDYWxsRW50aXRpZXMgPSBzZWxlY3Qoc2VsZWN0U3RyZWFtaW5nTWVzc2FnZVN0YXRlLCBzZWxlY3RTdHJlYW1pbmdUb29sQ2FsbEVudGl0aWVzJDEpO1xuLyoqXG4gKiBUb29sc1xuICovXG5jb25zdCBzZWxlY3RUb29sc1N0YXRlID0gc3RhdGUgPT4gc3RhdGUudG9vbHM7XG5jb25zdCBzZWxlY3RUb29scyA9IHNlbGVjdChzZWxlY3RUb29sc1N0YXRlLCBzZWxlY3RUb29scyQxKTtcbmNvbnN0IHNlbGVjdFRvb2xFbnRpdGllcyA9IHNlbGVjdChzZWxlY3RUb29sc1N0YXRlLCBzZWxlY3RUb29sRW50aXRpZXMkMSk7XG4vKipcbiAqIFRvb2wgQ2FsbHNcbiAqL1xuY29uc3Qgc2VsZWN0VG9vbENhbGxzU3RhdGUgPSBzdGF0ZSA9PiBzdGF0ZS50b29sQ2FsbHM7XG5jb25zdCBzZWxlY3RUb29sQ2FsbHMgPSBzZWxlY3Qoc2VsZWN0VG9vbENhbGxzU3RhdGUsIHNlbGVjdFRvb2xDYWxscyQxKTtcbmNvbnN0IHNlbGVjdFRvb2xDYWxsRW50aXRpZXMgPSBzZWxlY3Qoc2VsZWN0VG9vbENhbGxzU3RhdGUsIHNlbGVjdFRvb2xDYWxsRW50aXRpZXMkMSk7XG5jb25zdCBzZWxlY3RQZW5kaW5nVG9vbENhbGxzID0gc2VsZWN0KHNlbGVjdFRvb2xDYWxsc1N0YXRlLCBzZWxlY3RQZW5kaW5nVG9vbENhbGxzJDEpO1xuLyoqXG4gKiBDb25maWdcbiAqL1xuY29uc3Qgc2VsZWN0Q29uZmlnU3RhdGUgPSBzdGF0ZSA9PiBzdGF0ZS5jb25maWc7XG5jb25zdCBzZWxlY3RBcGlVcmwgPSBzZWxlY3Qoc2VsZWN0Q29uZmlnU3RhdGUsIHNlbGVjdEFwaVVybCQxKTtcbmNvbnN0IHNlbGVjdE1pZGRsZXdhcmUgPSBzZWxlY3Qoc2VsZWN0Q29uZmlnU3RhdGUsIHNlbGVjdE1pZGRsZXdhcmUkMSk7XG5jb25zdCBzZWxlY3RNb2RlbCA9IHNlbGVjdChzZWxlY3RDb25maWdTdGF0ZSwgc2VsZWN0TW9kZWwkMSk7XG5jb25zdCBzZWxlY3RTeXN0ZW0gPSBzZWxlY3Qoc2VsZWN0Q29uZmlnU3RhdGUsIHNlbGVjdFN5c3RlbSQxKTtcbmNvbnN0IHNlbGVjdERlYm91bmNlID0gc2VsZWN0KHNlbGVjdENvbmZpZ1N0YXRlLCBzZWxlY3REZWJvdW5jZSQxKTtcbmNvbnN0IHNlbGVjdFJldHJpZXMgPSBzZWxlY3Qoc2VsZWN0Q29uZmlnU3RhdGUsIHNlbGVjdFJldHJpZXMkMSk7XG5jb25zdCBzZWxlY3RSZXNwb25zZVNjaGVtYSA9IHNlbGVjdChzZWxlY3RDb25maWdTdGF0ZSwgc2VsZWN0UmVzcG9uc2VTY2hlbWEkMSk7XG5jb25zdCBzZWxlY3RFbXVsYXRlU3RydWN0dXJlZE91dHB1dCA9IHNlbGVjdChzZWxlY3RDb25maWdTdGF0ZSwgc2VsZWN0RW11bGF0ZVN0cnVjdHVyZWRPdXRwdXQkMSk7XG4vKipcbiAqIFRvcC1sZXZlbCBzZWxlY3RvcnNcbiAqL1xuY29uc3Qgc2VsZWN0Tm9uU3RyZWFtaW5nVmlld01lc3NhZ2VzID0gc2VsZWN0KHNlbGVjdE1lc3NhZ2VzLCBzZWxlY3RUb29sQ2FsbEVudGl0aWVzLCBzZWxlY3RUb29scywgc2VsZWN0UmVzcG9uc2VTY2hlbWEsIChtZXNzYWdlcywgdG9vbENhbGxzLCB0b29scywgcmVzcG9uc2VTY2hlbWEpID0+IHtcbiAgcmV0dXJuIG1lc3NhZ2VzLmZsYXRNYXAobWVzc2FnZSA9PiB0b1ZpZXdNZXNzYWdlc0Zyb21JbnRlcm5hbChtZXNzYWdlLCB0b29sQ2FsbHMsIHRvb2xzLCByZXNwb25zZVNjaGVtYSkpO1xufSk7XG5jb25zdCBzZWxlY3RTdHJlYW1pbmdWaWV3TWVzc2FnZXMgPSBzZWxlY3Qoc2VsZWN0U3RyZWFtaW5nTWVzc2FnZSwgc2VsZWN0U3RyZWFtaW5nVG9vbENhbGxFbnRpdGllcywgc2VsZWN0VG9vbHMsIHNlbGVjdFJlc3BvbnNlU2NoZW1hLCAoc3RyZWFtaW5nTWVzc2FnZSwgc3RyZWFtaW5nVG9vbENhbGxzLCB0b29scywgcmVzcG9uc2VTY2hlbWEpID0+IHtcbiAgcmV0dXJuIChzdHJlYW1pbmdNZXNzYWdlID8gW3N0cmVhbWluZ01lc3NhZ2VdIDogW10pLmZsYXRNYXAobWVzc2FnZSA9PiB0b1ZpZXdNZXNzYWdlc0Zyb21JbnRlcm5hbChtZXNzYWdlLCBzdHJlYW1pbmdUb29sQ2FsbHMsIHRvb2xzLCByZXNwb25zZVNjaGVtYSkpO1xufSk7XG5jb25zdCBzZWxlY3RWaWV3TWVzc2FnZXMgPSBzZWxlY3Qoc2VsZWN0Tm9uU3RyZWFtaW5nVmlld01lc3NhZ2VzLCBzZWxlY3RTdHJlYW1pbmdWaWV3TWVzc2FnZXMsIChub25TdHJlYW1pbmdNZXNzYWdlcywgc3RyZWFtaW5nTWVzc2FnZXMpID0+IHtcbiAgcmV0dXJuIFsuLi5ub25TdHJlYW1pbmdNZXNzYWdlcywgLi4uc3RyZWFtaW5nTWVzc2FnZXNdO1xufSk7XG5jb25zdCBzZWxlY3RMYXN0QXNzaXN0YW50TWVzc2FnZSA9IHNlbGVjdChzZWxlY3RWaWV3TWVzc2FnZXMsIG1lc3NhZ2VzID0+IHtcbiAgcmV0dXJuIG1lc3NhZ2VzLmZpbmRMYXN0KG1lc3NhZ2UgPT4gbWVzc2FnZS5yb2xlID09PSAnYXNzaXN0YW50Jyk7XG59KTtcbmNvbnN0IHNlbGVjdEFwaU1lc3NhZ2VzID0gc2VsZWN0KHNlbGVjdE1lc3NhZ2VzLCBzZWxlY3RUb29sQ2FsbHMsIChtZXNzYWdlcywgdG9vbENhbGxzKSA9PiB7XG4gIHJldHVybiBtZXNzYWdlcy5mbGF0TWFwKG1lc3NhZ2UgPT4gdG9BcGlNZXNzYWdlc0Zyb21JbnRlcm5hbChtZXNzYWdlLCB0b29sQ2FsbHMpKTtcbn0pO1xuY29uc3Qgc2VsZWN0U2hvdWxkR2VuZXJhdGVNZXNzYWdlID0gc2VsZWN0KHNlbGVjdEFwaU1lc3NhZ2VzLCBtZXNzYWdlcyA9PiB7XG4gIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIGlmICghbGFzdE1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGxhc3RNZXNzYWdlLnJvbGUgPT09ICd1c2VyJyB8fCBsYXN0TWVzc2FnZS5yb2xlID09PSAndG9vbCc7XG59KTtcbmNvbnN0IHNlbGVjdEFwaVRvb2xzID0gc2VsZWN0KHNlbGVjdFRvb2xzLCBzZWxlY3RSZXNwb25zZVNjaGVtYSwgc2VsZWN0RW11bGF0ZVN0cnVjdHVyZWRPdXRwdXQsICh0b29scywgcmVzcG9uc2VTY2hlbWEsIGVtdWxhdGVTdHJ1Y3R1cmVkT3V0cHV0KSA9PiB7XG4gIHJldHVybiB0b0FwaVRvb2xzRnJvbUludGVybmFsKHRvb2xzLCBlbXVsYXRlU3RydWN0dXJlZE91dHB1dCAmJiAhIXJlc3BvbnNlU2NoZW1hLCByZXNwb25zZVNjaGVtYSAhPT0gbnVsbCAmJiByZXNwb25zZVNjaGVtYSAhPT0gdm9pZCAwID8gcmVzcG9uc2VTY2hlbWEgOiBudWxsaXNoKCkpO1xufSk7XG5jb25zdCBzZWxlY3RJc0xvYWRpbmcgPSBzZWxlY3Qoc2VsZWN0SXNTZW5kaW5nLCBzZWxlY3RJc1JlY2VpdmluZywgc2VsZWN0SXNSdW5uaW5nVG9vbENhbGxzLCAoaXNTZW5kaW5nLCBpc1JlY2VpdmluZywgaXNSdW5uaW5nVG9vbENhbGxzKSA9PiBpc1NlbmRpbmcgfHwgaXNSZWNlaXZpbmcgfHwgaXNSdW5uaW5nVG9vbENhbGxzKTtcblxuY29uc3QgZ2VuZXJhdGVNZXNzYWdlID0gY3JlYXRlRWZmZWN0KHN0b3JlID0+IHtcbiAgY29uc3QgZWZmZWN0QWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAvLyBUaGlzIGNvbnRyb2xsZXIgaXMgdXNlZCB0byBjYW5jZWwgdGhlIGN1cnJlbnQgbWVzc2FnZSBnZW5lcmF0aW9uXG4gIC8vIHdoZW4gYSBuZXcgbWVzc2FnZSBpcyBzZW50IG9yIHRoZSB1c2VyIHN0b3BzIHRoZSBnZW5lcmF0aW9uLlxuICBsZXQgY2FuY2VsQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBzdG9yZS53aGVuKGludGVybmFsQWN0aW9ucy5zaXp6bGUsIGRldkFjdGlvbnMuc2V0TWVzc2FnZXMsIGRldkFjdGlvbnMuc2VuZE1lc3NhZ2UsIGRldkFjdGlvbnMucmVzZW5kTWVzc2FnZXMsIGludGVybmFsQWN0aW9ucy5ydW5Ub29sQ2FsbHNTdWNjZXNzLCBzd2l0Y2hBc3luYyhzd2l0Y2hTaWduYWwgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICBjb25zdCBhcGlVcmwgPSBzdG9yZS5yZWFkKHNlbGVjdEFwaVVybCk7XG4gICAgY29uc3QgbWlkZGxld2FyZSA9IHN0b3JlLnJlYWQoc2VsZWN0TWlkZGxld2FyZSk7XG4gICAgY29uc3QgbW9kZWwgPSBzdG9yZS5yZWFkKHNlbGVjdE1vZGVsKTtcbiAgICBjb25zdCByZXNwb25zZVNjaGVtYSA9IHN0b3JlLnJlYWQoc2VsZWN0UmVzcG9uc2VTY2hlbWEpO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gc3RvcmUucmVhZChzZWxlY3RBcGlNZXNzYWdlcyk7XG4gICAgY29uc3Qgc2hvdWxkR2VuZXJhdGVNZXNzYWdlID0gc3RvcmUucmVhZChzZWxlY3RTaG91bGRHZW5lcmF0ZU1lc3NhZ2UpO1xuICAgIGNvbnN0IGRlYm91bmNlID0gc3RvcmUucmVhZChzZWxlY3REZWJvdW5jZSk7XG4gICAgY29uc3QgcmV0cmllcyA9IHN0b3JlLnJlYWQoc2VsZWN0UmV0cmllcyk7XG4gICAgY29uc3QgdG9vbHMgPSBzdG9yZS5yZWFkKHNlbGVjdEFwaVRvb2xzKTtcbiAgICBjb25zdCBzeXN0ZW0gPSBzdG9yZS5yZWFkKHNlbGVjdFN5c3RlbSk7XG4gICAgY29uc3QgZW11bGF0ZVN0cnVjdHVyZWRPdXRwdXQgPSBzdG9yZS5yZWFkKHNlbGVjdEVtdWxhdGVTdHJ1Y3R1cmVkT3V0cHV0KTtcbiAgICBpZiAoIXNob3VsZEdlbmVyYXRlTWVzc2FnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBtb2RlbCxcbiAgICAgIHN5c3RlbSxcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgdG9vbHMsXG4gICAgICB0b29sQ2hvaWNlOiBlbXVsYXRlU3RydWN0dXJlZE91dHB1dCAmJiByZXNwb25zZVNjaGVtYSA/ICdyZXF1aXJlZCcgOiB1bmRlZmluZWQsXG4gICAgICByZXNwb25zZUZvcm1hdDogIWVtdWxhdGVTdHJ1Y3R1cmVkT3V0cHV0ICYmIHJlc3BvbnNlU2NoZW1hID8gdG9Kc29uU2NoZW1hKHJlc3BvbnNlU2NoZW1hKSA6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgeWllbGQgc2xlZXAoZGVib3VuY2UsIHN3aXRjaFNpZ25hbCk7XG4gICAgbGV0IGF0dGVtcHQgPSAwO1xuICAgIGRvIHtcbiAgICAgIGF0dGVtcHQrKztcbiAgICAgIGlmIChlZmZlY3RBYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQgfHwgc3dpdGNoU2lnbmFsLmFib3J0ZWQgfHwgY2FuY2VsQWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzZXQgdGhlIGNhbmNlbEFib3J0Q29udHJvbGxlciBmb3IgdGhlIG5leHQgbWVzc3NhZ2VcbiAgICAgICAgaWYgKGNhbmNlbEFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGNhbmNlbEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcmVxdWVzdEluaXQgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJhbXMpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgICBzaWduYWw6IHN3aXRjaFNpZ25hbFxuICAgICAgfTtcbiAgICAgIGlmIChtaWRkbGV3YXJlICYmIG1pZGRsZXdhcmUubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBtaWRkbGV3YXJlKSB7XG4gICAgICAgICAgcmVxdWVzdEluaXQgPSB5aWVsZCBtKHJlcXVlc3RJbml0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChhcGlVcmwsIHJlcXVlc3RJbml0KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKGFwaUFjdGlvbnMuZ2VuZXJhdGVNZXNzYWdlRXJyb3IobmV3IEVycm9yKGBIVFRQIGVycm9yISBTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgc3RvcmUuZGlzcGF0Y2goYXBpQWN0aW9ucy5nZW5lcmF0ZU1lc3NhZ2VFcnJvcihuZXcgRXJyb3IoYFJlc3BvbnNlIGJvZHkgaXMgbnVsbGApKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBjYXRjaGVzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGNhbmNlbGxhdGlvbiB3YXMgcmVxdWVzdGVkXG4gICAgICAgIC8vIGFmdGVyIHdlIGhhZCBhbHJlYWR5IGtpY2tlZCBvZmYgdGhlIGluaXRpYWwgcmVxdWVzdCwgYnV0XG4gICAgICAgIC8vIGJlZm9yZSB3ZSBzdGFydGVkIGRlY29kaW5nIGZyYW1lcy5cbiAgICAgICAgaWYgKGNhbmNlbEFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIC8vIElmIHRoZSBjYW5jZWxBYm9ydENvbnRyb2xsZXIgaXMgYWJvcnRlZCwgd2UgbmVlZCB0byByZXNldCBpdCBmb3IgdGhlIG5leHQgbWVzc2FnZVxuICAgICAgICAgIGNhbmNlbEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goYXBpQWN0aW9ucy5nZW5lcmF0ZU1lc3NhZ2VTdGFydCgpKTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgX2UgPSAoZV8xID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKGRlY29kZUZyYW1lcyhyZXNwb25zZS5ib2R5LCB7XG4gICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwuYW55KFtjYW5jZWxBYm9ydENvbnRyb2xsZXIuc2lnbmFsLCBlZmZlY3RBYm9ydENvbnRyb2xsZXIuc2lnbmFsXSlcbiAgICAgICAgICAgIH0pKSksIF9mOyBfZiA9IHlpZWxkIF9lLm5leHQoKSwgX2EgPSBfZi5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgX2MgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBmcmFtZSA9IF9jO1xuICAgICAgICAgICAgc3dpdGNoIChmcmFtZS50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NodW5rJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlID0gX3VwZGF0ZU1lc3NhZ2VzV2l0aERlbHRhKG1lc3NhZ2UsIGZyYW1lLmNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKGFwaUFjdGlvbnMuZ2VuZXJhdGVNZXNzYWdlQ2h1bmsobWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgLy8gQXNzdW1wdGlvbjogYSAnZmluaXNoJyB3aWxsIGZvbGxvdyB0aGUgJ2Vycm9yJywgYnV0IHdlIGtub3cgd2UgbmVlZCB0byByZXRyeVxuICAgICAgICAgICAgICAgICAgLy8gYXMgc29vbiBhcyB3ZSBzZWUgdGhlIGVycm9yLiAgVGhlcmVmb3JlLCB0aHJvdyBhbiBleGNlcHRpb24gdG8gYnJlYWsgb3V0XG4gICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgZm9yIGxvb3AuXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZnJhbWUuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICdmaW5pc2gnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKGFwaUFjdGlvbnMuZ2VuZXJhdGVNZXNzYWdlU3VjY2VzcyhtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaChhcGlBY3Rpb25zLmdlbmVyYXRlTWVzc2FnZUVycm9yKG5ldyBFcnJvcignTm8gbWVzc2FnZSB3YXMgZ2VuZXJhdGVkJykpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgICAgZV8xID0ge1xuICAgICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKGFwaUFjdGlvbnMuZ2VuZXJhdGVNZXNzYWdlRXJyb3IoZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIGNhbmNlbEFib3J0Q29udHJvbGxlciBmb3IgdGhlIG5leHQgbWVzc2FnZVxuICAgICAgICBpZiAoY2FuY2VsQWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgY2FuY2VsQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9IHdoaWxlIChyZXRyaWVzID4gMCAmJiBhdHRlbXB0IDwgcmV0cmllcyArIDEpO1xuICAgIC8vIERpZCB3ZSBleGhhdXN0IG91ciByZXRyaWVzP1xuICAgIGlmIChyZXRyaWVzID4gMCAmJiBhdHRlbXB0ID4gcmV0cmllcykge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goYXBpQWN0aW9ucy5nZW5lcmF0ZU1lc3NhZ2VFeGhhdXN0ZWRSZXRyaWVzKCkpO1xuICAgIH1cbiAgfSksIGVmZmVjdEFib3J0Q29udHJvbGxlci5zaWduYWwpKTtcbiAgc3RvcmUud2hlbihkZXZBY3Rpb25zLnN0b3BNZXNzYWdlR2VuZXJhdGlvbiwgKCkgPT4ge1xuICAgIGNhbmNlbEFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlZmZlY3RBYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBjYW5jZWxBYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfTtcbn0pO1xuLyoqXG4gKiBNZXJnZXMgZXhpc3RpbmcgYW5kIG5ldyB0b29sIGNhbGxzLlxuICpcbiAqIEBwYXJhbSBleGlzdGluZ0NhbGxzIC0gVGhlIGV4aXN0aW5nIHRvb2wgY2FsbHMuXG4gKiBAcGFyYW0gbmV3Q2FsbHMgLSBUaGUgbmV3IHRvb2wgY2FsbHMgdG8gbWVyZ2UuXG4gKiBAcmV0dXJucyBUaGUgbWVyZ2VkIGFycmF5IG9mIHRvb2wgY2FsbHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlVG9vbENhbGxzKGV4aXN0aW5nQ2FsbHMgPSBbXSwgbmV3Q2FsbHMgPSBbXSkge1xuICBjb25zdCBtZXJnZWQgPSBbLi4uZXhpc3RpbmdDYWxsc107XG4gIG5ld0NhbGxzLmZvckVhY2gobmV3Q2FsbCA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBpbmRleCA9IG1lcmdlZC5maW5kSW5kZXgoY2FsbCA9PiBjYWxsLmluZGV4ID09PSBuZXdDYWxsLmluZGV4KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IG1lcmdlZFtpbmRleF07XG4gICAgICBtZXJnZWRbaW5kZXhdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZyksIHtcbiAgICAgICAgZnVuY3Rpb246IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZnVuY3Rpb24pLCB7XG4gICAgICAgICAgYXJndW1lbnRzOiBleGlzdGluZy5mdW5jdGlvbi5hcmd1bWVudHMgKyAoKF9iID0gKF9hID0gbmV3Q2FsbC5mdW5jdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFyZ3VtZW50cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VkLnB1c2gobmV3Q2FsbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1lcmdlZDtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgbWVzc2FnZXMgYXJyYXkgd2l0aCBhbiBpbmNvbWluZyBhc3Npc3RhbnQgZGVsdGEuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VzIC0gVGhlIGN1cnJlbnQgbWVzc2FnZXMgYXJyYXkuXG4gKiBAcGFyYW0gZGVsdGEgLSBUaGUgaW5jb21pbmcgbWVzc2FnZSBkZWx0YS5cbiAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIG1lc3NhZ2VzIGFycmF5LlxuICovXG5mdW5jdGlvbiBfdXBkYXRlTWVzc2FnZXNXaXRoRGVsdGEobWVzc2FnZSwgZGVsdGEpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICBpZiAobWVzc2FnZSAmJiBtZXNzYWdlLnJvbGUgPT09ICdhc3Npc3RhbnQnICYmIGRlbHRhLmNob2ljZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgdXBkYXRlZFRvb2xDYWxscyA9IG1lcmdlVG9vbENhbGxzKG1lc3NhZ2UudG9vbENhbGxzLCAoX2EgPSBkZWx0YS5jaG9pY2VzWzBdLmRlbHRhLnRvb2xDYWxscykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pO1xuICAgIGNvbnN0IHVwZGF0ZWRNZXNzYWdlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZXNzYWdlKSwge1xuICAgICAgY29udGVudDogKChfYiA9IG1lc3NhZ2UuY29udGVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycpICsgKChfYyA9IGRlbHRhLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJycpLFxuICAgICAgdG9vbENhbGxzOiB1cGRhdGVkVG9vbENhbGxzXG4gICAgfSk7XG4gICAgcmV0dXJuIHVwZGF0ZWRNZXNzYWdlO1xuICB9IGVsc2UgaWYgKGRlbHRhLmNob2ljZXMubGVuZ3RoICYmICgoX2UgPSAoX2QgPSBkZWx0YS5jaG9pY2VzWzBdKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZGVsdGEpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yb2xlKSA9PT0gJ2Fzc2lzdGFudCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICBjb250ZW50OiAoX2YgPSBkZWx0YS5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6ICcnLFxuICAgICAgdG9vbENhbGxzOiBtZXJnZVRvb2xDYWxscyhbXSwgKF9nID0gZGVsdGEuY2hvaWNlc1swXS5kZWx0YS50b29sQ2FsbHMpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFtdKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbmNvbnN0IHJ1blRvb2xzID0gY3JlYXRlRWZmZWN0KHN0b3JlID0+IHtcbiAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBzdG9yZS53aGVuKGFwaUFjdGlvbnMuZ2VuZXJhdGVNZXNzYWdlU3VjY2VzcywgKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgdG9vbENhbGxzID0gc3RvcmUucmVhZChzZWxlY3RQZW5kaW5nVG9vbENhbGxzKTtcbiAgICBjb25zdCB0b29sRW50aXRpZXMgPSBzdG9yZS5yZWFkKHNlbGVjdFRvb2xFbnRpdGllcyk7XG4gICAgaWYgKHRvb2xDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHlpZWxkIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgc3RvcmUuZGlzcGF0Y2goaW50ZXJuYWxBY3Rpb25zLnNraXBwZWRUb29sQ2FsbHMoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRvb2xDYWxsUmVzdWx0cyA9IHRvb2xDYWxscy5tYXAodG9vbENhbGwgPT4ge1xuICAgICAgY29uc3QgdG9vbCA9IHRvb2xFbnRpdGllc1t0b29sQ2FsbC5uYW1lXTtcbiAgICAgIGlmICghdG9vbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBUb29sICR7dG9vbENhbGwubmFtZX0gbm90IGZvdW5kYCkpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXJncyA9IGlzSGFzaGJyb3duVHlwZSh0b29sLnNjaGVtYSkgPyB0b29sLnNjaGVtYS5wYXJzZUpzb25TY2hlbWEodG9vbENhbGwuYXJndW1lbnRzKSA6IEpTT04ucGFyc2UodG9vbENhbGwuYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0b29sLmhhbmRsZXIoYXJncywgYWJvcnRDb250cm9sbGVyLnNpZ25hbCkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gV2UgbWF5IGhhdmUgcmVjZWl2ZWQgdW5uZWNlc3NhcmlseSBlc2NhcGVkIGlucHV0LCBzbyB0cnlcbiAgICAgICAgLy8gYWdhaW4gd2l0aCBKU09OLnBhcnNlXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0V4cGVjdGVkIGFuIG9iamVjdCBhdCcpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBpc0hhc2hicm93blR5cGUodG9vbC5zY2hlbWEpID8gdG9vbC5zY2hlbWEucGFyc2VKc29uU2NoZW1hKEpTT04ucGFyc2UodG9vbENhbGwuYXJndW1lbnRzKSkgOiBKU09OLnBhcnNlKHRvb2xDYWxsLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRvb2wuaGFuZGxlcihhcmdzLCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IHlpZWxkIFByb21pc2UuYWxsU2V0dGxlZCh0b29sQ2FsbFJlc3VsdHMpO1xuICAgIGNvbnN0IHRvb2xNZXNzYWdlcyA9IHRvb2xDYWxscy5tYXAoKHRvb2xDYWxsLCBpbmRleCkgPT4gKHtcbiAgICAgIHJvbGU6ICd0b29sJyxcbiAgICAgIGNvbnRlbnQ6IHJlc3VsdHNbaW5kZXhdLFxuICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwuaWQsXG4gICAgICB0b29sTmFtZTogdG9vbENhbGwubmFtZVxuICAgIH0pKTtcbiAgICBzdG9yZS5kaXNwYXRjaChpbnRlcm5hbEFjdGlvbnMucnVuVG9vbENhbGxzU3VjY2Vzcyh7XG4gICAgICB0b29sTWVzc2FnZXNcbiAgICB9KSk7XG4gIH0pKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfTtcbn0pO1xuXG52YXIgZWZmZWN0cyA9IFtnZW5lcmF0ZU1lc3NhZ2UsIHJ1blRvb2xzXTtcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBDb3JlIGVudHJ5IHBvaW50IGZvciB0aGUgSGFzaGJyb3duIGZyYW1ld29yay5cbiAqIFByb3ZpZGVzIHN0YXRlIG1hbmFnZW1lbnQgYW5kIG1lc3NhZ2luZyB1dGlsaXRpZXMgZm9yIGludGVncmF0aW5nIExMTS1iYXNlZCBjaGF0IGludGVyYWN0aW9ucyBpbnRvIGZyb250ZW5kIGFwcGxpY2F0aW9ucy5cbiAqL1xuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGZyeUhhc2hicm93bihpbml0KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgaGFzSWxsZWdhbE91dHB1dFRvb2wgPSAoX2EgPSBpbml0LnRvb2xzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSh0b29sID0+IHRvb2wubmFtZSA9PT0gJ291dHB1dCcpO1xuICBpZiAoaGFzSWxsZWdhbE91dHB1dFRvb2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcIm91dHB1dFwiIHRvb2wgbmFtZSBpcyBhIHJlc2VydmVkIHRvb2wgbmFtZSBhbmQgY2Fubm90IGJlIHVzZWQuJyk7XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdG9yZSh7XG4gICAgZGVidWdOYW1lOiBpbml0LmRlYnVnTmFtZSxcbiAgICByZWR1Y2VycyxcbiAgICBlZmZlY3RzLFxuICAgIHByb2plY3RTdGF0ZUZvckRldnRvb2xzOiBzdGF0ZSA9PiAoe1xuICAgICAgbWVzc2FnZXM6IHNlbGVjdFZpZXdNZXNzYWdlcyhzdGF0ZSksXG4gICAgICBpc1JlY2VpdmluZzogc2VsZWN0SXNSZWNlaXZpbmcoc3RhdGUpLFxuICAgICAgaXNTZW5kaW5nOiBzZWxlY3RJc1NlbmRpbmcoc3RhdGUpLFxuICAgICAgaXNSdW5uaW5nVG9vbENhbGxzOiBzZWxlY3RJc1J1bm5pbmdUb29sQ2FsbHMoc3RhdGUpLFxuICAgICAgZXJyb3I6IHNlbGVjdEVycm9yKHN0YXRlKSxcbiAgICAgIMm1ybVpbnRlcm5hbDogc3RhdGVcbiAgICB9KVxuICB9KTtcbiAgc3RhdGUuZGlzcGF0Y2goZGV2QWN0aW9ucy5pbml0KHtcbiAgICBhcGlVcmw6IGluaXQuYXBpVXJsLFxuICAgIG1vZGVsOiBpbml0Lm1vZGVsLFxuICAgIHN5c3RlbTogaW5pdC5zeXN0ZW0sXG4gICAgbWVzc2FnZXM6IGluaXQubWVzc2FnZXMsXG4gICAgdG9vbHM6IGluaXQudG9vbHMsXG4gICAgcmVzcG9uc2VTY2hlbWE6IGluaXQucmVzcG9uc2VTY2hlbWEsXG4gICAgbWlkZGxld2FyZTogaW5pdC5taWRkbGV3YXJlLFxuICAgIGVtdWxhdGVTdHJ1Y3R1cmVkT3V0cHV0OiBpbml0LmVtdWxhdGVTdHJ1Y3R1cmVkT3V0cHV0LFxuICAgIGRlYm91bmNlOiBpbml0LmRlYm91bmNlLFxuICAgIHJldHJpZXM6IGluaXQucmV0cmllc1xuICB9KSk7XG4gIGZ1bmN0aW9uIHNldE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgc3RhdGUuZGlzcGF0Y2goZGV2QWN0aW9ucy5zZXRNZXNzYWdlcyh7XG4gICAgICBtZXNzYWdlczogbWVzc2FnZXNcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHN0YXRlLmRpc3BhdGNoKGRldkFjdGlvbnMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiByZXNlbmRNZXNzYWdlcygpIHtcbiAgICBzdGF0ZS5kaXNwYXRjaChkZXZBY3Rpb25zLnJlc2VuZE1lc3NhZ2VzKCkpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHN0YXRlLmRpc3BhdGNoKGRldkFjdGlvbnMudXBkYXRlT3B0aW9ucyhvcHRpb25zKSk7XG4gIH1cbiAgZnVuY3Rpb24gc2l6emxlKCkge1xuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZWZmZWN0Q2xlYW51cEZuO1xuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZmZlY3RDbGVhbnVwRm4gPSBzdGF0ZS5ydW5FZmZlY3RzKCk7XG4gICAgICBzdGF0ZS5kaXNwYXRjaChpbnRlcm5hbEFjdGlvbnMuc2l6emxlKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoJ0luaXRpYWxpemF0aW9uIGFib3J0ZWQnKTtcbiAgICAgIGVmZmVjdENsZWFudXBGbiA9PT0gbnVsbCB8fCBlZmZlY3RDbGVhbnVwRm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVmZmVjdENsZWFudXBGbigpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3RvcChjbGVhclN0cmVhbWluZ01lc3NhZ2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IGlzTG9hZGluZyA9IHN0YXRlLnJlYWQoc2VsZWN0SXNMb2FkaW5nKTtcbiAgICBpZiAoIWlzTG9hZGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3RvcCBzdHJlYW1pbmcgbWVzc2FnZXMgd2hlbiBub3Qgc3RyZWFtaW5nLicpO1xuICAgIH1cbiAgICBzdGF0ZS5kaXNwYXRjaChkZXZBY3Rpb25zLnN0b3BNZXNzYWdlR2VuZXJhdGlvbihjbGVhclN0cmVhbWluZ01lc3NhZ2UpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNldE1lc3NhZ2VzLFxuICAgIHNlbmRNZXNzYWdlLFxuICAgIHJlc2VuZE1lc3NhZ2VzLFxuICAgIHVwZGF0ZU9wdGlvbnMsXG4gICAgc3RvcCxcbiAgICBzaXp6bGUsXG4gICAgbWVzc2FnZXM6IHN0YXRlLmNyZWF0ZVNpZ25hbChzZWxlY3RWaWV3TWVzc2FnZXMpLFxuICAgIGVycm9yOiBzdGF0ZS5jcmVhdGVTaWduYWwoc2VsZWN0RXJyb3IpLFxuICAgIGlzUmVjZWl2aW5nOiBzdGF0ZS5jcmVhdGVTaWduYWwoc2VsZWN0SXNSZWNlaXZpbmcpLFxuICAgIGlzU2VuZGluZzogc3RhdGUuY3JlYXRlU2lnbmFsKHNlbGVjdElzU2VuZGluZyksXG4gICAgaXNSdW5uaW5nVG9vbENhbGxzOiBzdGF0ZS5jcmVhdGVTaWduYWwoc2VsZWN0SXNSdW5uaW5nVG9vbENhbGxzKSxcbiAgICBpc0xvYWRpbmc6IHN0YXRlLmNyZWF0ZVNpZ25hbChzZWxlY3RJc0xvYWRpbmcpLFxuICAgIGV4aGF1c3RlZFJldHJpZXM6IHN0YXRlLmNyZWF0ZVNpZ25hbChzZWxlY3RFeGhhdXN0ZWRSZXRyaWVzKSxcbiAgICBsYXN0QXNzaXN0YW50TWVzc2FnZTogc3RhdGUuY3JlYXRlU2lnbmFsKHNlbGVjdExhc3RBc3Npc3RhbnRNZXNzYWdlKVxuICB9O1xufVxuXG5jb25zdCBQTEFDRUhPTERFUl9QUkVGSVggPSAnX19IQlhfJztcbi8qKlxuICogV2VhdmUgdGVtcGxhdGUgZXhwcmVzc2lvbnMgaW50byBhIHNpbmdsZSBzdHJpbmcgYnkgaW5zZXJ0aW5nIHN0YWJsZSBwbGFjZWhvbGRlcnNcbiAqIChlLmcuLCBfX0hCWF8wX18pIGF0IGV4cHJlc3Npb24gcG9zaXRpb25zLiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0ZWQgdGV4dCBhbmRcbiAqIHRoZSBvcmRlcmVkIGxpc3Qgb2YgcGxhY2Vob2xkZXIgdG9rZW5zLlxuICovXG5mdW5jdGlvbiB3ZWF2ZVBsYWNlaG9sZGVycyhzdHJpbmdzLCBleHBycykge1xuICBjb25zdCB0b2tlbnMgPSBzdHJpbmdzLm1hcCgoY2h1bmssIGkpID0+IGkgPCBleHBycy5sZW5ndGggPyBgJHtjaHVua30ke1BMQUNFSE9MREVSX1BSRUZJWH0ke2l9X19gIDogY2h1bmspLmpvaW4oJycpO1xuICBjb25zdCBwbGFjZWhvbGRlcnMgPSBleHBycy5tYXAoKF8sIGkpID0+IGAke1BMQUNFSE9MREVSX1BSRUZJWH0ke2l9X19gKTtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0OiB0b2tlbnMsXG4gICAgcGxhY2Vob2xkZXJzXG4gIH07XG59XG4vKipcbiAqIEZ1bmN0aW9uYWwgc2NhbiBmb3IgPHVpPi4uLjwvdWk+IGJsb2Nrcy4gUHJvZHVjZXMgYW4gYXJyYXkgb2YgVWlCbG9jayBkZXNjcmlwdG9yc1xuICogaW5jbHVkaW5nIGFic29sdXRlIG9mZnNldHMgYW5kIGlubmVyIHNvdXJjZSB0ZXh0LlxuICovXG5mdW5jdGlvbiBmaW5kVWlCbG9ja3ModGV4dCkge1xuICBjb25zdCBuZXh0ID0gKGZyb20sIGFjYykgPT4ge1xuICAgIGNvbnN0IHN0YXJ0VGFnID0gdGV4dC5pbmRleE9mKCc8dWk+JywgZnJvbSk7XG4gICAgaWYgKHN0YXJ0VGFnID09PSAtMSkgcmV0dXJuIGFjYztcbiAgICBjb25zdCBlbmRUYWcgPSB0ZXh0LmluZGV4T2YoJzwvdWk+Jywgc3RhcnRUYWcpO1xuICAgIGlmIChlbmRUYWcgPT09IC0xKSByZXR1cm4gYWNjO1xuICAgIGNvbnN0IGlubmVyU3RhcnQgPSBzdGFydFRhZyArICc8dWk+Jy5sZW5ndGg7XG4gICAgY29uc3QgaW5uZXJFbmQgPSBlbmRUYWc7XG4gICAgY29uc3QgYmxvY2tUZXh0ID0gdGV4dC5zbGljZShpbm5lclN0YXJ0LCBpbm5lckVuZCk7XG4gICAgY29uc3QgYmxvY2sgPSB7XG4gICAgICBzdGFydDogc3RhcnRUYWcsXG4gICAgICBlbmQ6IGVuZFRhZyArICc8L3VpPicubGVuZ3RoLFxuICAgICAgaW5uZXJTdGFydCxcbiAgICAgIGlubmVyRW5kLFxuICAgICAgc291cmNlOiBibG9ja1RleHQsXG4gICAgICBhc3Q6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gbmV4dChlbmRUYWcgKyA1LCBhY2MuY29uY2F0KGJsb2NrKSk7XG4gIH07XG4gIHJldHVybiBuZXh0KDAsIFtdKTtcbn1cbi8qKiBXaGl0ZXNwYWNlIGNoZWNrIGhlbHBlci4gKi9cbmNvbnN0IGlzV2hpdGVzcGFjZSA9IGNoID0+IC9cXHMvLnRlc3QoY2gpO1xuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSA8dWk+IGlubmVyIHNvdXJjZSBpbnRvIFVpQXN0IG5vZGVzLiBQdXJlIGZ1bmN0aW9uOiByZXR1cm5zXG4gKiB0aGUgbm9kZXMgYW5kIGFueSBkaWFnbm9zdGljcyBnYXRoZXJlZCB3aGlsZSBwYXJzaW5nLlxuICovXG5mdW5jdGlvbiBwYXJzZVVpKHNvdXJjZSwgYmFzZU9mZnNldCkge1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGRpYWdzID0gW107XG4gIGNvbnN0IGRpYWcgPSBkID0+IHtcbiAgICBkaWFncy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZCksIHtcbiAgICAgIGxpbmU6IDAsXG4gICAgICBjb2x1bW46IDBcbiAgICB9KSk7XG4gIH07XG4gIGNvbnN0IHNraXBXcyA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgd2hpbGUgKGkgPCBzb3VyY2UubGVuZ3RoICYmIGlzV2hpdGVzcGFjZSgoX2EgPSBzb3VyY2VbaV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKSkgaSsrO1xuICB9O1xuICBjb25zdCBwYXJzZVRleHQgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgd2hpbGUgKGkgPCBzb3VyY2UubGVuZ3RoICYmIHNvdXJjZVtpXSAhPT0gJzwnKSB7XG4gICAgICB0ZXh0ICs9IHNvdXJjZVtpXTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHRleHQubGVuZ3RoID09PSAwID8gbnVsbCA6IHtcbiAgICAgIGtpbmQ6ICd0ZXh0JyxcbiAgICAgIHRleHQsXG4gICAgICBzdGFydDogYmFzZU9mZnNldCArIHN0YXJ0LFxuICAgICAgZW5kOiBiYXNlT2Zmc2V0ICsgaVxuICAgIH07XG4gIH07XG4gIGNvbnN0IHBhcnNlQXR0cnMgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBhdHRycyA9IHt9O1xuICAgIHdoaWxlIChpIDwgc291cmNlLmxlbmd0aCkge1xuICAgICAgc2tpcFdzKCk7XG4gICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgIGlmIChjaCA9PT0gJy8nIHx8IGNoID09PSAnPicgfHwgY2ggPT0gbnVsbCkgYnJlYWs7XG4gICAgICBjb25zdCBuYW1lU3RhcnQgPSBpO1xuICAgICAgbGV0IG5hbWUgPSAnJztcbiAgICAgIHdoaWxlIChpIDwgc291cmNlLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gKF9hID0gc291cmNlW2ldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgaWYgKC9bLUEtWmEtejAtOV86JF0vLnRlc3QoYykpIHtcbiAgICAgICAgICBuYW1lICs9IGM7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBza2lwV3MoKTtcbiAgICAgIGNvbnN0IHJlYWRVbnF1b3RlZCA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB2cyA9IGk7XG4gICAgICAgIHdoaWxlIChpIDwgc291cmNlLmxlbmd0aCAmJiAvW15cXHMvPl0vLnRlc3QoKF9hID0gc291cmNlW2ldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykpIGkrKztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogc291cmNlLnNsaWNlKHZzLCBpKSxcbiAgICAgICAgICBzdGFydDogYmFzZU9mZnNldCArIHZzLFxuICAgICAgICAgIGVuZDogYmFzZU9mZnNldCArIGlcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZWFkUXVvdGVkID0gcSA9PiB7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29uc3QgdnMgPSBpO1xuICAgICAgICB3aGlsZSAoaSA8IHNvdXJjZS5sZW5ndGggJiYgc291cmNlW2ldICE9PSBxKSBpKys7XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzb3VyY2Uuc2xpY2UodnMsIGkpO1xuICAgICAgICBjb25zdCBzcGFuID0ge1xuICAgICAgICAgIHZhbHVlOiBzZWdtZW50LFxuICAgICAgICAgIHN0YXJ0OiBiYXNlT2Zmc2V0ICsgdnMsXG4gICAgICAgICAgZW5kOiBiYXNlT2Zmc2V0ICsgaVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc291cmNlW2ldID09PSBxKSBpKys7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGF0dHJTcGFuID0gc291cmNlW2ldID09PSAnPScgPyAoKCkgPT4ge1xuICAgICAgICBpKys7XG4gICAgICAgIHNraXBXcygpO1xuICAgICAgICBjb25zdCBxID0gc291cmNlW2ldO1xuICAgICAgICByZXR1cm4gcSA9PT0gJ1wiJyB8fCBxID09PSBcIidcIiA/IHJlYWRRdW90ZWQocSkgOiByZWFkVW5xdW90ZWQoKTtcbiAgICAgIH0pKCkgOiB7XG4gICAgICAgIHZhbHVlOiAndHJ1ZScsXG4gICAgICAgIHN0YXJ0OiBiYXNlT2Zmc2V0ICsgbmFtZVN0YXJ0LFxuICAgICAgICBlbmQ6IGJhc2VPZmZzZXQgKyBpXG4gICAgICB9O1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRycywgbmFtZSkpIHtcbiAgICAgICAgZGlhZyh7XG4gICAgICAgICAgY29kZTogJ0UxNDAxJyxcbiAgICAgICAgICBzZXZlcml0eTogJ2Vycm9yJyxcbiAgICAgICAgICBtZXNzYWdlOiBgRHVwbGljYXRlIGF0dHJpYnV0ZSBcIiR7bmFtZX1cImAsXG4gICAgICAgICAgc3RhcnQ6IGJhc2VPZmZzZXQgKyBuYW1lU3RhcnQsXG4gICAgICAgICAgZW5kOiBiYXNlT2Zmc2V0ICsgaSxcbiAgICAgICAgICBzbmlwcGV0OiBzb3VyY2Uuc2xpY2UobmFtZVN0YXJ0LCBpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGF0dHJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdHRycyksIHtcbiAgICAgICAgW25hbWVdOiBhdHRyU3BhblxuICAgICAgfSk7XG4gICAgICBza2lwV3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9O1xuICBjb25zdCBwYXJzZUVsZW1lbnQgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChzb3VyY2VbaV0gIT09ICc8JykgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgIGkrKztcbiAgICBpZiAoc291cmNlW2ldID09PSAnLycpIHJldHVybiBudWxsO1xuICAgIGxldCB0YWcgPSAnJztcbiAgICB3aGlsZSAoaSA8IHNvdXJjZS5sZW5ndGggJiYgL1stQS1aYS16MC05XS8udGVzdCgoX2EgPSBzb3VyY2VbaV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKSkge1xuICAgICAgdGFnICs9IHNvdXJjZVtpXTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgc2tpcFdzKCk7XG4gICAgY29uc3QgYXR0cnMgPSBwYXJzZUF0dHJzKCk7XG4gICAgY29uc3Qgc2VsZkNsb3NpbmcgPSBzb3VyY2VbaV0gPT09ICcvJyA/IChpKyssIHRydWUpIDogZmFsc2U7XG4gICAgaWYgKHNvdXJjZVtpXSA9PT0gJz4nKSBpKys7XG4gICAgY29uc3QgcGFyc2VDaGlsZHJlbiA9IGFjYyA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoaSA+PSBzb3VyY2UubGVuZ3RoKSByZXR1cm4gYWNjO1xuICAgICAgaWYgKHNvdXJjZVtpXSA9PT0gJzwnICYmIHNvdXJjZVtpICsgMV0gPT09ICcvJykge1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIHdoaWxlIChpIDwgc291cmNlLmxlbmd0aCAmJiAvWy1BLVphLXowLTldLy50ZXN0KChfYSA9IHNvdXJjZVtpXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpKSBpKys7XG4gICAgICAgIHdoaWxlIChpIDwgc291cmNlLmxlbmd0aCAmJiBzb3VyY2VbaV0gIT09ICc+JykgaSsrO1xuICAgICAgICBpZiAoc291cmNlW2ldID09PSAnPicpIGkrKztcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gc291cmNlW2ldID09PSAnPCcgPyBwYXJzZUVsZW1lbnQoKSA6IHBhcnNlVGV4dCgpO1xuICAgICAgcmV0dXJuIGNoaWxkID09IG51bGwgPyBhY2MgOiBwYXJzZUNoaWxkcmVuKGFjYy5jb25jYXQoY2hpbGQpKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkcmVuID0gc2VsZkNsb3NpbmcgPyBbXSA6IHBhcnNlQ2hpbGRyZW4oW10pO1xuICAgIGNvbnN0IGVuZCA9IGJhc2VPZmZzZXQgKyBpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiAnZWxlbWVudCcsXG4gICAgICB0YWcsXG4gICAgICBzdGFydDogYmFzZU9mZnNldCArIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgYXR0cnMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHNlbGZDbG9zaW5nXG4gICAgfTtcbiAgfTtcbiAgY29uc3QgcGFyc2VOb2RlcyA9IGFjYyA9PiB7XG4gICAgc2tpcFdzKCk7XG4gICAgaWYgKGkgPj0gc291cmNlLmxlbmd0aCkgcmV0dXJuIGFjYztcbiAgICBjb25zdCBub2RlID0gc291cmNlW2ldID09PSAnPCcgPyBwYXJzZUVsZW1lbnQoKSA6IHBhcnNlVGV4dCgpO1xuICAgIHJldHVybiBub2RlID09IG51bGwgPyBhY2MgOiBwYXJzZU5vZGVzKGFjYy5jb25jYXQobm9kZSkpO1xuICB9O1xuICBjb25zdCBub2RlcyA9IHBhcnNlTm9kZXMoW10pO1xuICByZXR1cm4ge1xuICAgIG5vZGVzLFxuICAgIGRpYWdub3N0aWNzOiBkaWFnc1xuICB9O1xufVxuLyoqIE1hcCBhYnNvbHV0ZSBvZmZzZXQgdG8gMS1iYXNlZCB7bGluZSwgY29sdW1ufS4gKi9cbmZ1bmN0aW9uIGFic29sdXRlVG9MaW5lQ29sKHRleHQsIGFicykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHNsaWNlID0gdGV4dC5zbGljZSgwLCBNYXRoLm1pbihhYnMsIHRleHQubGVuZ3RoKSk7XG4gIGNvbnN0IGxpbmVzID0gc2xpY2Uuc3BsaXQoJ1xcbicpO1xuICBjb25zdCBsaW5lID0gbGluZXMubGVuZ3RoO1xuICBjb25zdCBjb2x1bW4gPSAoKF9hID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKS5sZW5ndGggKyAxO1xuICByZXR1cm4ge1xuICAgIGxpbmUsXG4gICAgY29sdW1uXG4gIH07XG59XG4vKiogUGxhaW4tb2JqZWN0IGNoZWNrIHRoYXQgZXhjbHVkZXMgYXJyYXlzIGFuZCBjbGFzcyBpbnN0YW5jZXMuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHYpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yodik7XG4gIHJldHVybiBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbDtcbn1cbi8qKiBFbnN1cmUgdmFsdWVzIGFyZSBKU09OLXNlcmlhbGl6YWJsZSBhY2NvcmRpbmcgdG8gcG9saWN5LiAqL1xuZnVuY3Rpb24gZW5zdXJlU2VyaWFsaXphYmxlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSByZXR1cm4gJ0JpZ0ludCc7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHJldHVybiAnZnVuY3Rpb24nO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykgcmV0dXJuICdzeW1ib2wnO1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gJ0RhdGUnO1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHJldHVybiAnTWFwJztcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSByZXR1cm4gJ1NldCc7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGZpcnN0QmFkID0gdmFsdWUubWFwKGVuc3VyZVNlcmlhbGl6YWJsZSkuZmluZChyID0+IHIgIT09IHRydWUpO1xuICAgIHJldHVybiBmaXJzdEJhZCAhPT0gbnVsbCAmJiBmaXJzdEJhZCAhPT0gdm9pZCAwID8gZmlyc3RCYWQgOiB0cnVlO1xuICB9XG4gIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChfYSkge1xuICAgICAgcmV0dXJuICdjaXJjdWxhcic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnY2xhc3MtaW5zdGFuY2UnO1xufVxuLyoqIExvd2VyIGEgVWlBc3QgZWxlbWVudCBpbnRvIGFuIEhCTm9kZSwgY29sbGVjdGluZyBkaWFnbm9zdGljcyBmdW5jdGlvbmFsbHkuICovXG5mdW5jdGlvbiBsb3dlclRvSEIobm9kZSwgZXhwcnNCeVRva2VuKSB7XG4gIGlmIChub2RlLmtpbmQgPT09ICd0ZXh0JykgcmV0dXJuIHtcbiAgICBoYjogbnVsbCxcbiAgICBkaWFnbm9zdGljczogW11cbiAgfTtcbiAgY29uc3QgZm9sZEF0dHJzID0gZW50cmllcyA9PiB7XG4gICAgcmV0dXJuIGVudHJpZXMucmVkdWNlKChhY2MsIFtrLCBzcGFuXSkgPT4ge1xuICAgICAgY29uc3QgcmF3ID0gc3Bhbi52YWx1ZTtcbiAgICAgIGlmIChyYXcuc3RhcnRzV2l0aChQTEFDRUhPTERFUl9QUkVGSVgpKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGV4cHJzQnlUb2tlbi5nZXQocmF3KTtcbiAgICAgICAgY29uc3Qgc2VyID0gZW5zdXJlU2VyaWFsaXphYmxlKHZhbCk7XG4gICAgICAgIHJldHVybiBzZXIgIT09IHRydWUgPyB7XG4gICAgICAgICAgcHJvcHM6IGFjYy5wcm9wcyxcbiAgICAgICAgICBkaWFnbm9zdGljczogYWNjLmRpYWdub3N0aWNzLmNvbmNhdCh7XG4gICAgICAgICAgICBjb2RlOiAnRTEzMDEnLFxuICAgICAgICAgICAgc2V2ZXJpdHk6ICdlcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBgJHtyYXd9IGlzIG5vdCBKU09OLXNlcmlhbGl6YWJsZSAoJHtzZXJ9KS5gLFxuICAgICAgICAgICAgc3RhcnQ6IHNwYW4uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHNwYW4uZW5kLFxuICAgICAgICAgICAgbGluZTogMCxcbiAgICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgICAgIHNuaXBwZXQ6IHJhd1xuICAgICAgICAgIH0pXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgcHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjLnByb3BzKSwge1xuICAgICAgICAgICAgW2tdOiB2YWxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBkaWFnbm9zdGljczogYWNjLmRpYWdub3N0aWNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHJhdyA9PT0gJ3RydWUnID8gdHJ1ZSA6IHJhdyA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogcmF3ID09PSAnbnVsbCcgPyBudWxsIDogL14tP1xcZCsoPzpcXC5cXGQrKT8kLy50ZXN0KHJhdykgPyBOdW1iZXIocmF3KSA6IHJhdztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYy5wcm9wcyksIHtcbiAgICAgICAgICBba106IHZhbHVlXG4gICAgICAgIH0pLFxuICAgICAgICBkaWFnbm9zdGljczogYWNjLmRpYWdub3N0aWNzXG4gICAgICB9O1xuICAgIH0sIHtcbiAgICAgIHByb3BzOiB7fSxcbiAgICAgIGRpYWdub3N0aWNzOiBbXVxuICAgIH0pO1xuICB9O1xuICBjb25zdCB7XG4gICAgcHJvcHMsXG4gICAgZGlhZ25vc3RpY3M6IGF0dHJEaWFnc1xuICB9ID0gZm9sZEF0dHJzKE9iamVjdC5lbnRyaWVzKG5vZGUuYXR0cnMpKTtcbiAgY29uc3QgY2hpbGRyZW5Mb3dlcmVkID0gbm9kZS5jaGlsZHJlbi5tYXAoYyA9PiBsb3dlclRvSEIoYywgZXhwcnNCeVRva2VuKSk7XG4gIGNvbnN0IGNoaWxkRGlhZ3MgPSBjaGlsZHJlbkxvd2VyZWQuZmxhdE1hcChyID0+IHIuZGlhZ25vc3RpY3MpO1xuICBjb25zdCBjaGlsZHJlbiA9IGNoaWxkcmVuTG93ZXJlZC5tYXAociA9PiByLmhiKS5maWx0ZXIoaCA9PiBoICE9IG51bGwpO1xuICBjb25zdCBoYiA9IGNoaWxkcmVuLmxlbmd0aCA/IHtcbiAgICAkdGFnOiBub2RlLnRhZyxcbiAgICAkY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICRwcm9wczogcHJvcHNcbiAgfSA6IHtcbiAgICAkdGFnOiBub2RlLnRhZyxcbiAgICAkY2hpbGRyZW46IFtdLFxuICAgICRwcm9wczogcHJvcHNcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBoYixcbiAgICBkaWFnbm9zdGljczogYXR0ckRpYWdzLmNvbmNhdChjaGlsZERpYWdzKVxuICB9O1xufVxuLyoqXG4gKiBMb3dlciBhIFVpQXN0IGVsZW1lbnQgaW50byBhIGZsZXhpYmxlIEhCIG5vZGUgdGhhdCBjYW4gcmVwcmVzZW50IHRleHQgY2hpbGRyZW5cbiAqICh3aGVuIGNvbXBvbmVudCBwb2xpY3kgaXMgJ3RleHQnKS4gVGhpcyB2YXJpYW50IHJlcXVpcmVzIGFjY2VzcyB0byB0aGUgY29tcG9uZW50XG4gKiByZWdpc3RyeSAoYnkgbmFtZSBvciBzZWxlY3RvcikgdG8ga25vdyBlYWNoIGNvbXBvbmVudCdzIGNoaWxkcmVuIHBvbGljeS5cbiAqL1xuZnVuY3Rpb24gbG93ZXJXaXRoUG9saWN5KG5vZGUsIGV4cHJzQnlUb2tlbiwgYnlOYW1lKSB7XG4gIGlmIChub2RlLmtpbmQgPT09ICd0ZXh0JykgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGZvbGRBdHRycyA9IGVudHJpZXMgPT4ge1xuICAgIHJldHVybiBlbnRyaWVzLnJlZHVjZSgoYWNjLCBbaywgc3Bhbl0pID0+IHtcbiAgICAgIGNvbnN0IHJhdyA9IHNwYW4udmFsdWU7XG4gICAgICBpZiAocmF3LnN0YXJ0c1dpdGgoUExBQ0VIT0xERVJfUFJFRklYKSkge1xuICAgICAgICBjb25zdCB2YWwgPSBleHByc0J5VG9rZW4uZ2V0KHJhdyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHtcbiAgICAgICAgICBba106IHZhbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcmF3ID09PSAndHJ1ZScgPyB0cnVlIDogcmF3ID09PSAnZmFsc2UnID8gZmFsc2UgOiByYXcgPT09ICdudWxsJyA/IG51bGwgOiAvXi0/XFxkKyg/OlxcLlxcZCspPyQvLnRlc3QocmF3KSA/IE51bWJlcihyYXcpIDogcmF3O1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjKSwge1xuICAgICAgICBba106IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCB7fSk7XG4gIH07XG4gIGNvbnN0IHByb3BzID0gZm9sZEF0dHJzKE9iamVjdC5lbnRyaWVzKG5vZGUuYXR0cnMpKTtcbiAgY29uc3QgY29tcCA9IGJ5TmFtZS5nZXQobm9kZS50YWcpO1xuICBjb25zdCBwb2xpY3kgPSBjb21wID8gY29tcC5jaGlsZHJlbiA6IHVuZGVmaW5lZDtcbiAgaWYgKHBvbGljeSA9PT0gJ3RleHQnKSB7XG4gICAgLy8gQ29uY2F0ZW5hdGUgb25seSB0ZXh0IGNoaWxkcmVuIChwcmVzZXJ2ZSBwbGFjZWhvbGRlcnMpIGFzIGNvbnRlbnRcbiAgICBjb25zdCBjb250ZW50ID0gbm9kZS5jaGlsZHJlbi5tYXAoYyA9PiBjLmtpbmQgPT09ICd0ZXh0JyA/IGMudGV4dCA6ICcnKS5qb2luKCcnKTtcbiAgICBjb25zdCBlbGVtZW50Q2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcChjID0+IGMua2luZCA9PT0gJ2VsZW1lbnQnID8gbG93ZXJXaXRoUG9saWN5KGMsIGV4cHJzQnlUb2tlbiwgYnlOYW1lKSA6IG51bGwpLmZpbHRlcihoID0+IGggIT0gbnVsbCk7XG4gICAgLy8gSW5jbHVkZSBhIG1ldGEgcHJvcGVydHkgZm9yIHZhbGlkYXRpb247IHN0cmlwcGVkIG91dCBmb3IgaW5qZWN0aW9uIGxhdGVyXG4gICAgcmV0dXJuIHtcbiAgICAgICR0YWc6IG5vZGUudGFnLFxuICAgICAgJGNoaWxkcmVuOiBjb250ZW50LFxuICAgICAgJGVsZW1lbnRDaGlsZHJlbjogZWxlbWVudENoaWxkcmVuLFxuICAgICAgJHByb3BzOiBwcm9wc1xuICAgIH07XG4gIH1cbiAgLy8gRGVmYXVsdCBiZWhhdmlvcjogbG93ZXIgZWxlbWVudCBjaGlsZHJlbiBvbmx5IChpZ25vcmUgdGV4dCBub2RlcylcbiAgY29uc3QgbG93ZXJlZENoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoYyA9PiBjLmtpbmQgPT09ICdlbGVtZW50JyA/IGxvd2VyV2l0aFBvbGljeShjLCBleHByc0J5VG9rZW4sIGJ5TmFtZSkgOiBudWxsKS5maWx0ZXIoaCA9PiBoICE9IG51bGwpO1xuICByZXR1cm4ge1xuICAgICR0YWc6IG5vZGUudGFnLFxuICAgICRjaGlsZHJlbjogbG93ZXJlZENoaWxkcmVuLFxuICAgICRwcm9wczogcHJvcHNcbiAgfTtcbn1cbi8qKiBDb21wdXRlIExldmVuc2h0ZWluIGRpc3RhbmNlIGZvciBuZWFyZXN0LW5hbWUgc3VnZ2VzdGlvbnMuICovXG5mdW5jdGlvbiBsZXZlbnNodGVpbihhLCBiKSB7XG4gIGNvbnN0IGRwID0gQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiBhLmxlbmd0aCArIDFcbiAgfSwgKF8sIGkpID0+IEFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogYi5sZW5ndGggKyAxXG4gIH0sIChfLCBqKSA9PiBpID09PSAwID8gaiA6IGogPT09IDAgPyBpIDogMCkpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYi5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgY29zdCA9IGFbaSAtIDFdID09PSBiW2ogLSAxXSA/IDAgOiAxO1xuICAgICAgZHBbaV1bal0gPSBNYXRoLm1pbihkcFtpIC0gMV1bal0gKyAxLCBkcFtpXVtqIC0gMV0gKyAxLCBkcFtpIC0gMV1baiAtIDFdICsgY29zdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkcFthLmxlbmd0aF1bYi5sZW5ndGhdO1xufVxuLyoqIFZhbGlkYXRlIGV4YW1wbGVzIGFnYWluc3QgY29tcG9uZW50IHJlZ2lzdHJ5OyByZXR1cm5zIGRpYWdub3N0aWNzIChmdW5jdGlvbmFsKS4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhhbXBsZXMoZXhhbXBsZXMsIGJsb2NrcywgY29tcG9uZW50cywgdG9MaW5lQ29sKSB7XG4gIGNvbnN0IGJ5TmFtZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgYWxsTmFtZXMgPSBbXTtcbiAgY29tcG9uZW50cy5mb3JFYWNoKGMgPT4ge1xuICAgIGlmIChjICYmIHR5cGVvZiBjLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieU5hbWUuc2V0KGMubmFtZSwgYyk7XG4gICAgICBhbGxOYW1lcy5wdXNoKGMubmFtZSk7XG4gICAgfVxuICAgIC8vIFN1cHBvcnQgQW5ndWxhci1zdHlsZSBzZWxlY3RvciBhbGlhc2VzXG4gICAgaWYgKGMgJiYgdHlwZW9mIGMuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBzZWwgPSBjLnNlbGVjdG9yO1xuICAgICAgYnlOYW1lLnNldChzZWwsIGMpO1xuICAgICAgYWxsTmFtZXMucHVzaChzZWwpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHZpc2l0ID0gKG5vZGUsIGJsaykgPT4ge1xuICAgIGNvbnN0IGNvbXAgPSBieU5hbWUuZ2V0KG5vZGUuJHRhZyk7XG4gICAgaWYgKCFjb21wKSB7XG4gICAgICBjb25zdCBzdWdnZXN0aW9ucyA9IGFsbE5hbWVzLm1hcChuID0+ICh7XG4gICAgICAgIG4sXG4gICAgICAgIGQ6IGxldmVuc2h0ZWluKG4udG9Mb3dlckNhc2UoKSwgbm9kZS4kdGFnLnRvTG93ZXJDYXNlKCkpXG4gICAgICB9KSkuc29ydCgoYSwgYikgPT4gYS5kIC0gYi5kKS5zbGljZSgwLCAxKS5tYXAoeCA9PiB4Lm4pO1xuICAgICAgcmV0dXJuIFtPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjb2RlOiAnRTEwMDEnLFxuICAgICAgICBzZXZlcml0eTogJ2Vycm9yJyxcbiAgICAgICAgbWVzc2FnZTogYDwke25vZGUuJHRhZ30+IG5vdCBmb3VuZC5gICsgKHN1Z2dlc3Rpb25zLmxlbmd0aCA/IGAgRGlkIHlvdSBtZWFuIDwke3N1Z2dlc3Rpb25zWzBdfT4/YCA6ICcnKSxcbiAgICAgICAgc3RhcnQ6IGJsay5pbm5lclN0YXJ0LFxuICAgICAgICBlbmQ6IGJsay5pbm5lckVuZFxuICAgICAgfSwgdG9MaW5lQ29sKGJsay5pbm5lclN0YXJ0KSksIHtcbiAgICAgICAgc25pcHBldDogYmxrLnNvdXJjZVxuICAgICAgfSldO1xuICAgIH1cbiAgICBjb25zdCBkaWFncyA9IFtdO1xuICAgIGlmIChjb21wLnByb3BzICYmIHR5cGVvZiBjb21wLnByb3BzID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgZGVmaW5lZFByb3BzID0gbmV3IFNldChPYmplY3Qua2V5cyhjb21wLnByb3BzKSk7XG4gICAgICBjb25zdCBub2RlUHJvcHMgPSBub2RlLiRwcm9wcyB8fCB7fTtcbiAgICAgIGRlZmluZWRQcm9wcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmICghKGtleSBpbiBub2RlUHJvcHMpKSB7XG4gICAgICAgICAgZGlhZ3MucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY29kZTogJ0UxMTAyJyxcbiAgICAgICAgICAgIHNldmVyaXR5OiAnZXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogYDwke25vZGUuJHRhZ30+IG1pc3NpbmcgcmVxdWlyZWQgcHJvcCBcIiR7a2V5fVwiLmAsXG4gICAgICAgICAgICBzdGFydDogYmxrLmlubmVyU3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGJsay5pbm5lckVuZFxuICAgICAgICAgIH0sIHRvTGluZUNvbChibGsuaW5uZXJTdGFydCkpLCB7XG4gICAgICAgICAgICBzbmlwcGV0OiBibGsuc291cmNlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKG5vZGVQcm9wcykuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFkZWZpbmVkUHJvcHMuaGFzKGspKSB7XG4gICAgICAgICAgZGlhZ3MucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY29kZTogJ1cyMDAxJyxcbiAgICAgICAgICAgIHNldmVyaXR5OiAnd2FybmluZycsXG4gICAgICAgICAgICBtZXNzYWdlOiBgUHJvcCBcIiR7a31cIiBpcyBub3QgZGVmaW5lZCBvbiA8JHtub2RlLiR0YWd9Pi5gLFxuICAgICAgICAgICAgc3RhcnQ6IGJsay5pbm5lclN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBibGsuaW5uZXJFbmRcbiAgICAgICAgICB9LCB0b0xpbmVDb2woYmxrLmlubmVyU3RhcnQpKSwge1xuICAgICAgICAgICAgc25pcHBldDogYmxrLnNvdXJjZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gKF9hID0gY29tcC5wcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2tdO1xuICAgICAgICAgICAgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHNjaGVtYS52YWxpZGF0ZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkaWFncy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIGNvZGU6ICdFMTIwMycsXG4gICAgICAgICAgICAgIHNldmVyaXR5OiAnZXJyb3InLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBgUHJvcCBcIiR7a31cIiBvbiA8JHtub2RlLiR0YWd9PiBmYWlsZWQgc2NoZW1hIHZhbGlkYXRpb246IFxcblxcbiR7ZS5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgIHN0YXJ0OiBibGsuaW5uZXJTdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBibGsuaW5uZXJFbmRcbiAgICAgICAgICAgIH0sIHRvTGluZUNvbChibGsuaW5uZXJTdGFydCkpLCB7XG4gICAgICAgICAgICAgIHNuaXBwZXQ6IGJsay5zb3VyY2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwb2xpY3kgPSBjb21wLmNoaWxkcmVuO1xuICAgIGNvbnN0IGFycmF5Q2hpbGRyZW4gPSBBcnJheS5pc0FycmF5KG5vZGUuJGNoaWxkcmVuKSA/IG5vZGUuJGNoaWxkcmVuIDogW107XG4gICAgaWYgKHBvbGljeSA9PT0gJ3RleHQnKSB7XG4gICAgICAvLyBUZXh0LW9ubHkgY29tcG9uZW50czogYW55IGVsZW1lbnQgY2hpbGQgaXMgbm90IGFsbG93ZWRcbiAgICAgIGNvbnN0IGhhc0VsZW1lbnRDaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkobm9kZS4kZWxlbWVudENoaWxkcmVuKSA/IG5vZGUuJGVsZW1lbnRDaGlsZHJlbi5sZW5ndGggPiAwIDogYXJyYXlDaGlsZHJlbi5sZW5ndGggPiAwO1xuICAgICAgaWYgKGhhc0VsZW1lbnRDaGlsZHJlbikge1xuICAgICAgICBkaWFncy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY29kZTogJ1cyMTAxJyxcbiAgICAgICAgICBzZXZlcml0eTogJ3dhcm5pbmcnLFxuICAgICAgICAgIG1lc3NhZ2U6IGA8JHtub2RlLiR0YWd9PiBleHBlY3RzIHRleHQgY2hpbGRyZW4sIGVsZW1lbnQgZm91bmQuYCxcbiAgICAgICAgICBzdGFydDogYmxrLmlubmVyU3RhcnQsXG4gICAgICAgICAgZW5kOiBibGsuaW5uZXJFbmRcbiAgICAgICAgfSwgdG9MaW5lQ29sKGJsay5pbm5lclN0YXJ0KSksIHtcbiAgICAgICAgICBzbmlwcGV0OiBibGsuc291cmNlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIC8vIG5vIHJlY3Vyc2lvbiBmb3IgdGV4dCBjaGlsZHJlblxuICAgICAgcmV0dXJuIGRpYWdzO1xuICAgIH1cbiAgICBpZiAocG9saWN5ID09PSBmYWxzZSAmJiBhcnJheUNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgZGlhZ3MucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjb2RlOiAnVzIxMDEnLFxuICAgICAgICBzZXZlcml0eTogJ3dhcm5pbmcnLFxuICAgICAgICBtZXNzYWdlOiBgPCR7bm9kZS4kdGFnfT4gZG9lcyBub3QgYWNjZXB0IGNoaWxkcmVuLmAsXG4gICAgICAgIHN0YXJ0OiBibGsuaW5uZXJTdGFydCxcbiAgICAgICAgZW5kOiBibGsuaW5uZXJFbmRcbiAgICAgIH0sIHRvTGluZUNvbChibGsuaW5uZXJTdGFydCkpLCB7XG4gICAgICAgIHNuaXBwZXQ6IGJsay5zb3VyY2VcbiAgICAgIH0pKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocG9saWN5KSAmJiBhcnJheUNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgY29uc3QgYWxsb3dlZCA9IG5ldyBTZXQocG9saWN5Lm1hcChwID0+IHAubmFtZSkpO1xuICAgICAgYXJyYXlDaGlsZHJlbi5mb3JFYWNoKGNoID0+IHtcbiAgICAgICAgaWYgKCFhbGxvd2VkLmhhcyhjaC4kdGFnKSkge1xuICAgICAgICAgIGRpYWdzLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNvZGU6ICdXMjEwMScsXG4gICAgICAgICAgICBzZXZlcml0eTogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgbWVzc2FnZTogYDwke25vZGUuJHRhZ30+IGNoaWxkcmVuIHJlc3RyaWN0ZWQ7IFwiJHtjaC4kdGFnfVwiIG5vdCBhbGxvd2VkLmAsXG4gICAgICAgICAgICBzdGFydDogYmxrLmlubmVyU3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGJsay5pbm5lckVuZFxuICAgICAgICAgIH0sIHRvTGluZUNvbChibGsuaW5uZXJTdGFydCkpLCB7XG4gICAgICAgICAgICBzbmlwcGV0OiBibGsuc291cmNlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGREaWFncyA9IGFycmF5Q2hpbGRyZW4uZmxhdE1hcChjID0+IHZpc2l0KGMsIGJsaykpO1xuICAgIHJldHVybiBkaWFncy5jb25jYXQoY2hpbGREaWFncyk7XG4gIH07XG4gIHJldHVybiBleGFtcGxlcy5mbGF0TWFwKCh0cmVlLCBpZHgpID0+IHRyZWUuZmxhdE1hcChuID0+IGJsb2Nrc1tpZHhdID8gdmlzaXQobiwgYmxvY2tzW2lkeF0pIDogW10pKTtcbn1cbi8qKiBSZXBsYWNlIDx1aT4gYmxvY2tzIHdpdGggaW5saW5lIEpTT04gZmVuY2VzIG9yIHBsYWNlaG9sZGVycy4gKi9cbmZ1bmN0aW9uIGluamVjdEV4YW1wbGVzKHRleHQsIGJsb2NrcywgZXhhbXBsZXMsIG1vZGUpIHtcbiAgaWYgKG1vZGUgPT09ICdub25lJykgcmV0dXJuIHRleHQ7XG4gIGNvbnN0IHBhcnRzID0gYmxvY2tzLnJlZHVjZSgoYWNjLCBibGssIGkpID0+IHtcbiAgICBjb25zdCBwcmUgPSB0ZXh0LnNsaWNlKGFjYy5jdXJzb3IsIGJsay5zdGFydCk7XG4gICAgY29uc3QgbWlkID0gbW9kZSA9PT0gJ2lubGluZScgPyBgXFxuXFxuJHtKU09OLnN0cmluZ2lmeShleGFtcGxlc1tpXSwgbnVsbCwgMil9XFxuXFxuYCA6IGBbU2VlIGNvbXBpbGVkIFVJIGV4YW1wbGUgJHtTdHJpbmcuZnJvbUNoYXJDb2RlKCdBJy5jaGFyQ29kZUF0KDApICsgaSl9XWA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnNvcjogYmxrLmVuZCxcbiAgICAgIG91dDogYWNjLm91dCArIHByZSArIG1pZFxuICAgIH07XG4gIH0sIHtcbiAgICBjdXJzb3I6IDAsXG4gICAgb3V0OiAnJ1xuICB9KTtcbiAgcmV0dXJuIHBhcnRzLm91dCArIHRleHQuc2xpY2UocGFydHMuY3Vyc29yKTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwcm9tcHQoc3RyaW5ncywgLi4uZXhwcnMpIHtcbiAgY29uc3Qge1xuICAgIHRleHQsXG4gICAgcGxhY2Vob2xkZXJzXG4gIH0gPSB3ZWF2ZVBsYWNlaG9sZGVycyhzdHJpbmdzLCBleHBycyk7XG4gIGNvbnN0IGV4cHJzQnlUb2tlbiA9IG5ldyBNYXAocGxhY2Vob2xkZXJzLm1hcCgocCwgaSkgPT4gW3AsIGV4cHJzW2ldXSkpO1xuICBjb25zdCBibG9ja3MgPSBmaW5kVWlCbG9ja3ModGV4dCk7XG4gIGNvbnN0IHBhcnNlZCA9IGJsb2Nrcy5tYXAoYiA9PiBwYXJzZVVpKGIuc291cmNlLCBiLmlubmVyU3RhcnQpKTtcbiAgY29uc3QgYXN0QmxvY2tzID0gcGFyc2VkLm1hcChwID0+IHAubm9kZXMpO1xuICBjb25zdCBwYXJzZURpYWdub3N0aWNzID0gcGFyc2VkLmZsYXRNYXAocCA9PiBwLmRpYWdub3N0aWNzKS5tYXAoZCA9PiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGQpLCBhYnNvbHV0ZVRvTGluZUNvbCh0ZXh0LCBkLnN0YXJ0KSkpO1xuICBjb25zdCBsb3dlcmVkID0gYXN0QmxvY2tzLm1hcChhc3QgPT4gYXN0Lm1hcChuID0+IGxvd2VyVG9IQihuLCBleHByc0J5VG9rZW4pKSk7XG4gIGNvbnN0IGxvd2VyZWRUcmVlcyA9IGxvd2VyZWQubWFwKG5vZGVzID0+IG5vZGVzLm1hcChyID0+IHIuaGIpLmZpbHRlcih4ID0+IHggIT0gbnVsbCkpO1xuICBjb25zdCBsb3dlckRpYWdub3N0aWNzID0gbG93ZXJlZC5mbGF0TWFwKG5vZGVzID0+IG5vZGVzLmZsYXRNYXAociA9PiByLmRpYWdub3N0aWNzKSkubWFwKGQgPT4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkKSwgYWJzb2x1dGVUb0xpbmVDb2wodGV4dCwgZC5zdGFydCkpKTtcbiAgbGV0IGRpYWdub3N0aWNzID0gcGFyc2VEaWFnbm9zdGljcy5jb25jYXQobG93ZXJEaWFnbm9zdGljcyk7XG4gIGZ1bmN0aW9uIGNvbXBpbGUoY29tcG9uZW50cywgc2NoZW1hKSB7XG4gICAgLy8gQnVpbGQgY29tcG9uZW50IGxvb2t1cCBieSBuYW1lIGFuZCBzZWxlY3RvciBmb3IgcG9saWN5LWF3YXJlIGxvd2VyaW5nXG4gICAgY29uc3QgYnlOYW1lID0gbmV3IE1hcCgpO1xuICAgIGNvbXBvbmVudHMuZm9yRWFjaChjID0+IHtcbiAgICAgIGlmIChjICYmIHR5cGVvZiBjLm5hbWUgPT09ICdzdHJpbmcnKSBieU5hbWUuc2V0KGMubmFtZSwgYyk7XG4gICAgICBpZiAoYyAmJiB0eXBlb2YgYy5zZWxlY3RvciA9PT0gJ3N0cmluZycpIGJ5TmFtZS5zZXQoYy5zZWxlY3RvciwgYyk7XG4gICAgfSk7XG4gICAgLy8gTG93ZXIgQVNUIHVzaW5nIHRoZSBjb21wb25lbnQgY2hpbGRyZW4gcG9saWN5IChzdXBwb3J0cyAndGV4dCcpXG4gICAgY29uc3QgcG9saWN5RXhhbXBsZXMgPSBhc3RCbG9ja3MubWFwKGFzdCA9PiBhc3QubWFwKG4gPT4gbG93ZXJXaXRoUG9saWN5KG4sIGV4cHJzQnlUb2tlbiwgYnlOYW1lKSkuZmlsdGVyKG4gPT4gbiAhPSBudWxsKSk7XG4gICAgLy8gUHJlcGFyZSBhIGNsZWFuZWQgdmVyc2lvbiBmb3IgaW5qZWN0aW9uIHdpdGhvdXQgbWV0YSBoZWxwZXIgcHJvcGVydGllc1xuICAgIGNvbnN0IGNsZWFuRm9ySW5qZWN0aW9uID0gbm9kZXMgPT4gbm9kZXMubWFwKG4gPT4ge1xuICAgICAgY29uc3QgX2EgPSBuLFxuICAgICAgICB7XG4gICAgICAgICAgJHRhZyxcbiAgICAgICAgICAkY2hpbGRyZW5cbiAgICAgICAgfSA9IF9hLFxuICAgICAgICByZXN0ID0gX19yZXN0KF9hLCBbXCIkdGFnXCIsIFwiJGNoaWxkcmVuXCJdKTtcbiAgICAgIGNvbnN0IGNsZWFuZWQgPSB7XG4gICAgICAgICR0YWdcbiAgICAgIH07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSgkY2hpbGRyZW4pKSB7XG4gICAgICAgIGNsZWFuZWQuJGNoaWxkcmVuID0gY2xlYW5Gb3JJbmplY3Rpb24oJGNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFuZWQuJGNoaWxkcmVuID0gJGNoaWxkcmVuO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBub24taW50ZXJuYWwgcHJvcHMgKGlnbm9yZSAkZWxlbWVudENoaWxkcmVuKVxuICAgICAgT2JqZWN0LmVudHJpZXMocmVzdCkuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgIGlmIChrICE9PSAnJGVsZW1lbnRDaGlsZHJlbicpIGNsZWFuZWRba10gPSB2O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xlYW5lZDtcbiAgICB9KTtcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVFeGFtcGxlcyhwb2xpY3lFeGFtcGxlcywgYmxvY2tzLCBjb21wb25lbnRzLCBvID0+IGFic29sdXRlVG9MaW5lQ29sKHRleHQsIG8pKTtcbiAgICBkaWFnbm9zdGljcyA9IHBhcnNlRGlhZ25vc3RpY3MuY29uY2F0KGxvd2VyRGlhZ25vc3RpY3MpLmNvbmNhdCh2YWxpZGF0aW9uKTtcbiAgICBjb25zdCBjbGVhbmVkID0gcG9saWN5RXhhbXBsZXMubWFwKHRyZWUgPT4gY2xlYW5Gb3JJbmplY3Rpb24odHJlZSkpO1xuICAgIC8vIElmIGFuIGV4cGxpY2l0IFVJIHNjaGVtYSBpcyBwcm92aWRlZCwgZG93bmxldmVsIGV4YW1wbGVzIGZvciBzdHJlYW1pbmdcbiAgICAvLyBqdXN0IGJlZm9yZSBlbWl0dGluZyB0aGVtIGluc2lkZSBKU09OIGZlbmNlcy5cbiAgICBjb25zdCB0b0luamVjdCA9IGNsZWFuZWQubWFwKHRyZWUgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS50b1N0cmVhbWluZyh7XG4gICAgICAgICAgdWk6IHRyZWVcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gSWYgbm8gY29tcG9uZW50cyBhcmUgcHJvdmlkZWQsIGRvIG5vdCBpbmxpbmUgSlNPTiBmZW5jZXM7IHByZXNlcnZlIGF1dGhvciB0ZXh0LlxuICAgIGNvbnN0IG1vZGUgPSBjb21wb25lbnRzLmxlbmd0aCA+IDAgPyAnaW5saW5lJyA6ICdub25lJztcbiAgICByZXR1cm4gaW5qZWN0RXhhbXBsZXModGV4dCwgYmxvY2tzLCB0b0luamVjdCwgbW9kZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21waWxlLFxuICAgIGV4YW1wbGVzOiBsb3dlcmVkVHJlZXMsXG4gICAgZ2V0IGRpYWdub3N0aWNzKCkge1xuICAgICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgIH0sXG4gICAgbWV0YToge1xuICAgICAgdWlCbG9ja3M6IGJsb2Nrcy5tYXAoYiA9PiAoe1xuICAgICAgICBzdGFydDogYi5zdGFydCxcbiAgICAgICAgZW5kOiBiLmVuZCxcbiAgICAgICAgc291cmNlOiBiLnNvdXJjZVxuICAgICAgfSkpXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aXRoIGFuIGlucHV0IHNjaGVtYS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gY2ZnIC0gVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBmdW5jdGlvbiBjb250YWluaW5nOlxuICogICAtIGBuYW1lYDogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gKiAgIC0gYGRlc2NyaXB0aW9uYDogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvblxuICogICAtIGBhcmdzYDogVGhlIGFyZ3Mgc2NoZW1hIG9mIHRoZSBmdW5jdGlvblxuICogICAtIGByZXN1bHRgOiBUaGUgcmVzdWx0IHNjaGVtYSBvZiB0aGUgZnVuY3Rpb25cbiAqICAgLSBgaGFuZGxlcmA6IFRoZSBoYW5kbGVyIG9mIHRoZSBmdW5jdGlvblxuICogQHJldHVybnMgVGhlIGZ1bmN0aW9uIHJlZmVyZW5jZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUnVudGltZUZ1bmN0aW9uSW1wbChjZmcpIHtcbiAgaWYgKCEoJ2FyZ3MnIGluIGNmZykgJiYgISgncmVzdWx0JyBpbiBjZmcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGNmZy5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IGNmZy5kZXNjcmlwdGlvbixcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIChfLCBhYm9ydFNpZ25hbCkge1xuICAgICAgICByZXR1cm4gY2ZnLmhhbmRsZXIoYWJvcnRTaWduYWwpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgaWYgKCEoJ2FyZ3MnIGluIGNmZykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogY2ZnLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogY2ZnLmRlc2NyaXB0aW9uLFxuICAgICAgcmVzdWx0OiBjZmcucmVzdWx0LFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKF8sIGFib3J0U2lnbmFsKSB7XG4gICAgICAgIHJldHVybiBjZmcuaGFuZGxlcihhYm9ydFNpZ25hbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBpZiAoISgncmVzdWx0JyBpbiBjZmcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGNmZy5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IGNmZy5kZXNjcmlwdGlvbixcbiAgICAgIGFyZ3M6IGNmZy5hcmdzLFxuICAgICAgaGFuZGxlcjogY2ZnLmhhbmRsZXJcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogY2ZnLm5hbWUsXG4gICAgZGVzY3JpcHRpb246IGNmZy5kZXNjcmlwdGlvbixcbiAgICBhcmdzOiBjZmcuYXJncyxcbiAgICByZXN1bHQ6IGNmZy5yZXN1bHQsXG4gICAgaGFuZGxlcjogY2ZnLmhhbmRsZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGF0dGFjaEZ1bmN0aW9uVG9Db250ZXh0KGNvbnRleHQsIHRyYW5zcG9ydCwgZGVmaW5pdGlvbiwgYXR0YWNoVG8sIGFib3J0U2lnbmFsKSB7XG4gIGNvbnN0IHtcbiAgICBuYW1lLFxuICAgIGFyZ3M6IGFyZ3NTY2hlbWEsXG4gICAgcmVzdWx0OiByZXN1bHRTY2hlbWEsXG4gICAgaGFuZGxlclxuICB9ID0gZGVmaW5pdGlvbjtcbiAgY29uc3QgZm5IYW5kbGUgPSBjb250ZXh0Lm5ld0FzeW5jaWZpZWRGdW5jdGlvbihuYW1lLCAoLi4uYXJncykgPT4ge1xuICAgIGlmIChhcmdzU2NoZW1hID09PSB1bmRlZmluZWQgJiYgcmVzdWx0U2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyKG51bGwsIGFib3J0U2lnbmFsKS50aGVuKCgpID0+IGNvbnRleHQudW5kZWZpbmVkKTtcbiAgICB9XG4gICAgaWYgKGFyZ3NTY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIobnVsbCwgYWJvcnRTaWduYWwpLnRoZW4ocmVzdWx0ID0+IHRyYW5zcG9ydC5zZW5kT2JqZWN0KHJlc3VsdCkpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0U2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IHRyYW5zcG9ydC5yZWNlaXZlT2JqZWN0KGFyZ3NbMF0pO1xuICAgICAgcmV0dXJuIGhhbmRsZXIocmVzb2x2ZWRBcmdzLCBhYm9ydFNpZ25hbCkudGhlbigoKSA9PiBjb250ZXh0LnVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IHRyYW5zcG9ydC5yZWNlaXZlT2JqZWN0KGFyZ3NbMF0pO1xuICAgIHJldHVybiBoYW5kbGVyKHJlc29sdmVkQXJncywgYWJvcnRTaWduYWwpLnRoZW4ocmVzdWx0ID0+IHRyYW5zcG9ydC5zZW5kT2JqZWN0KHJlc3VsdCkpO1xuICB9KTtcbiAgY29udGV4dC5zZXRQcm9wKGF0dGFjaFRvLCBuYW1lLCBmbkhhbmRsZSk7XG4gIHJldHVybiBmbkhhbmRsZTtcbn1cblxuY2xhc3MgUnVudGltZVRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGNvbnN0IGpzb25SZXN1bHQgPSBjb250ZXh0LmdldFByb3AoY29udGV4dC5nbG9iYWwsICdKU09OJyk7XG4gICAgY29uc3Qgc3RyaW5naWZ5UmVzdWx0ID0gY29udGV4dC5nZXRQcm9wKGpzb25SZXN1bHQsICdzdHJpbmdpZnknKTtcbiAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGNvbnRleHQuZ2V0UHJvcChqc29uUmVzdWx0LCAncGFyc2UnKTtcbiAgICB0aGlzLmpzb25IYW5kbGUgPSBqc29uUmVzdWx0O1xuICAgIHRoaXMuc3RyaW5naWZ5SGFuZGxlID0gc3RyaW5naWZ5UmVzdWx0O1xuICAgIHRoaXMucGFyc2VIYW5kbGUgPSBwYXJzZVJlc3VsdDtcbiAgfVxuICBzZW5kT2JqZWN0KG9iamVjdCkge1xuICAgIGNvbnN0IGFzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqZWN0KTtcbiAgICBjb25zdCBzdHJpbmdIYW5kbGUgPSB0aGlzLmNvbnRleHQubmV3U3RyaW5nKGFzU3RyaW5nKTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNvbnRleHQuY2FsbEZ1bmN0aW9uKHRoaXMucGFyc2VIYW5kbGUsIHRoaXMuanNvbkhhbmRsZSwgc3RyaW5nSGFuZGxlKTtcbiAgICBzdHJpbmdIYW5kbGUuZGlzcG9zZSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc2VuZEVycm9yKG5hbWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0Lm5ld0Vycm9yKHtcbiAgICAgIG5hbWUsXG4gICAgICBtZXNzYWdlXG4gICAgfSk7XG4gIH1cbiAgcmVjZWl2ZU9iamVjdChoYW5kbGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNvbnRleHQuY2FsbEZ1bmN0aW9uKHRoaXMuc3RyaW5naWZ5SGFuZGxlLCB0aGlzLmpzb25IYW5kbGUsIGhhbmRsZSk7XG4gICAgY29uc3Qgc3RyaW5nSGFuZGxlID0gcmVzdWx0LnVud3JhcCgpO1xuICAgIGNvbnN0IGFzU3RyaW5nID0gdGhpcy5jb250ZXh0LmdldFN0cmluZyhzdHJpbmdIYW5kbGUpO1xuICAgIHN0cmluZ0hhbmRsZS5kaXNwb3NlKCk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoYXNTdHJpbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxEYXRlVGltZUZvcm1hdChjdHgpIHtcbiAgY29uc3QgZm9ybWF0SGFuZGxlID0gY3R4Lm5ld0Z1bmN0aW9uKCdmb3JtYXQnLCAoZGF0ZUhhbmRsZSwgbG9jYWxlSGFuZGxlLCBvcHRpb25zSGFuZGxlKSA9PiB7XG4gICAgY29uc3QgZGF0ZSA9IGN0eC5kdW1wKGRhdGVIYW5kbGUpO1xuICAgIGNvbnN0IGxvY2FsZSA9IGN0eC5kdW1wKGxvY2FsZUhhbmRsZSk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGN0eC5kdW1wKG9wdGlvbnNIYW5kbGUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG5ldyBEYXRlKGRhdGUpKTtcbiAgICByZXR1cm4gY3R4Lm5ld1N0cmluZyhyZXN1bHQpO1xuICB9KTtcbiAgY3R4LnNldFByb3AoY3R4Lmdsb2JhbCwgJ19faGJfX0ludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0JywgZm9ybWF0SGFuZGxlKTtcbiAgY3R4LmV2YWxDb2RlKGBcbiAgICBjbGFzcyBEYXRlVGltZUZvcm1hdCB7XG4gICAgICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGZvcm1hdChkYXRlKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzW1wiX19oYl9fSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRcIl0uY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgdGhpcy5sb2NhbGUsXG4gICAgICAgICAgdGhpcy5vcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2xvYmFsVGhpcy5JbnRsLkRhdGVUaW1lRm9ybWF0ID0gRGF0ZVRpbWVGb3JtYXQ7XG4gIGApO1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsSW50bChjdHgpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBJbnRsSGFuZGxlID0gY3R4Lm5ld09iamVjdCgpO1xuICAgIGN0eC5zZXRQcm9wKGN0eC5nbG9iYWwsICdJbnRsJywgSW50bEhhbmRsZSk7XG4gICAgaW5zdGFsbERhdGVUaW1lRm9ybWF0KGN0eCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcnVudGltZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgcnVudGltZSBjb250YWluaW5nOlxuICogICAtIGB0aW1lb3V0YDogVGhlIHRpbWVvdXQgZm9yIHRoZSBydW50aW1lXG4gKiAgIC0gYGZ1bmN0aW9uc2A6IFRoZSBmdW5jdGlvbnMgdGhhdCBhcmUgYXZhaWxhYmxlIGluIHRoZSBydW50aW1lXG4gKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgcnVudGltZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUnVudGltZUltcGwob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgdGltZW91dCA9IDEwMDAsXG4gICAgZnVuY3Rpb25zXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IGZ1bmN0aW9ucy5tYXAoZm4gPT4ge1xuICAgIGNvbnN0IGFyZ3NXaXRoVHlwZSA9IGZuLmFyZ3MgPyBgYXJnczogJHtmbi5hcmdzLnRvVHlwZVNjcmlwdCgpfWAgOiAnJztcbiAgICBjb25zdCByZXR1cm5UeXBlID0gZm4ucmVzdWx0ID8gZm4ucmVzdWx0LnRvVHlwZVNjcmlwdCgpIDogJ3ZvaWQnO1xuICAgIHJldHVybiBbYCMjIyAke2ZuLm5hbWV9YCwgZm4uZGVzY3JpcHRpb24sICcnLCBgKipUeXBlIFNpZ25hdHVyZToqKmAsIGBcXGBcXGBcXGB0eXBlc2NyaXB0YCwgYCR7Zm4ubmFtZX0oJHthcmdzV2l0aFR5cGV9KTogJHtyZXR1cm5UeXBlfWAsIGBcXGBcXGBcXGBgXS5qb2luKCdcXG4nKTtcbiAgfSkuam9pbignXFxuXFxuJyk7XG4gIHJldHVybiB7XG4gICAgZnVuY3Rpb25zLFxuICAgIHRpbWVvdXQsXG4gICAgZGVzY3JpYmUoKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfSxcbiAgICBydW4oY29kZSwgYWJvcnRTaWduYWwpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0U2lnbmFsID8gQWJvcnRTaWduYWwuYW55KFthYm9ydFNpZ25hbCwgQWJvcnRTaWduYWwudGltZW91dCh0aW1lb3V0KV0pIDogQWJvcnRTaWduYWwudGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgW3tcbiAgICAgICAgICBuZXdRdWlja0pTQXN5bmNXQVNNTW9kdWxlRnJvbVZhcmlhbnRcbiAgICAgICAgfSwgdmFyaWFudF0gPSB5aWVsZCBQcm9taXNlLmFsbChbaW1wb3J0KCcuL2luZGV4LmVzbTQuanMnKSwgaW1wb3J0KCcuL2luZGV4LmVzbTIuanMnKS50aGVuKG0gPT4gbS5kZWZhdWx0KV0pO1xuICAgICAgICBjb25zdCBRdWlja0pTID0geWllbGQgbmV3UXVpY2tKU0FzeW5jV0FTTU1vZHVsZUZyb21WYXJpYW50KHZhcmlhbnQpO1xuICAgICAgICBjb25zdCBydW50aW1lID0gUXVpY2tKUy5uZXdSdW50aW1lKHtcbiAgICAgICAgICBpbnRlcnJ1cHRIYW5kbGVyOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmFsLmFib3J0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgdm0gPSBydW50aW1lLm5ld0NvbnRleHQoKTtcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFJ1bnRpbWVUcmFuc3BvcnQodm0pO1xuICAgICAgICBpbnN0YWxsSW50bCh2bSk7XG4gICAgICAgIG9wdGlvbnMuZnVuY3Rpb25zLmZvckVhY2goZm4gPT4ge1xuICAgICAgICAgIGF0dGFjaEZ1bmN0aW9uVG9Db250ZXh0KHZtLCB0cmFuc3BvcnQsIGZuLCB2bS5nbG9iYWwsIHNpZ25hbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB2bS5ldmFsQ29kZUFzeW5jKGNvZGUpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBlcnJvcjogdm0uZHVtcChyZXN1bHQuZXJyb3IpXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXN1bHQuZXJyb3IuZGlzcG9zZSgpO1xuICAgICAgICAgIHZtLmRpc3Bvc2UoKTtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICByZXN1bHQ6IHZtLmR1bXAocmVzdWx0LnZhbHVlKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVzdWx0LnZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgICB2bS5kaXNwb3NlKCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogRmxhdHRlbnMgYSBjb21wb25lbnQgaGllcmFyY2h5IGludG8gYSBtYXAgb2YgY29tcG9uZW50IG5hbWVzIHRvIHRoZWlyIGRlZmluaXRpb25zLlxuICogVGhpcyBpbmNsdWRlcyBuZXN0ZWQgY29tcG9uZW50cyBkZWZpbmVkIGluIHRoZSBjaGlsZHJlbiBwcm9wZXJ0eS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5Db21wb25lbnRzKGNvbXBvbmVudHMpIHtcbiAgY29uc3QgY29tcG9uZW50TWFwID0gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudE1hcC5zZXQoY29tcG9uZW50Lm5hbWUsIGNvbXBvbmVudCk7XG4gICAgaWYgKGNvbXBvbmVudC5jaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5jaGlsZHJlbikpIHtcbiAgICAgIGNvbXBvbmVudC5jaGlsZHJlbi5mb3JFYWNoKHByb2Nlc3NDb21wb25lbnQpO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRzLmZvckVhY2gocHJvY2Vzc0NvbXBvbmVudCk7XG4gIHJldHVybiBjb21wb25lbnRNYXA7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBzY2hlbWEgZm9yIGEgbGlzdCBvZiBleHBvc2VkIGNvbXBvbmVudHMsIGFsbG93aW5nIGZvciB0aGUgZGVmaW5pdGlvblxuICogb2YgY29tcG9uZW50IHN0cnVjdHVyZXMgYW5kIHRoZWlyIHJlbGF0aW9uc2hpcHMuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIGNvbXBvbmVudHMgLSBBbiBhcnJheSBvZiBjb21wb25lbnRzIHRvIGNyZWF0ZSBzY2hlbWFzIGZvci5cbiAqIEByZXR1cm5zIEEgc2NoZW1hIHJlcHJlc2VudGluZyB0aGUgc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRTY2hlbWEoY29tcG9uZW50cykge1xuICBjb25zdCB3ZWFrTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgZWxlbWVudHMgPSBhbnlPZihjb21wb25lbnRzLm1hcChjb21wb25lbnQgPT4gY3JlYXRlU2NoZW1hKGNvbXBvbmVudCkpKTtcbiAgZnVuY3Rpb24gY3JlYXRlU2NoZW1hKGNvbXBvbmVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBpZiAod2Vha01hcC5oYXMoY29tcG9uZW50LmNvbXBvbmVudCkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICByZXR1cm4gd2Vha01hcC5nZXQoY29tcG9uZW50LmNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gY29tcG9uZW50LmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gJ2FueScpIHtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IG9iamVjdCQxKGNvbXBvbmVudC5kZXNjcmlwdGlvbiwge1xuICAgICAgICAkdGFnOiBsaXRlcmFsKGNvbXBvbmVudC5uYW1lKSxcbiAgICAgICAgJHByb3BzOiBvYmplY3QkMSgnQ29tcG9uZW50IFByb3BzJywgKF9hID0gY29tcG9uZW50LnByb3BzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSksXG4gICAgICAgIGdldCAkY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5KCdDaGlsZCBFbGVtZW50cycsIGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3ZWFrTWFwLnNldChjb21wb25lbnQuY29tcG9uZW50LCBzY2hlbWEpO1xuICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkcmVuID09PSAndGV4dCcpIHtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IG9iamVjdCQxKGNvbXBvbmVudC5kZXNjcmlwdGlvbiwge1xuICAgICAgICAkdGFnOiBsaXRlcmFsKGNvbXBvbmVudC5uYW1lKSxcbiAgICAgICAgJHByb3BzOiBvYmplY3QkMSgnQ29tcG9uZW50IFByb3BzJywgKF9iID0gY29tcG9uZW50LnByb3BzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSksXG4gICAgICAgICRjaGlsZHJlbjogc3RyaW5nKCdDb250ZW50JylcbiAgICAgIH0pO1xuICAgICAgd2Vha01hcC5zZXQoY29tcG9uZW50LmNvbXBvbmVudCwgc2NoZW1hKTtcbiAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfSBlbHNlIGlmIChjaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgY29uc3Qgc2NoZW1hID0gb2JqZWN0JDEoY29tcG9uZW50LmRlc2NyaXB0aW9uLCB7XG4gICAgICAgICR0YWc6IGxpdGVyYWwoY29tcG9uZW50Lm5hbWUpLFxuICAgICAgICAkcHJvcHM6IG9iamVjdCQxKCdDb21wb25lbnQgUHJvcHMnLCAoX2MgPSBjb21wb25lbnQucHJvcHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9KSxcbiAgICAgICAgZ2V0ICRjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkoJ0NoaWxkIEVsZW1lbnRzJywgYW55T2YoY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNyZWF0ZVNjaGVtYShjaGlsZCkpKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2Vha01hcC5zZXQoY29tcG9uZW50LmNvbXBvbmVudCwgc2NoZW1hKTtcbiAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IG9iamVjdCQxKGNvbXBvbmVudC5kZXNjcmlwdGlvbiwge1xuICAgICAgICAkdGFnOiBsaXRlcmFsKGNvbXBvbmVudC5uYW1lKSxcbiAgICAgICAgJHByb3BzOiBvYmplY3QkMSgnQ29tcG9uZW50IFByb3BzJywgKF9kID0gY29tcG9uZW50LnByb3BzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB7fSlcbiAgICAgIH0pO1xuICAgICAgd2Vha01hcC5zZXQoY29tcG9uZW50LmNvbXBvbmVudCwgc2NoZW1hKTtcbiAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVtZW50cztcbn1cblxudmFyIGluZGV4ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjcmVhdGVDb21wb25lbnRTY2hlbWE6IGNyZWF0ZUNvbXBvbmVudFNjaGVtYSxcbiAgICBmbGF0dGVuQ29tcG9uZW50czogZmxhdHRlbkNvbXBvbmVudHNcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIERlZXAgc3RydWN0dXJhbCBjb21wYXJpc29uIHRoYXQgXCJqdXN0IHdvcmtzXCIgb24gcHJpbWl0aXZlcyB0b28uXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiLCBzZWVuID0gbmV3IFdlYWtNYXAoKSkge1xuICAvLyAxLiBGYXN04oCRcGF0aCBmb3Igc3RyaWN0IGVxdWFsaXR5IOKAkyBjYXRjaGVzIG1vc3QgcHJpbWl0aXZlcyAmIGlkZW50aWNhbCByZWZlcmVuY2VzLlxuICBpZiAoYSA9PT0gYikge1xuICAgIC8vIERpc3Rpbmd1aXNoICswIGFuZCDigJMwIChKUyB0cmVhdHMgdGhlbSBhcyBlcXVhbCBidXQgc3BlYyBzYXlzIHRoZXnigJlyZSBub3Qg4oCcU2FtZVZhbHVl4oCdKVxuICAgIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgfVxuICAvLyAyLiBIYW5kbGUgdGhlIG9uZSBwcmltaXRpdmUgcGFpciB0aGF0IGZhaWxzIGA9PT1gOiBOYU5cbiAgaWYgKE51bWJlci5pc05hTihhKSAmJiBOdW1iZXIuaXNOYU4oYikpIHJldHVybiB0cnVlO1xuICAvLyAzLiBJZiB0eXBlcyBkaWZmZXIgKGFuZCBuZWl0aGVyIGlzIG51bGwvdW5kZWZpbmVkKSwgd2XigJlyZSBhbHJlYWR5IHVuZXF1YWwuXG4gIGNvbnN0IHRhID0gdHlwZW9mIGEsXG4gICAgdGIgPSB0eXBlb2YgYjtcbiAgaWYgKHRhICE9PSB0YikgcmV0dXJuIGZhbHNlO1xuICBpZiAodGEgIT09ICdvYmplY3QnICYmIHRhICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7IC8vIGFsbCByZW1haW5pbmcgcHJpbWl0aXZlcyBoYW5kbGVkIGFib3ZlXG4gIC8vIDQuIE51bGwgaXMgYG9iamVjdGAgaW4gSlMgYnV0IGNhbuKAmXQgYmUgZXF1YWwgdG8gYW55dGhpbmcgcmVhY2hlZCBoZXJlLlxuICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIC8vIDUuIFByb3RlY3QgYWdhaW5zdCBjeWNsZXMgKEHihpRCLCBldGMuKVxuICBpZiAoc2Vlbi5nZXQoYSkgPT09IGIpIHJldHVybiB0cnVlO1xuICBzZWVuLnNldChhLCBiKTtcbiAgLyoqIEhlbHBlciB1c2VkIGJlbG93ICovXG4gIGNvbnN0IGVxID0gKHgsIHkpID0+IGRlZXBFcXVhbCh4LCB5LCBzZWVuKTtcbiAgLy8gPT09PT09PT09PSBCdWlsdOKAkWlucyB3aXRoIGJlc3Bva2Ugc2VtYW50aWNzID09PT09PT09PT1cbiAgaWYgKGEgaW5zdGFuY2VvZiBEYXRlIHx8IGIgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUgJiYgYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xuICBpZiAoYSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBiIGluc3RhbmNlb2YgUmVnRXhwKSByZXR1cm4gYSBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBiIGluc3RhbmNlb2YgUmVnRXhwICYmIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpIHx8IEFycmF5QnVmZmVyLmlzVmlldyhiKSkge1xuICAgIGlmICghKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcoYikpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gRGF0YVZpZXcgY292ZXJzIGV2ZXJ5IFR5cGVkQXJyYXkgYmVoaW5kIHRoZSBzY2VuZXNcbiAgICBjb25zdCBkdkEgPSBuZXcgRGF0YVZpZXcoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCk7XG4gICAgY29uc3QgZHZCID0gbmV3IERhdGFWaWV3KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHZBLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGR2QS5nZXRVaW50OChpKSAhPT0gZHZCLmdldFVpbnQ4KGkpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGIpIHx8IGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykgaWYgKCFlcShhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhIGluc3RhbmNlb2YgU2V0IHx8IGIgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICBpZiAoIShhIGluc3RhbmNlb2YgU2V0ICYmIGIgaW5zdGFuY2VvZiBTZXQpIHx8IGEuc2l6ZSAhPT0gYi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgb3V0ZXI6IGZvciAoY29uc3QgdmEgb2YgYSkge1xuICAgICAgZm9yIChjb25zdCB2YiBvZiBiKSBpZiAoZXEodmEsIHZiKSkgY29udGludWUgb3V0ZXI7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIG5vIG1hdGNoIGZvdW5kXG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhIGluc3RhbmNlb2YgTWFwIHx8IGIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICBpZiAoIShhIGluc3RhbmNlb2YgTWFwICYmIGIgaW5zdGFuY2VvZiBNYXApIHx8IGEuc2l6ZSAhPT0gYi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgb3V0ZXI6IGZvciAoY29uc3QgW2thLCB2YV0gb2YgYSkge1xuICAgICAgZm9yIChjb25zdCBba2IsIHZiXSBvZiBiKSB7XG4gICAgICAgIGlmIChlcShrYSwga2IpICYmIGVxKHZhLCB2YikpIGNvbnRpbnVlIG91dGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyA9PT09PT09PT09IFBsYWluIG9iamVjdHMgKyBjbGFzcyBpbnN0YW5jZXMgKHByb3RvdHlwZSBkb2VzbuKAmXQgbWF0dGVyKSA9PT09PT09PT09XG4gIGNvbnN0IGtleXNBID0gUmVmbGVjdC5vd25LZXlzKGEpO1xuICBjb25zdCBrZXlzQiA9IFJlZmxlY3Qub3duS2V5cyhiKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGZvciAoY29uc3QgayBvZiBrZXlzQSkge1xuICAgIGlmICgha2V5c0IuaW5jbHVkZXMoaykgfHwgIWVxKGFba10sIGJba10pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciB0eXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG5leHBvcnQgeyBwdWJsaWNfYXBpIGFzIENoYXQsIGRlY29kZUZyYW1lcywgZW5jb2RlRnJhbWUsIGZyeUhhc2hicm93biwgcHJvbXB0LCBwdWJsaWNfYXBpJDEgYXMgcywgY3JlYXRlUnVudGltZUZ1bmN0aW9uSW1wbCBhcyDJtWNyZWF0ZVJ1bnRpbWVGdW5jdGlvbkltcGwsIGNyZWF0ZVJ1bnRpbWVJbXBsIGFzIMm1Y3JlYXRlUnVudGltZUltcGwsIGRlZXBFcXVhbCBhcyDJtWRlZXBFcXVhbCwgdHlwZXMgYXMgybV0eXBlcywgaW5kZXggYXMgybV1aSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@hashbrownai+core@0.3.0/node_modules/@hashbrownai/core/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/polyfills/process.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/polyfills/process.js ***!
  \***************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMzJfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxxQ0FBcUMscUJBQU0saUZBQWlGLHFCQUFNLGtFQUFrRSxxQkFBTSxXQUFXLG1CQUFPLENBQUMsd0xBQTRCOztBQUV6UCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjMyX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy5qcz85NGRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9nbG9iYWxfcHJvY2VzcywgX2dsb2JhbF9wcm9jZXNzMTtcbm1vZHVsZS5leHBvcnRzID0gKChfZ2xvYmFsX3Byb2Nlc3MgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2Vzcy5lbnYpICYmIHR5cGVvZiAoKF9nbG9iYWxfcHJvY2VzczEgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2VzczEuZW52KSA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbC5wcm9jZXNzIDogcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzXCIpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/process/browser.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/process/browser.js ***!
  \****************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMzJfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMi4zMl9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzP2I0ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ HomePage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_HashbrownSummary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/HashbrownSummary */ \"(app-pages-browser)/./src/components/HashbrownSummary.tsx\");\n/* harmony import */ var _lib_providers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/providers */ \"(app-pages-browser)/./src/lib/providers.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst providerEntries = Object.entries(_lib_providers__WEBPACK_IMPORTED_MODULE_3__.providerMetadata);\nfunction HomePage() {\n    _s();\n    const [provider, setProvider] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"openai\");\n    const [prompt, setPrompt] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Give me a one sentence update proving this API key is active right now.\");\n    const [result, setResult] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const providerLabel = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>_lib_providers__WEBPACK_IMPORTED_MODULE_3__.providerMetadata[provider].label, [\n        provider\n    ]);\n    async function handleSubmit(event) {\n        event.preventDefault();\n        setIsLoading(true);\n        setError(null);\n        try {\n            const response = await fetch(\"/api/check\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    provider,\n                    prompt\n                })\n            });\n            const json = await response.json();\n            if (!response.ok || !json.success) {\n                const message = json.success ? \"Request failed with status \".concat(response.status) : json.error;\n                setError(message);\n                setResult(null);\n                return;\n            }\n            setResult(json);\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Unexpected error while reaching server\");\n            setResult(null);\n        } finally{\n            setIsLoading(false);\n        }\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"mx-auto flex min-h-screen max-w-5xl flex-col gap-12 px-6 py-10\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                className: \"flex flex-col gap-4 text-balance text-center sm:text-left\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-4xl font-semibold tracking-tight text-white\",\n                        children: \"Tea Olive\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                        lineNumber: 59,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-base text-white/70\",\n                        children: \"Run a quick prompt against OpenAI, Claude, or Gemini to confirm their API keys still work. Inspect the raw payloads like you would in Postman, then let Hashbrown craft a friendly summary for you.\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                        lineNumber: 60,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                lineNumber: 58,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"flex flex-col gap-6 rounded-3xl border border-white/10 bg-slate-950/70 p-8 shadow-xl ring-1 ring-white/5\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                        className: \"flex flex-col gap-6\",\n                        onSubmit: handleSubmit,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"grid gap-4 sm:grid-cols-[200px_1fr] sm:items-center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        className: \"text-sm font-medium text-white/80\",\n                                        htmlFor: \"service\",\n                                        children: \"Service\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                        lineNumber: 70,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                        id: \"service\",\n                                        value: provider,\n                                        onChange: (event)=>setProvider(event.target.value),\n                                        className: \"w-full rounded-lg border border-white/10 bg-slate-900/80 px-3 py-2 text-sm text-white focus:border-brand focus:outline-none focus:ring-2 focus:ring-brand\",\n                                        children: providerEntries.map((param)=>{\n                                            let [id, meta] = param;\n                                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                value: id,\n                                                children: meta.label\n                                            }, id, false, {\n                                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                                lineNumber: 80,\n                                                columnNumber: 17\n                                            }, this);\n                                        })\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                        lineNumber: 73,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                lineNumber: 69,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"grid gap-3\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        className: \"text-sm font-medium text-white/80\",\n                                        htmlFor: \"prompt\",\n                                        children: \"Prompt\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                        lineNumber: 88,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                                        id: \"prompt\",\n                                        value: prompt,\n                                        onChange: (event)=>setPrompt(event.target.value),\n                                        rows: 4,\n                                        className: \"w-full rounded-lg border border-white/10 bg-slate-900/80 px-3 py-2 text-sm text-white focus:border-brand focus:outline-none focus:ring-2 focus:ring-brand\",\n                                        placeholder: \"Ask the provider to prove your API key works.\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                        lineNumber: 91,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                lineNumber: 87,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                type: \"submit\",\n                                className: \"inline-flex items-center justify-center rounded-lg bg-brand px-4 py-2 text-sm font-semibold text-white shadow-lg shadow-brand/30 transition hover:bg-brand/90 focus:outline-none focus:ring-2 focus:ring-brand focus:ring-offset-2 focus:ring-offset-slate-950 disabled:cursor-not-allowed disabled:opacity-60\",\n                                disabled: isLoading,\n                                children: isLoading ? \"Checking...\" : \"Run check\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                lineNumber: 101,\n                                columnNumber: 11\n                            }, this),\n                            error ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"rounded-lg border border-rose-500/60 bg-rose-500/10 p-4 text-sm text-rose-100\",\n                                children: error\n                            }, void 0, false, {\n                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                lineNumber: 110,\n                                columnNumber: 13\n                            }, this) : null\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                        lineNumber: 68,\n                        columnNumber: 9\n                    }, this),\n                    result ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid gap-6 lg:grid-cols-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                                className: \"flex flex-col gap-4 rounded-2xl border border-white/10 bg-slate-900/60 p-6\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                                        className: \"flex flex-col gap-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                                className: \"text-lg font-semibold text-white/90\",\n                                                children: \"Run details\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                                lineNumber: 120,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-sm text-white/60\",\n                                                children: [\n                                                    \"HTTP status \",\n                                                    result.status,\n                                                    \" - \",\n                                                    result.durationMs.toLocaleString(),\n                                                    \" ms - Model\",\n                                                    \" \",\n                                                    result.modelUsed\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                                lineNumber: 121,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                        lineNumber: 119,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"rounded-lg bg-black/40 p-4 text-sm text-white/80\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"font-medium text-white/70\",\n                                                children: \"Prompt\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                                lineNumber: 127,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"mt-1 whitespace-pre-wrap text-white/90\",\n                                                children: result.prompt\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                                lineNumber: 128,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                        lineNumber: 126,\n                                        columnNumber: 15\n                                    }, this),\n                                    result.textOutput ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"rounded-lg bg-black/40 p-4 text-sm text-white/80\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"font-medium text-white/70\",\n                                                children: \"Model output\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                                lineNumber: 132,\n                                                columnNumber: 19\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"mt-1 whitespace-pre-wrap text-white/90\",\n                                                children: result.textOutput\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                                lineNumber: 133,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                        lineNumber: 131,\n                                        columnNumber: 17\n                                    }, this) : null\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                lineNumber: 118,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                                className: \"flex flex-col gap-4 rounded-2xl border border-white/10 bg-slate-900/60 p-6\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-lg font-semibold text-white/90\",\n                                        children: \"Raw payloads\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                        lineNumber: 139,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PayloadBlock, {\n                                        label: \"Request\",\n                                        data: result.requestPayload\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                        lineNumber: 140,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PayloadBlock, {\n                                        label: \"Response\",\n                                        data: result.responsePayload\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                        lineNumber: 141,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                                lineNumber: 138,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                        lineNumber: 117,\n                        columnNumber: 11\n                    }, this) : null\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                lineNumber: 67,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_HashbrownSummary__WEBPACK_IMPORTED_MODULE_2__.HashbrownSummary, {\n                    provider: provider,\n                    providerLabel: providerLabel,\n                    result: result\n                }, void 0, false, {\n                    fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                    lineNumber: 148,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                lineNumber: 147,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n        lineNumber: 57,\n        columnNumber: 5\n    }, this);\n}\n_s(HomePage, \"/X4lDxbjRLtQSJL+JwZeyim3C9o=\");\n_c = HomePage;\nfunction PayloadBlock(param) {\n    let { label, data } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col gap-2\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"text-sm font-medium text-white/70\",\n                children: label\n            }, void 0, false, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                lineNumber: 157,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"pre\", {\n                className: \"max-h-72 overflow-auto rounded-xl bg-black/60 p-4 text-xs leading-relaxed text-emerald-200\",\n                children: safeJson(data)\n            }, void 0, false, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n                lineNumber: 158,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/app/page.tsx\",\n        lineNumber: 156,\n        columnNumber: 5\n    }, this);\n}\n_c1 = PayloadBlock;\nfunction safeJson(data) {\n    try {\n        return JSON.stringify(data, null, 2);\n    } catch (error) {\n        return \"Unable to serialise payload: \".concat(error instanceof Error ? error.message : \"unknown error\");\n    }\n}\nvar _c, _c1;\n$RefreshReg$(_c, \"HomePage\");\n$RefreshReg$(_c1, \"PayloadBlock\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFcUQ7QUFFWTtBQUNHO0FBR3BFLE1BQU1JLGtCQUFrQkMsT0FBT0MsT0FBTyxDQUFDSCw0REFBZ0JBO0FBS3hDLFNBQVNJOztJQUN0QixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1IsK0NBQVFBLENBQWE7SUFDckQsTUFBTSxDQUFDUyxRQUFRQyxVQUFVLEdBQUdWLCtDQUFRQSxDQUNsQztJQUVGLE1BQU0sQ0FBQ1csUUFBUUMsVUFBVSxHQUFHWiwrQ0FBUUEsQ0FBeUI7SUFDN0QsTUFBTSxDQUFDYSxXQUFXQyxhQUFhLEdBQUdkLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ2UsT0FBT0MsU0FBUyxHQUFHaEIsK0NBQVFBLENBQWdCO0lBRWxELE1BQU1pQixnQkFBZ0JsQiw4Q0FBT0EsQ0FBQyxJQUFNRyw0REFBZ0IsQ0FBQ0ssU0FBUyxDQUFDVyxLQUFLLEVBQUU7UUFBQ1g7S0FBUztJQUVoRixlQUFlWSxhQUFhQyxLQUFpQztRQUMzREEsTUFBTUMsY0FBYztRQUNwQlAsYUFBYTtRQUNiRSxTQUFTO1FBRVQsSUFBSTtZQUNGLE1BQU1NLFdBQVcsTUFBTUMsTUFBTSxjQUFjO2dCQUN6Q0MsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUVyQjtvQkFBVUU7Z0JBQU87WUFDMUM7WUFFQSxNQUFNb0IsT0FBUSxNQUFNUCxTQUFTTyxJQUFJO1lBQ2pDLElBQUksQ0FBQ1AsU0FBU1EsRUFBRSxJQUFJLENBQUNELEtBQUtFLE9BQU8sRUFBRTtnQkFDakMsTUFBTUMsVUFBVUgsS0FBS0UsT0FBTyxHQUFHLDhCQUE4QyxPQUFoQlQsU0FBU1csTUFBTSxJQUFLSixLQUFLZCxLQUFLO2dCQUMzRkMsU0FBU2dCO2dCQUNUcEIsVUFBVTtnQkFDVjtZQUNGO1lBRUFBLFVBQVVp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QUFlTixRQUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJcEY7R0ExSXdCTDtLQUFBQTtBQTRJeEIsU0FBUzJELGFBQWEsS0FBaUQ7UUFBakQsRUFBRS9DLEtBQUssRUFBRWdELElBQUksRUFBb0MsR0FBakQ7SUFDcEIscUJBQ0UsOERBQUN0QjtRQUFJUCxXQUFVOzswQkFDYiw4REFBQ0c7Z0JBQUVILFdBQVU7MEJBQXFDbkI7Ozs7OzswQkFDbEQsOERBQUNtRDtnQkFBSWhDLFdBQVU7MEJBQ1ppQyxTQUFTSjs7Ozs7Ozs7Ozs7O0FBSWxCO01BVFNEO0FBV1QsU0FBU0ssU0FBU0osSUFBYTtJQUM3QixJQUFJO1FBQ0YsT0FBT3ZDLEtBQUtDLFNBQVMsQ0FBQ3NDLE1BQU0sTUFBTTtJQUNwQyxFQUFFLE9BQU9uRCxPQUFPO1FBQ2QsT0FBTyxnQ0FBeUYsT0FBekRBLGlCQUFpQm9CLFFBQVFwQixNQUFNaUIsT0FBTyxHQUFHO0lBQ2xGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9wYWdlLnRzeD9mNjhhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgRm9ybUV2ZW50LCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgSGFzaGJyb3duU3VtbWFyeSB9IGZyb20gJ0AvY29tcG9uZW50cy9IYXNoYnJvd25TdW1tYXJ5JztcbmltcG9ydCB7IHByb3ZpZGVyTWV0YWRhdGEsIHR5cGUgUHJvdmlkZXJJZCB9IGZyb20gJ0AvbGliL3Byb3ZpZGVycyc7XG5pbXBvcnQgdHlwZSB7IEFwaUNoZWNrUmVzcG9uc2UsIEFwaUNoZWNrU3VjY2VzcyB9IGZyb20gJ0AvdHlwZXMvY2hlY2snO1xuXG5jb25zdCBwcm92aWRlckVudHJpZXMgPSBPYmplY3QuZW50cmllcyhwcm92aWRlck1ldGFkYXRhKSBhcyBBcnJheTxbXG4gIFByb3ZpZGVySWQsXG4gIHsgbGFiZWw6IHN0cmluZzsgZGVmYXVsdE1vZGVsOiBzdHJpbmcgfVxuXT47XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWVQYWdlKCkge1xuICBjb25zdCBbcHJvdmlkZXIsIHNldFByb3ZpZGVyXSA9IHVzZVN0YXRlPFByb3ZpZGVySWQ+KCdvcGVuYWknKTtcbiAgY29uc3QgW3Byb21wdCwgc2V0UHJvbXB0XSA9IHVzZVN0YXRlKFxuICAgICdHaXZlIG1lIGEgb25lIHNlbnRlbmNlIHVwZGF0ZSBwcm92aW5nIHRoaXMgQVBJIGtleSBpcyBhY3RpdmUgcmlnaHQgbm93LicsXG4gICk7XG4gIGNvbnN0IFtyZXN1bHQsIHNldFJlc3VsdF0gPSB1c2VTdGF0ZTxBcGlDaGVja1N1Y2Nlc3MgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBwcm92aWRlckxhYmVsID0gdXNlTWVtbygoKSA9PiBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyXS5sYWJlbCwgW3Byb3ZpZGVyXSk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlU3VibWl0KGV2ZW50OiBGb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50Pikge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hlY2snLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBwcm92aWRlciwgcHJvbXB0IH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGpzb24gPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKSBhcyBBcGlDaGVja1Jlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZS5vayB8fCAhanNvbi5zdWNjZXNzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBqc29uLnN1Y2Nlc3MgPyBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCA6IGpzb24uZXJyb3I7XG4gICAgICAgIHNldEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBzZXRSZXN1bHQobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2V0UmVzdWx0KGpzb24pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdVbmV4cGVjdGVkIGVycm9yIHdoaWxlIHJlYWNoaW5nIHNlcnZlcicpO1xuICAgICAgc2V0UmVzdWx0KG51bGwpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPG1haW4gY2xhc3NOYW1lPVwibXgtYXV0byBmbGV4IG1pbi1oLXNjcmVlbiBtYXgtdy01eGwgZmxleC1jb2wgZ2FwLTEyIHB4LTYgcHktMTBcIj5cbiAgICAgIDxoZWFkZXIgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtNCB0ZXh0LWJhbGFuY2UgdGV4dC1jZW50ZXIgc206dGV4dC1sZWZ0XCI+XG4gICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTR4bCBmb250LXNlbWlib2xkIHRyYWNraW5nLXRpZ2h0IHRleHQtd2hpdGVcIj5UZWEgT2xpdmU8L2gxPlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWJhc2UgdGV4dC13aGl0ZS83MFwiPlxuICAgICAgICAgIFJ1biBhIHF1aWNrIHByb21wdCBhZ2FpbnN0IE9wZW5BSSwgQ2xhdWRlLCBvciBHZW1pbmkgdG8gY29uZmlybSB0aGVpciBBUEkga2V5cyBzdGlsbCB3b3JrLlxuICAgICAgICAgIEluc3BlY3QgdGhlIHJhdyBwYXlsb2FkcyBsaWtlIHlvdSB3b3VsZCBpbiBQb3N0bWFuLCB0aGVuIGxldCBIYXNoYnJvd24gY3JhZnQgYSBmcmllbmRseVxuICAgICAgICAgIHN1bW1hcnkgZm9yIHlvdS5cbiAgICAgICAgPC9wPlxuICAgICAgPC9oZWFkZXI+XG5cbiAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTYgcm91bmRlZC0zeGwgYm9yZGVyIGJvcmRlci13aGl0ZS8xMCBiZy1zbGF0ZS05NTAvNzAgcC04IHNoYWRvdy14bCByaW5nLTEgcmluZy13aGl0ZS81XCI+XG4gICAgICAgIDxmb3JtIGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTZcIiBvblN1Ym1pdD17aGFuZGxlU3VibWl0fT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ2FwLTQgc206Z3JpZC1jb2xzLVsyMDBweF8xZnJdIHNtOml0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW0gdGV4dC13aGl0ZS84MFwiIGh0bWxGb3I9XCJzZXJ2aWNlXCI+XG4gICAgICAgICAgICAgIFNlcnZpY2VcbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgIGlkPVwic2VydmljZVwiXG4gICAgICAgICAgICAgIHZhbHVlPXtwcm92aWRlcn1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyhldmVudCkgPT4gc2V0UHJvdmlkZXIoZXZlbnQudGFyZ2V0LnZhbHVlIGFzIFByb3ZpZGVySWQpfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLXdoaXRlLzEwIGJnLXNsYXRlLTkwMC84MCBweC0zIHB5LTIgdGV4dC1zbSB0ZXh0LXdoaXRlIGZvY3VzOmJvcmRlci1icmFuZCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYnJhbmRcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7cHJvdmlkZXJFbnRyaWVzLm1hcCgoW2lkLCBtZXRhXSkgPT4gKFxuICAgICAgICAgICAgICAgIDxvcHRpb24ga2V5PXtpZH0gdmFsdWU9e2lkfT5cbiAgICAgICAgICAgICAgICAgIHttZXRhLmxhYmVsfVxuICAgICAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdhcC0zXCI+XG4gICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LXdoaXRlLzgwXCIgaHRtbEZvcj1cInByb21wdFwiPlxuICAgICAgICAgICAgICBQcm9tcHRcbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgaWQ9XCJwcm9tcHRcIlxuICAgICAgICAgICAgICB2YWx1ZT17cHJvbXB0fVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiBzZXRQcm9tcHQoZXZlbnQudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgcm93cz17NH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIHJvdW5kZWQtbGcgYm9yZGVyIGJvcmRlci13aGl0ZS8xMCBiZy1zbGF0ZS05MDAvODAgcHgtMyBweS0yIHRleHQtc20gdGV4dC13aGl0ZSBmb2N1czpib3JkZXItYnJhbmQgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJyYW5kXCJcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJBc2sgdGhlIHByb3ZpZGVyIHRvIHByb3ZlIHlvdXIgQVBJIGtleSB3b3Jrcy5cIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJzdWJtaXRcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJvdW5kZWQtbGcgYmctYnJhbmQgcHgtNCBweS0yIHRleHQtc20gZm9udC1zZW1pYm9sZCB0ZXh0LXdoaXRlIHNoYWRvdy1sZyBzaGFkb3ctYnJhbmQvMzAgdHJhbnNpdGlvbiBob3ZlcjpiZy1icmFuZC85MCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYnJhbmQgZm9jdXM6cmluZy1vZmZzZXQtMiBmb2N1czpyaW5nLW9mZnNldC1zbGF0ZS05NTAgZGlzYWJsZWQ6Y3Vyc29yLW5vdC1hbGxvd2VkIGRpc2FibGVkOm9wYWNpdHktNjBcIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2lzTG9hZGluZ31cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7aXNMb2FkaW5nID8gJ0NoZWNraW5nLi4uJyA6ICdSdW4gY2hlY2snfVxuICAgICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgICAge2Vycm9yID8gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3VuZGVkLWxnIGJvcmRlciBib3JkZXItcm9zZS01MDAvNjAgYmctcm9zZS01MDAvMTAgcC00IHRleHQtc20gdGV4dC1yb3NlLTEwMFwiPlxuICAgICAgICAgICAgICB7ZXJyb3J9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgPC9mb3JtPlxuXG4gICAgICAgIHtyZXN1bHQgPyAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdhcC02IGxnOmdyaWQtY29scy0yXCI+XG4gICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00IHJvdW5kZWQtMnhsIGJvcmRlciBib3JkZXItd2hpdGUvMTAgYmctc2xhdGUtOTAwLzYwIHAtNlwiPlxuICAgICAgICAgICAgICA8aGVhZGVyIGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTJcIj5cbiAgICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LXNlbWlib2xkIHRleHQtd2hpdGUvOTBcIj5SdW4gZGV0YWlsczwvaDI+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXdoaXRlLzYwXCI+XG4gICAgICAgICAgICAgICAgICBIVFRQIHN0YXR1cyB7cmVzdWx0LnN0YXR1c30gLSB7cmVzdWx0LmR1cmF0aW9uTXMudG9Mb2NhbGVTdHJpbmcoKX0gbXMgLSBNb2RlbHsnICd9XG4gICAgICAgICAgICAgICAgICB7cmVzdWx0Lm1vZGVsVXNlZH1cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIDwvaGVhZGVyPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvdW5kZWQtbGcgYmctYmxhY2svNDAgcC00IHRleHQtc20gdGV4dC13aGl0ZS84MFwiPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtIHRleHQtd2hpdGUvNzBcIj5Qcm9tcHQ8L3A+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibXQtMSB3aGl0ZXNwYWNlLXByZS13cmFwIHRleHQtd2hpdGUvOTBcIj57cmVzdWx0LnByb21wdH08L3A+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICB7cmVzdWx0LnRleHRPdXRwdXQgPyAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3VuZGVkLWxnIGJnLWJsYWNrLzQwIHAtNCB0ZXh0LXNtIHRleHQtd2hpdGUvODBcIj5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtIHRleHQtd2hpdGUvNzBcIj5Nb2RlbCBvdXRwdXQ8L3A+XG4gICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtdC0xIHdoaXRlc3BhY2UtcHJlLXdyYXAgdGV4dC13aGl0ZS85MFwiPntyZXN1bHQudGV4dE91dHB1dH08L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgICAgPC9zZWN0aW9uPlxuXG4gICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00IHJvdW5kZWQtMnhsIGJvcmRlciBib3JkZXItd2hpdGUvMTAgYmctc2xhdGUtOTAwLzYwIHAtNlwiPlxuICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LXNlbWlib2xkIHRleHQtd2hpdGUvOTBcIj5SYXcgcGF5bG9hZHM8L2gyPlxuICAgICAgICAgICAgICA8UGF5bG9hZEJsb2NrIGxhYmVsPVwiUmVxdWVzdFwiIGRhdGE9e3Jlc3VsdC5yZXF1ZXN0UGF5bG9hZH0gLz5cbiAgICAgICAgICAgICAgPFBheWxvYWRCbG9jayBsYWJlbD1cIlJlc3BvbnNlXCIgZGF0YT17cmVzdWx0LnJlc3BvbnNlUGF5bG9hZH0gLz5cbiAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSA6IG51bGx9XG4gICAgICA8L3NlY3Rpb24+XG5cbiAgICAgIDxzZWN0aW9uPlxuICAgICAgICA8SGFzaGJyb3duU3VtbWFyeSBwcm92aWRlcj17cHJvdmlkZXJ9IHByb3ZpZGVyTGFiZWw9e3Byb3ZpZGVyTGFiZWx9IHJlc3VsdD17cmVzdWx0fSAvPlxuICAgICAgPC9zZWN0aW9uPlxuICAgIDwvbWFpbj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gUGF5bG9hZEJsb2NrKHsgbGFiZWwsIGRhdGEgfTogeyBsYWJlbDogc3RyaW5nOyBkYXRhOiB1bmtub3duIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTJcIj5cbiAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW0gdGV4dC13aGl0ZS83MFwiPntsYWJlbH08L3A+XG4gICAgICA8cHJlIGNsYXNzTmFtZT1cIm1heC1oLTcyIG92ZXJmbG93LWF1dG8gcm91bmRlZC14bCBiZy1ibGFjay82MCBwLTQgdGV4dC14cyBsZWFkaW5nLXJlbGF4ZWQgdGV4dC1lbWVyYWxkLTIwMFwiPlxuICAgICAgICB7c2FmZUpzb24oZGF0YSl9XG4gICAgICA8L3ByZT5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gc2FmZUpzb24oZGF0YTogdW5rbm93bikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gYFVuYWJsZSB0byBzZXJpYWxpc2UgcGF5bG9hZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duIGVycm9yJ31gO1xuICB9XG59XG4iXSwibmFtZXMiOlsidXNlTWVtbyIsInVzZVN0YXRlIiwiSGFzaGJyb3duU3VtbWFyeSIsInByb3ZpZGVyTWV0YWRhdGEiLCJwcm92aWRlckVudHJpZXMiLCJPYmplY3QiLCJlbnRyaWVzIiwiSG9tZVBhZ2UiLCJwcm92aWRlciIsInNldFByb3ZpZGVyIiwicHJvbXB0Iiwic2V0UHJvbXB0IiwicmVzdWx0Iiwic2V0UmVzdWx0IiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsInByb3ZpZGVyTGFiZWwiLCJsYWJlbCIsImhhbmRsZVN1Ym1pdCIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwianNvbiIsIm9rIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJlcnIiLCJFcnJvciIsIm1haW4iLCJjbGFzc05hbWUiLCJoZWFkZXIiLCJoMSIsInAiLCJzZWN0aW9uIiwiZm9ybSIsIm9uU3VibWl0IiwiZGl2IiwiaHRtbEZvciIsInNlbGVjdCIsImlkIiwidmFsdWUiLCJvbkNoYW5nZSIsInRhcmdldCIsIm1hcCIsIm1ldGEiLCJvcHRpb24iLCJ0ZXh0YXJlYSIsInJvd3MiLCJwbGFjZWhvbGRlciIsImJ1dHRvbiIsInR5cGUiLCJkaXNhYmxlZCIsImgyIiwiZHVyYXRpb25NcyIsInRvTG9jYWxlU3RyaW5nIiwibW9kZWxVc2VkIiwidGV4dE91dHB1dCIsIlBheWxvYWRCbG9jayIsImRhdGEiLCJyZXF1ZXN0UGF5bG9hZCIsInJlc3BvbnNlUGF5bG9hZCIsInByZSIsInNhZmVKc29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/HashbrownSummary.tsx":
/*!*********************************************!*\
  !*** ./src/components/HashbrownSummary.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HashbrownSummary: function() { return /* binding */ HashbrownSummary; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _hashbrownai_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @hashbrownai/core */ \"(app-pages-browser)/./node_modules/.pnpm/@hashbrownai+core@0.3.0/node_modules/@hashbrownai/core/index.esm.js\");\n/* harmony import */ var _hashbrownai_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @hashbrownai/react */ \"(app-pages-browser)/./node_modules/.pnpm/@hashbrownai+react@0.3.0_@hashbrownai+core@0.3.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@hashbrownai/react/index.esm.js\");\n/* harmony import */ var _lib_providers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/providers */ \"(app-pages-browser)/./src/lib/providers.ts\");\n/* harmony import */ var _hashbrown_KeyValueList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hashbrown/KeyValueList */ \"(app-pages-browser)/./src/components/hashbrown/KeyValueList.tsx\");\n/* harmony import */ var _hashbrown_Note__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hashbrown/Note */ \"(app-pages-browser)/./src/components/hashbrown/Note.tsx\");\n/* harmony import */ var _hashbrown_SummaryCard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hashbrown/SummaryCard */ \"(app-pages-browser)/./src/components/hashbrown/SummaryCard.tsx\");\n/* __next_internal_client_entry_do_not_use__ HashbrownSummary auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction safeStringify(value) {\n    let space = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2, maxLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 6000;\n    try {\n        const json = JSON.stringify(value, null, space);\n        if (!json) return \"\";\n        return json.length > maxLength ? \"\".concat(json.slice(0, maxLength), \"...\") : json;\n    } catch (error) {\n        return \"Unable to stringify value: \".concat(error instanceof Error ? error.message : \"unknown error\");\n    }\n}\nconst exposedComponents = [\n    (0,_hashbrownai_react__WEBPACK_IMPORTED_MODULE_6__.exposeComponent)(_hashbrown_SummaryCard__WEBPACK_IMPORTED_MODULE_5__.SummaryCard, {\n        name: \"SummaryCard\",\n        description: \"Use this to summarise whether the API key test succeeded or failed.\",\n        props: {\n            title: _hashbrownai_core__WEBPACK_IMPORTED_MODULE_7__.s.string(\"Short title for the summary card.\"),\n            body: _hashbrownai_core__WEBPACK_IMPORTED_MODULE_7__.s.string(\"Detailed explanation in plain text.\"),\n            tone: _hashbrownai_core__WEBPACK_IMPORTED_MODULE_7__.s.string(\"Visual tone for the card. Use success, info, warning, or danger to reflect the result.\")\n        }\n    }),\n    (0,_hashbrownai_react__WEBPACK_IMPORTED_MODULE_6__.exposeComponent)(_hashbrown_KeyValueList__WEBPACK_IMPORTED_MODULE_3__.KeyValueList, {\n        name: \"KeyValueList\",\n        description: \"Display useful metadata about the API call such as latency and HTTP status.\",\n        props: {\n            heading: _hashbrownai_core__WEBPACK_IMPORTED_MODULE_7__.s.string(\"Section heading.\"),\n            items: _hashbrownai_core__WEBPACK_IMPORTED_MODULE_7__.s.array(\"Key metrics or facts about the API response.\", _hashbrownai_core__WEBPACK_IMPORTED_MODULE_7__.s.object(\"Individual key/value pair.\", {\n                label: _hashbrownai_core__WEBPACK_IMPORTED_MODULE_7__.s.string(\"Label to display.\"),\n                value: _hashbrownai_core__WEBPACK_IMPORTED_MODULE_7__.s.string(\"Associated value.\")\n            }))\n        }\n    }),\n    (0,_hashbrownai_react__WEBPACK_IMPORTED_MODULE_6__.exposeComponent)(_hashbrown_Note__WEBPACK_IMPORTED_MODULE_4__.Note, {\n        name: \"Note\",\n        description: \"Show helpful guidance or follow-up steps for the user.\",\n        props: {\n            text: _hashbrownai_core__WEBPACK_IMPORTED_MODULE_7__.s.string(\"Content for the note.\")\n        },\n        children: false\n    })\n];\nfunction HashbrownSummary(param) {\n    let { provider, providerLabel, result } = param;\n    const url = \"/api/hashbrown/\".concat(provider);\n    if (!result) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"rounded-2xl border border-dashed border-white/10 bg-slate-950/60 p-6 text-sm text-white/60\",\n            children: \"Run a check and we will generate a quick summary here.\"\n        }, void 0, false, {\n            fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n            lineNumber: 72,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_hashbrownai_react__WEBPACK_IMPORTED_MODULE_6__.HashbrownProvider, {\n        url: url,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SummaryRuntime, {\n            provider: provider,\n            providerLabel: providerLabel,\n            result: result\n        }, void 0, false, {\n            fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n            lineNumber: 80,\n            columnNumber: 7\n        }, this)\n    }, \"\".concat(provider, \"-\").concat(result.status, \"-\").concat(result.durationMs), false, {\n        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n        lineNumber: 79,\n        columnNumber: 5\n    }, this);\n}\n_c = HashbrownSummary;\nfunction SummaryRuntime(param) {\n    let { provider, providerLabel, result } = param;\n    _s();\n    const lastPayloadRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    var _result_modelUsed;\n    const summaryModel = provider === \"gemini\" ? \"gemini-2.5-flash\" : (_result_modelUsed = result.modelUsed) !== null && _result_modelUsed !== void 0 ? _result_modelUsed : _lib_providers__WEBPACK_IMPORTED_MODULE_2__.providerMetadata[provider].defaultModel;\n    const model = summaryModel;\n    const payloadForAi = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return safeStringify({\n            provider,\n            providerLabel,\n            prompt: result.prompt,\n            status: result.status,\n            latencyMs: result.durationMs,\n            modelUsed: summaryModel,\n            textOutput: result.textOutput,\n            responsePayload: result.responsePayload\n        }, 2, 6000);\n    }, [\n        provider,\n        providerLabel,\n        result,\n        summaryModel\n    ]);\n    const { messages, sendMessage, stop, setMessages, isReceiving, isSending, error } = (0,_hashbrownai_react__WEBPACK_IMPORTED_MODULE_6__.useUiChat)({\n        debugName: \"api-summary\",\n        model,\n        system: \"You help developers understand whether an API key check succeeded. Use the provided components to share a clear status, key metrics, and any follow-up advice. Focus on being concise.\",\n        components: exposedComponents\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!payloadForAi) return;\n        if (lastPayloadRef.current === payloadForAi) return;\n        lastPayloadRef.current = payloadForAi;\n        if (isReceiving || isSending) {\n            stop(true);\n        }\n        setMessages([]);\n        sendMessage({\n            role: \"user\",\n            content: \"Here is the latest API check result in JSON format. Summarize it for the user and call out whether the key worked.\\n\".concat(payloadForAi)\n        });\n    }, [\n        payloadForAi,\n        sendMessage,\n        setMessages,\n        stop,\n        isReceiving,\n        isSending\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col gap-4 rounded-2xl border border-white/10 bg-slate-950/60 p-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                className: \"flex items-center justify-between\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-lg font-semibold text-white/90\",\n                        children: \"Hashbrown summary\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n                        lineNumber: 142,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"rounded-full border border-white/10 bg-white/5 px-3 py-1 text-xs uppercase tracking-wide text-white/60\",\n                        children: providerLabel\n                    }, void 0, false, {\n                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n                        lineNumber: 143,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n                lineNumber: 141,\n                columnNumber: 7\n            }, this),\n            error ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"rounded-lg border border-rose-500/60 bg-rose-500/10 p-4 text-sm text-rose-100\",\n                children: error.message\n            }, void 0, false, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n                lineNumber: 149,\n                columnNumber: 9\n            }, this) : null,\n            (isReceiving || isSending) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center gap-2 text-sm text-white/60\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"h-3 w-3 animate-pulse rounded-full bg-white/40\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n                        lineNumber: 156,\n                        columnNumber: 11\n                    }, this),\n                    \"Generating summary...\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n                lineNumber: 155,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col gap-4\",\n                children: messages.filter((entry)=>entry.role === \"assistant\").map((entry, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex flex-col gap-4\",\n                        children: entry.ui && entry.ui.length > 0 ? entry.ui : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"rounded-lg border border-white/10 bg-slate-900/80 p-4 text-sm text-white/80\",\n                            children: typeof entry.content === \"string\" ? entry.content : \"Assistant response received.\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n                            lineNumber: 169,\n                            columnNumber: 17\n                        }, this)\n                    }, index, false, {\n                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n                        lineNumber: 165,\n                        columnNumber: 13\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n                lineNumber: 161,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/HashbrownSummary.tsx\",\n        lineNumber: 140,\n        columnNumber: 5\n    }, this);\n}\n_s(SummaryRuntime, \"4wYtmODSKQuavZKjpLd5QZQCVJo=\", false, function() {\n    return [\n        _hashbrownai_react__WEBPACK_IMPORTED_MODULE_6__.useUiChat\n    ];\n});\n_c1 = SummaryRuntime;\nvar _c, _c1;\n$RefreshReg$(_c, \"HashbrownSummary\");\n$RefreshReg$(_c1, \"SummaryRuntime\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0hhc2hicm93blN1bW1hcnkudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVtRDtBQUNiO0FBQzZDO0FBR2hDO0FBR0s7QUFDaEI7QUFDYztBQUV0RCxTQUFTVyxjQUFjQyxLQUFjO1FBQUVDLFFBQUFBLGlFQUFRLEdBQUdDLFlBQUFBLGlFQUFZO0lBQzVELElBQUk7UUFDRixNQUFNQyxPQUFPQyxLQUFLQyxTQUFTLENBQUNMLE9BQU8sTUFBTUM7UUFDekMsSUFBSSxDQUFDRSxNQUFNLE9BQU87UUFDbEIsT0FBT0EsS0FBS0csTUFBTSxHQUFHSixZQUFZLEdBQTRCLE9BQXpCQyxLQUFLSSxLQUFLLENBQUMsR0FBR0wsWUFBVyxTQUFPQztJQUN0RSxFQUFFLE9BQU9LLE9BQU87UUFDZCxPQUFPLDhCQUF1RixPQUF6REEsaUJBQWlCQyxRQUFRRCxNQUFNRSxPQUFPLEdBQUc7SUFDaEY7QUFDRjtBQUVBLE1BQU1DLG9CQUFvQjtJQUN4Qm5CLG1FQUFlQSxDQUFDTSwrREFBV0EsRUFBRTtRQUMzQmMsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLE9BQU87WUFDTEMsT0FBT3hCLGdEQUFDQSxDQUFDeUIsTUFBTSxDQUFDO1lBQ2hCQyxNQUFNMUIsZ0RBQUNBLENBQUN5QixNQUFNLENBQUM7WUFDZkUsTUFBTTNCLGdEQUFDQSxDQUFDeUIsTUFBTSxDQUNaO1FBRUo7SUFDRjtJQUNBeEIsbUVBQWVBLENBQUNJLGlFQUFZQSxFQUFFO1FBQzVCZ0IsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLE9BQU87WUFDTEssU0FBUzVCLGdEQUFDQSxDQUFDeUIsTUFBTSxDQUFDO1lBQ2xCSSxPQUFPN0IsZ0RBQUNBLENBQUM4QixLQUFLLENBQ1osZ0RBQ0E5QixnREFBQ0EsQ0FBQytCLE1BQU0sQ0FBQyw4QkFBOEI7Z0JBQ3JDQyxPQUFPaEMsZ0RBQUNBLENBQUN5QixNQUFNLENBQUM7Z0JBQ2hCaEIsT0FBT1QsZ0RB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QUFDLENBQUNDLFFBQVVBLE1BQU1OLElBQUksS0FBSyxhQUNqQ08sR0FBRyxDQUFDLENBQUNELE9BQU9FLHNCQUNYLDhEQUFDakM7d0JBQWdCQyxXQUFVO2tDQUN4QjhCLE1BQU1HLEVBQUUsSUFBSUgsTUFBTUcsRUFBRSxDQUFDM0QsTUFBTSxHQUFHLElBQzdCd0QsTUFBTUcsRUFBRSxpQkFFUiw4REFBQ2xDOzRCQUFJQyxXQUFVO3NDQUNaLE9BQU84QixNQUFNTCxPQUFPLEtBQUssV0FDdEJLLE1BQU1MLE9BQU8sR0FDYjs7Ozs7O3VCQVBBTzs7Ozs7Ozs7Ozs7Ozs7OztBQWV0QjtHQTdGUy9COztRQThCSHZDLHlEQUFTQTs7O01BOUJOdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvSGFzaGJyb3duU3VtbWFyeS50c3g/ZjlkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcyB9IGZyb20gJ0BoYXNoYnJvd25haS9jb3JlJztcbmltcG9ydCB7IGV4cG9zZUNvbXBvbmVudCwgSGFzaGJyb3duUHJvdmlkZXIsIHVzZVVpQ2hhdCB9IGZyb20gJ0BoYXNoYnJvd25haS9yZWFjdCc7XG5cbmltcG9ydCB0eXBlIHsgUHJvdmlkZXJJZCB9IGZyb20gJ0AvbGliL3Byb3ZpZGVycyc7XG5pbXBvcnQgeyBwcm92aWRlck1ldGFkYXRhIH0gZnJvbSAnQC9saWIvcHJvdmlkZXJzJztcbmltcG9ydCB0eXBlIHsgQXBpQ2hlY2tTdWNjZXNzIH0gZnJvbSAnQC90eXBlcy9jaGVjayc7XG5cbmltcG9ydCB7IEtleVZhbHVlTGlzdCB9IGZyb20gJy4vaGFzaGJyb3duL0tleVZhbHVlTGlzdCc7XG5pbXBvcnQgeyBOb3RlIH0gZnJvbSAnLi9oYXNoYnJvd24vTm90ZSc7XG5pbXBvcnQgeyBTdW1tYXJ5Q2FyZCB9IGZyb20gJy4vaGFzaGJyb3duL1N1bW1hcnlDYXJkJztcblxuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeSh2YWx1ZTogdW5rbm93biwgc3BhY2UgPSAyLCBtYXhMZW5ndGggPSA2MDAwKSB7XG4gIHRyeSB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCBzcGFjZSk7XG4gICAgaWYgKCFqc29uKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGpzb24ubGVuZ3RoID4gbWF4TGVuZ3RoID8gYCR7anNvbi5zbGljZSgwLCBtYXhMZW5ndGgpfS4uLmAgOiBqc29uO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBgVW5hYmxlIHRvIHN0cmluZ2lmeSB2YWx1ZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duIGVycm9yJ31gO1xuICB9XG59XG5cbmNvbnN0IGV4cG9zZWRDb21wb25lbnRzID0gW1xuICBleHBvc2VDb21wb25lbnQoU3VtbWFyeUNhcmQsIHtcbiAgICBuYW1lOiAnU3VtbWFyeUNhcmQnLFxuICAgIGRlc2NyaXB0aW9uOiAnVXNlIHRoaXMgdG8gc3VtbWFyaXNlIHdoZXRoZXIgdGhlIEFQSSBrZXkgdGVzdCBzdWNjZWVkZWQgb3IgZmFpbGVkLicsXG4gICAgcHJvcHM6IHtcbiAgICAgIHRpdGxlOiBzLnN0cmluZygnU2hvcnQgdGl0bGUgZm9yIHRoZSBzdW1tYXJ5IGNhcmQuJyksXG4gICAgICBib2R5OiBzLnN0cmluZygnRGV0YWlsZWQgZXhwbGFuYXRpb24gaW4gcGxhaW4gdGV4dC4nKSxcbiAgICAgIHRvbmU6IHMuc3RyaW5nKFxuICAgICAgICAnVmlzdWFsIHRvbmUgZm9yIHRoZSBjYXJkLiBVc2Ugc3VjY2VzcywgaW5mbywgd2FybmluZywgb3IgZGFuZ2VyIHRvIHJlZmxlY3QgdGhlIHJlc3VsdC4nLFxuICAgICAgKSxcbiAgICB9LFxuICB9KSxcbiAgZXhwb3NlQ29tcG9uZW50KEtleVZhbHVlTGlzdCwge1xuICAgIG5hbWU6ICdLZXlWYWx1ZUxpc3QnLFxuICAgIGRlc2NyaXB0aW9uOiAnRGlzcGxheSB1c2VmdWwgbWV0YWRhdGEgYWJvdXQgdGhlIEFQSSBjYWxsIHN1Y2ggYXMgbGF0ZW5jeSBhbmQgSFRUUCBzdGF0dXMuJyxcbiAgICBwcm9wczoge1xuICAgICAgaGVhZGluZzogcy5zdHJpbmcoJ1NlY3Rpb24gaGVhZGluZy4nKSxcbiAgICAgIGl0ZW1zOiBzLmFycmF5KFxuICAgICAgICAnS2V5IG1ldHJpY3Mgb3IgZmFjdHMgYWJvdXQgdGhlIEFQSSByZXNwb25zZS4nLFxuICAgICAgICBzLm9iamVjdCgnSW5kaXZpZHVhbCBrZXkvdmFsdWUgcGFpci4nLCB7XG4gICAgICAgICAgbGFiZWw6IHMuc3RyaW5nKCdMYWJlbCB0byBkaXNwbGF5LicpLFxuICAgICAgICAgIHZhbHVlOiBzLnN0cmluZygnQXNzb2NpYXRlZCB2YWx1ZS4nKSxcbiAgICAgICAgfSksXG4gICAgICApLFxuICAgIH0sXG4gIH0pLFxuICBleHBvc2VDb21wb25lbnQoTm90ZSwge1xuICAgIG5hbWU6ICdOb3RlJyxcbiAgICBkZXNjcmlwdGlvbjogJ1Nob3cgaGVscGZ1bCBndWlkYW5jZSBvciBmb2xsb3ctdXAgc3RlcHMgZm9yIHRoZSB1c2VyLicsXG4gICAgcHJvcHM6IHtcbiAgICAgIHRleHQ6IHMuc3RyaW5nKCdDb250ZW50IGZvciB0aGUgbm90ZS4nKSxcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBmYWxzZSxcbiAgfSksXG5dO1xuXG5pbnRlcmZhY2UgSGFzaGJyb3duU3VtbWFyeVByb3BzIHtcbiAgcHJvdmlkZXI6IFByb3ZpZGVySWQ7XG4gIHByb3ZpZGVyTGFiZWw6IHN0cmluZztcbiAgcmVzdWx0OiBBcGlDaGVja1N1Y2Nlc3MgfCBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSGFzaGJyb3duU3VtbWFyeSh7IHByb3ZpZGVyLCBwcm92aWRlckxhYmVsLCByZXN1bHQgfTogSGFzaGJyb3duU3VtbWFyeVByb3BzKSB7XG4gIGNvbnN0IHVybCA9IGAvYXBpL2hhc2hicm93bi8ke3Byb3ZpZGVyfWA7XG5cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3VuZGVkLTJ4bCBib3JkZXIgYm9yZGVyLWRhc2hlZCBib3JkZXItd2hpdGUvMTAgYmctc2xhdGUtOTUwLzYwIHAtNiB0ZXh0LXNtIHRleHQtd2hpdGUvNjBcIj5cbiAgICAgICAgUnVuIGEgY2hlY2sgYW5kIHdlIHdpbGwgZ2VuZXJhdGUgYSBxdWljayBzdW1tYXJ5IGhlcmUuXG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8SGFzaGJyb3duUHJvdmlkZXIga2V5PXtgJHtwcm92aWRlcn0tJHtyZXN1bHQuc3RhdHVzfS0ke3Jlc3VsdC5kdXJhdGlvbk1zfWB9IHVybD17dXJsfT5cbiAgICAgIDxTdW1tYXJ5UnVudGltZSBwcm92aWRlcj17cHJvdmlkZXJ9IHByb3ZpZGVyTGFiZWw9e3Byb3ZpZGVyTGFiZWx9IHJlc3VsdD17cmVzdWx0fSAvPlxuICAgIDwvSGFzaGJyb3duUHJvdmlkZXI+XG4gICk7XG59XG5cbmludGVyZmFjZSBTdW1tYXJ5UnVudGltZVByb3BzIGV4dGVuZHMgSGFzaGJyb3duU3VtbWFyeVByb3BzIHt9XG5cbmZ1bmN0aW9uIFN1bW1hcnlSdW50aW1lKHsgcHJvdmlkZXIsIHByb3ZpZGVyTGFiZWwsIHJlc3VsdCB9OiBTdW1tYXJ5UnVudGltZVByb3BzKSB7XG4gIGNvbnN0IGxhc3RQYXlsb2FkUmVmID0gdXNlUmVmPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBzdW1tYXJ5TW9kZWwgPSBwcm92aWRlciA9PT0gJ2dlbWluaScgPyAnZ2VtaW5pLTIuNS1mbGFzaCcgOiByZXN1bHQubW9kZWxVc2VkID8/IHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJdLmRlZmF1bHRNb2RlbDtcbiAgY29uc3QgbW9kZWwgPSBzdW1tYXJ5TW9kZWw7XG5cbiAgY29uc3QgcGF5bG9hZEZvckFpID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHNhZmVTdHJpbmdpZnkoXG4gICAgICB7XG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBwcm92aWRlckxhYmVsLFxuICAgICAgICBwcm9tcHQ6IHJlc3VsdC5wcm9tcHQsXG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgbGF0ZW5jeU1zOiByZXN1bHQuZHVyYXRpb25NcyxcbiAgICAgICAgbW9kZWxVc2VkOiBzdW1tYXJ5TW9kZWwsXG4gICAgICAgIHRleHRPdXRwdXQ6IHJlc3VsdC50ZXh0T3V0cHV0LFxuICAgICAgICByZXNwb25zZVBheWxvYWQ6IHJlc3VsdC5yZXNwb25zZVBheWxvYWQsXG4gICAgICB9LFxuICAgICAgMixcbiAgICAgIDYwMDAsXG4gICAgKTtcbiAgfSwgW3Byb3ZpZGVyLCBwcm92aWRlckxhYmVsLCByZXN1bHQsIHN1bW1hcnlNb2RlbF0pO1xuXG4gIGNvbnN0IHtcbiAgICBtZXNzYWdlcyxcbiAgICBzZW5kTWVzc2FnZSxcbiAgICBzdG9wLFxuICAgIHNldE1lc3NhZ2VzLFxuICAgIGlzUmVjZWl2aW5nLFxuICAgIGlzU2VuZGluZyxcbiAgICBlcnJvcixcbiAgfSA9IHVzZVVpQ2hhdCh7XG4gICAgZGVidWdOYW1lOiAnYXBpLXN1bW1hcnknLFxuICAgIG1vZGVsLFxuICAgIHN5c3RlbTpcbiAgICAgICdZb3UgaGVscCBkZXZlbG9wZXJzIHVuZGVyc3RhbmQgd2hldGhlciBhbiBBUEkga2V5IGNoZWNrIHN1Y2NlZWRlZC4gVXNlIHRoZSBwcm92aWRlZCBjb21wb25lbnRzIHRvIHNoYXJlIGEgY2xlYXIgc3RhdHVzLCBrZXkgbWV0cmljcywgYW5kIGFueSBmb2xsb3ctdXAgYWR2aWNlLiBGb2N1cyBvbiBiZWluZyBjb25jaXNlLicsXG4gICAgY29tcG9uZW50czogZXhwb3NlZENvbXBvbmVudHMsXG4gIH0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwYXlsb2FkRm9yQWkpIHJldHVybjtcbiAgICBpZiAobGFzdFBheWxvYWRSZWYuY3VycmVudCA9PT0gcGF5bG9hZEZvckFpKSByZXR1cm47XG4gICAgbGFzdFBheWxvYWRSZWYuY3VycmVudCA9IHBheWxvYWRGb3JBaTtcbiAgICBpZiAoaXNSZWNlaXZpbmcgfHwgaXNTZW5kaW5nKSB7XG4gICAgICBzdG9wKHRydWUpO1xuICAgIH1cbiAgICBzZXRNZXNzYWdlcyhbXSk7XG4gICAgc2VuZE1lc3NhZ2Uoe1xuICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgY29udGVudDogYEhlcmUgaXMgdGhlIGxhdGVzdCBBUEkgY2hlY2sgcmVzdWx0IGluIEpTT04gZm9ybWF0LiBTdW1tYXJpemUgaXQgZm9yIHRoZSB1c2VyIGFuZCBjYWxsIG91dCB3aGV0aGVyIHRoZSBrZXkgd29ya2VkLlxcbiR7cGF5bG9hZEZvckFpfWAsXG4gICAgfSk7XG4gIH0sIFtwYXlsb2FkRm9yQWksIHNlbmRNZXNzYWdlLCBzZXRNZXNzYWdlcywgc3RvcCwgaXNSZWNlaXZpbmcsIGlzU2VuZGluZ10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00IHJvdW5kZWQtMnhsIGJvcmRlciBib3JkZXItd2hpdGUvMTAgYmctc2xhdGUtOTUwLzYwIHAtNlwiPlxuICAgICAgPGhlYWRlciBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1zZW1pYm9sZCB0ZXh0LXdoaXRlLzkwXCI+SGFzaGJyb3duIHN1bW1hcnk8L2gyPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJyb3VuZGVkLWZ1bGwgYm9yZGVyIGJvcmRlci13aGl0ZS8xMCBiZy13aGl0ZS81IHB4LTMgcHktMSB0ZXh0LXhzIHVwcGVyY2FzZSB0cmFja2luZy13aWRlIHRleHQtd2hpdGUvNjBcIj5cbiAgICAgICAgICB7cHJvdmlkZXJMYWJlbH1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9oZWFkZXI+XG5cbiAgICAgIHtlcnJvciA/IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3VuZGVkLWxnIGJvcmRlciBib3JkZXItcm9zZS01MDAvNjAgYmctcm9zZS01MDAvMTAgcC00IHRleHQtc20gdGV4dC1yb3NlLTEwMFwiPlxuICAgICAgICAgIHtlcnJvci5tZXNzYWdlfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICkgOiBudWxsfVxuXG4gICAgICB7KGlzUmVjZWl2aW5nIHx8IGlzU2VuZGluZykgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yIHRleHQtc20gdGV4dC13aGl0ZS82MFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaC0zIHctMyBhbmltYXRlLXB1bHNlIHJvdW5kZWQtZnVsbCBiZy13aGl0ZS80MFwiIC8+XG4gICAgICAgICAgR2VuZXJhdGluZyBzdW1tYXJ5Li4uXG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00XCI+XG4gICAgICAgIHttZXNzYWdlc1xuICAgICAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5yb2xlID09PSAnYXNzaXN0YW50JylcbiAgICAgICAgICAubWFwKChlbnRyeSwgaW5kZXgpID0+IChcbiAgICAgICAgICAgIDxkaXYga2V5PXtpbmRleH0gY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtNFwiPlxuICAgICAgICAgICAgICB7ZW50cnkudWkgJiYgZW50cnkudWkubGVuZ3RoID4gMCA/IChcbiAgICAgICAgICAgICAgICBlbnRyeS51aVxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLXdoaXRlLzEwIGJnLXNsYXRlLTkwMC84MCBwLTQgdGV4dC1zbSB0ZXh0LXdoaXRlLzgwXCI+XG4gICAgICAgICAgICAgICAgICB7dHlwZW9mIGVudHJ5LmNvbnRlbnQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gZW50cnkuY29udGVudFxuICAgICAgICAgICAgICAgICAgICA6ICdBc3Npc3RhbnQgcmVzcG9uc2UgcmVjZWl2ZWQuJ31cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInMiLCJleHBvc2VDb21wb25lbnQiLCJIYXNoYnJvd25Qcm92aWRlciIsInVzZVVpQ2hhdCIsInByb3ZpZGVyTWV0YWRhdGEiLCJLZXlWYWx1ZUxpc3QiLCJOb3RlIiwiU3VtbWFyeUNhcmQiLCJzYWZlU3RyaW5naWZ5IiwidmFsdWUiLCJzcGFjZSIsIm1heExlbmd0aCIsImpzb24iLCJKU09OIiwic3RyaW5naWZ5IiwibGVuZ3RoIiwic2xpY2UiLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsImV4cG9zZWRDb21wb25lbnRzIiwibmFtZSIsImRlc2NyaXB0aW9uIiwicHJvcHMiLCJ0aXRsZSIsInN0cmluZyIsImJvZHkiLCJ0b25lIiwiaGVhZGluZyIsIml0ZW1zIiwiYXJyYXkiLCJvYmplY3QiLCJsYWJlbCIsInRleHQiLCJjaGlsZHJlbiIsIkhhc2hicm93blN1bW1hcnkiLCJwcm92aWRlciIsInByb3ZpZGVyTGFiZWwiLCJyZXN1bHQiLCJ1cmwiLCJkaXYiLCJjbGFzc05hbWUiLCJTdW1tYXJ5UnVudGltZSIsInN0YXR1cyIsImR1cmF0aW9uTXMiLCJsYXN0UGF5bG9hZFJlZiIsInN1bW1hcnlNb2RlbCIsIm1vZGVsVXNlZCIsImRlZmF1bHRNb2RlbCIsIm1vZGVsIiwicGF5bG9hZEZvckFpIiwicHJvbXB0IiwibGF0ZW5jeU1zIiwidGV4dE91dHB1dCIsInJlc3BvbnNlUGF5bG9hZCIsIm1lc3NhZ2VzIiwic2VuZE1lc3NhZ2UiLCJzdG9wIiwic2V0TWVzc2FnZXMiLCJpc1JlY2VpdmluZyIsImlzU2VuZGluZyIsImRlYnVnTmFtZSIsInN5c3RlbSIsImNvbXBvbmVudHMiLCJjdXJyZW50Iiwicm9sZSIsImNvbnRlbnQiLCJoZWFkZXIiLCJoMiIsInNwYW4iLCJmaWx0ZXIiLCJlbnRyeSIsIm1hcCIsImluZGV4IiwidWkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/HashbrownSummary.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/hashbrown/KeyValueList.tsx":
/*!***************************************************!*\
  !*** ./src/components/hashbrown/KeyValueList.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyValueList: function() { return /* binding */ KeyValueList; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ KeyValueList auto */ \nfunction KeyValueList(param) {\n    let { heading, items } = param;\n    if (!items.length) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n        className: \"flex flex-col gap-2 rounded-xl border border-white/10 bg-slate-900/60 p-4 ring-1 ring-inset ring-white/5\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                className: \"text-sm font-semibold uppercase tracking-wide text-white/60\",\n                children: heading\n            }, void 0, false, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/hashbrown/KeyValueList.tsx\",\n                lineNumber: 18,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"dl\", {\n                className: \"grid grid-cols-1 gap-3 text-sm sm:grid-cols-2\",\n                children: items.map((item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex flex-col gap-1 rounded-lg bg-slate-900/70 p-3 ring-1 ring-white/5\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"dt\", {\n                                className: \"text-xs uppercase tracking-wide text-white/40\",\n                                children: item.label\n                            }, void 0, false, {\n                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/hashbrown/KeyValueList.tsx\",\n                                lineNumber: 25,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"dd\", {\n                                className: \"text-white/85 break-words\",\n                                children: item.value\n                            }, void 0, false, {\n                                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/hashbrown/KeyValueList.tsx\",\n                                lineNumber: 26,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, item.label, true, {\n                        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/hashbrown/KeyValueList.tsx\",\n                        lineNumber: 21,\n                        columnNumber: 11\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/hashbrown/KeyValueList.tsx\",\n                lineNumber: 19,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/hashbrown/KeyValueList.tsx\",\n        lineNumber: 17,\n        columnNumber: 5\n    }, this);\n}\n_c = KeyValueList;\nvar _c;\n$RefreshReg$(_c, \"KeyValueList\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2hhc2hicm93bi9LZXlWYWx1ZUxpc3QudHN4IiwibWFwcGluZ3MiOiI7Ozs7OztBQVVPLFNBQVNBLGFBQWEsS0FBcUM7UUFBckMsRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQXFCLEdBQXJDO0lBQzNCLElBQUksQ0FBQ0EsTUFBTUMsTUFBTSxFQUFFO1FBQ2pCLE9BQU87SUFDVDtJQUVBLHFCQUNFLDhEQUFDQztRQUFRQyxXQUFVOzswQkFDakIsOERBQUNDO2dCQUFHRCxXQUFVOzBCQUErREo7Ozs7OzswQkFDN0UsOERBQUNNO2dCQUFHRixXQUFVOzBCQUNYSCxNQUFNTSxHQUFHLENBQUMsQ0FBQ0MscUJBQ1YsOERBQUNDO3dCQUVDTCxXQUFVOzswQ0FFViw4REFBQ007Z0NBQUdOLFdBQVU7MENBQWlESSxLQUFLRyxLQUFLOzs7Ozs7MENBQ3pFLDhEQUFDQztnQ0FBR1IsV0FBVTswQ0FBNkJJLEtBQUtLLEtBQUs7Ozs7Ozs7dUJBSmhETCxLQUFLRyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7O0FBVTNCO0tBckJnQloiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvaGFzaGJyb3duL0tleVZhbHVlTGlzdC50c3g/NjExNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgS2V5VmFsdWVMaXN0UHJvcHMge1xuICBoZWFkaW5nOiBzdHJpbmc7XG4gIGl0ZW1zOiBBcnJheTx7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICB9Pjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEtleVZhbHVlTGlzdCh7IGhlYWRpbmcsIGl0ZW1zIH06IEtleVZhbHVlTGlzdFByb3BzKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTIgcm91bmRlZC14bCBib3JkZXIgYm9yZGVyLXdoaXRlLzEwIGJnLXNsYXRlLTkwMC82MCBwLTQgcmluZy0xIHJpbmctaW5zZXQgcmluZy13aGl0ZS81XCI+XG4gICAgICA8aDQgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LXNlbWlib2xkIHVwcGVyY2FzZSB0cmFja2luZy13aWRlIHRleHQtd2hpdGUvNjBcIj57aGVhZGluZ308L2g0PlxuICAgICAgPGRsIGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTEgZ2FwLTMgdGV4dC1zbSBzbTpncmlkLWNvbHMtMlwiPlxuICAgICAgICB7aXRlbXMubWFwKChpdGVtKSA9PiAoXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAga2V5PXtpdGVtLmxhYmVsfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtMSByb3VuZGVkLWxnIGJnLXNsYXRlLTkwMC83MCBwLTMgcmluZy0xIHJpbmctd2hpdGUvNVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGR0IGNsYXNzTmFtZT1cInRleHQteHMgdXBwZXJjYXNlIHRyYWNraW5nLXdpZGUgdGV4dC13aGl0ZS80MFwiPntpdGVtLmxhYmVsfTwvZHQ+XG4gICAgICAgICAgICA8ZGQgY2xhc3NOYW1lPVwidGV4dC13aGl0ZS84NSBicmVhay13b3Jkc1wiPntpdGVtLnZhbHVlfTwvZGQ+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkpfVxuICAgICAgPC9kbD5cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiS2V5VmFsdWVMaXN0IiwiaGVhZGluZyIsIml0ZW1zIiwibGVuZ3RoIiwic2VjdGlvbiIsImNsYXNzTmFtZSIsImg0IiwiZGwiLCJtYXAiLCJpdGVtIiwiZGl2IiwiZHQiLCJsYWJlbCIsImRkIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/hashbrown/KeyValueList.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/hashbrown/Note.tsx":
/*!*******************************************!*\
  !*** ./src/components/hashbrown/Note.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Note: function() { return /* binding */ Note; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ Note auto */ \nfunction Note(param) {\n    let { text } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"rounded-lg border border-white/10 bg-slate-900/70 p-4 text-sm leading-relaxed text-white/75\",\n        children: text\n    }, void 0, false, {\n        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/hashbrown/Note.tsx\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, this);\n}\n_c = Note;\nvar _c;\n$RefreshReg$(_c, \"Note\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2hhc2hicm93bi9Ob3RlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFNTyxTQUFTQSxLQUFLLEtBQW1CO1FBQW5CLEVBQUVDLElBQUksRUFBYSxHQUFuQjtJQUNuQixxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTtrQkFDWkY7Ozs7OztBQUdQO0tBTmdCRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9oYXNoYnJvd24vTm90ZS50c3g/ZmU2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90ZVByb3BzIHtcbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTm90ZSh7IHRleHQgfTogTm90ZVByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJyb3VuZGVkLWxnIGJvcmRlciBib3JkZXItd2hpdGUvMTAgYmctc2xhdGUtOTAwLzcwIHAtNCB0ZXh0LXNtIGxlYWRpbmctcmVsYXhlZCB0ZXh0LXdoaXRlLzc1XCI+XG4gICAgICB7dGV4dH1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJOb3RlIiwidGV4dCIsImRpdiIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/hashbrown/Note.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/hashbrown/SummaryCard.tsx":
/*!**************************************************!*\
  !*** ./src/components/hashbrown/SummaryCard.tsx ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SummaryCard: function() { return /* binding */ SummaryCard; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* __next_internal_client_entry_do_not_use__ SummaryCard auto */ \n\nconst toneStyles = {\n    success: \"border-emerald-500/80 bg-emerald-500/10 text-emerald-100\",\n    info: \"border-sky-500/80 bg-sky-500/10 text-sky-100\",\n    warning: \"border-amber-500/80 bg-amber-500/10 text-amber-100\",\n    danger: \"border-rose-500/80 bg-rose-500/10 text-rose-100\"\n};\nfunction SummaryCard(param) {\n    let { title, body, tone = \"info\" } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"flex flex-col gap-2 rounded-xl border p-4 shadow-sm ring-1 ring-inset ring-white/5 backdrop-blur\", toneStyles[tone]),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                className: \"text-lg font-semibold leading-tight text-white/90\",\n                children: title\n            }, void 0, false, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/hashbrown/SummaryCard.tsx\",\n                lineNumber: 26,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"whitespace-pre-wrap text-sm leading-relaxed text-white/80\",\n                children: body\n            }, void 0, false, {\n                fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/hashbrown/SummaryCard.tsx\",\n                lineNumber: 27,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ohong/Library/Mobile Documents/com~apple~CloudDocs/dev/tea-olive/web/src/components/hashbrown/SummaryCard.tsx\",\n        lineNumber: 20,\n        columnNumber: 5\n    }, this);\n}\n_c = SummaryCard;\nvar _c;\n$RefreshReg$(_c, \"SummaryCard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2hhc2hicm93bi9TdW1tYXJ5Q2FyZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUV3QjtBQVF4QixNQUFNQyxhQUFvRTtJQUN4RUMsU0FBUztJQUNUQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsUUFBUTtBQUNWO0FBRU8sU0FBU0MsWUFBWSxLQUFnRDtRQUFoRCxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsT0FBTyxNQUFNLEVBQW9CLEdBQWhEO0lBQzFCLHFCQUNFLDhEQUFDQztRQUNDQyxXQUFXWCxnREFBSUEsQ0FDYixvR0FDQUMsVUFBVSxDQUFDUSxLQUFLOzswQkFHbEIsOERBQUNHO2dCQUFHRCxXQUFVOzBCQUFxREo7Ozs7OzswQkFDbkUsOERBQUNNO2dCQUFFRixXQUFVOzBCQUE2REg7Ozs7Ozs7Ozs7OztBQUdoRjtLQVpnQkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvaGFzaGJyb3duL1N1bW1hcnlDYXJkLnRzeD8wOWNiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VtbWFyeUNhcmRQcm9wcyB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGJvZHk6IHN0cmluZztcbiAgdG9uZT86ICdzdWNjZXNzJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdkYW5nZXInO1xufVxuXG5jb25zdCB0b25lU3R5bGVzOiBSZWNvcmQ8Tm9uTnVsbGFibGU8U3VtbWFyeUNhcmRQcm9wc1sndG9uZSddPiwgc3RyaW5nPiA9IHtcbiAgc3VjY2VzczogJ2JvcmRlci1lbWVyYWxkLTUwMC84MCBiZy1lbWVyYWxkLTUwMC8xMCB0ZXh0LWVtZXJhbGQtMTAwJyxcbiAgaW5mbzogJ2JvcmRlci1za3ktNTAwLzgwIGJnLXNreS01MDAvMTAgdGV4dC1za3ktMTAwJyxcbiAgd2FybmluZzogJ2JvcmRlci1hbWJlci01MDAvODAgYmctYW1iZXItNTAwLzEwIHRleHQtYW1iZXItMTAwJyxcbiAgZGFuZ2VyOiAnYm9yZGVyLXJvc2UtNTAwLzgwIGJnLXJvc2UtNTAwLzEwIHRleHQtcm9zZS0xMDAnLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIFN1bW1hcnlDYXJkKHsgdGl0bGUsIGJvZHksIHRvbmUgPSAnaW5mbycgfTogU3VtbWFyeUNhcmRQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xzeChcbiAgICAgICAgJ2ZsZXggZmxleC1jb2wgZ2FwLTIgcm91bmRlZC14bCBib3JkZXIgcC00IHNoYWRvdy1zbSByaW5nLTEgcmluZy1pbnNldCByaW5nLXdoaXRlLzUgYmFja2Ryb3AtYmx1cicsXG4gICAgICAgIHRvbmVTdHlsZXNbdG9uZV0sXG4gICAgICApfVxuICAgID5cbiAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtc2VtaWJvbGQgbGVhZGluZy10aWdodCB0ZXh0LXdoaXRlLzkwXCI+e3RpdGxlfTwvaDM+XG4gICAgICA8cCBjbGFzc05hbWU9XCJ3aGl0ZXNwYWNlLXByZS13cmFwIHRleHQtc20gbGVhZGluZy1yZWxheGVkIHRleHQtd2hpdGUvODBcIj57Ym9keX08L3A+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiY2xzeCIsInRvbmVTdHlsZXMiLCJzdWNjZXNzIiwiaW5mbyIsIndhcm5pbmciLCJkYW5nZXIiLCJTdW1tYXJ5Q2FyZCIsInRpdGxlIiwiYm9keSIsInRvbmUiLCJkaXYiLCJjbGFzc05hbWUiLCJoMyIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/hashbrown/SummaryCard.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/providers.ts":
/*!******************************!*\
  !*** ./src/lib/providers.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   callClaude: function() { return /* binding */ callClaude; },\n/* harmony export */   callGemini: function() { return /* binding */ callGemini; },\n/* harmony export */   callOpenAI: function() { return /* binding */ callOpenAI; },\n/* harmony export */   getProviderCall: function() { return /* binding */ getProviderCall; },\n/* harmony export */   parseProviderRequest: function() { return /* binding */ parseProviderRequest; },\n/* harmony export */   providerMetadata: function() { return /* binding */ providerMetadata; }\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/polyfills/process.js\");\n\nconst providerRequestSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    provider: zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n        \"openai\",\n        \"claude\",\n        \"gemini\"\n    ]),\n    prompt: zod__WEBPACK_IMPORTED_MODULE_0__.string().min(1, \"Prompt is required\")\n});\nfunction parseProviderRequest(json) {\n    return providerRequestSchema.parse(json);\n}\nvar _process_env_OPENAI_MODEL, _process_env_ANTHROPIC_MODEL, _process_env_GEMINI_MODEL;\nconst providerMetadata = {\n    openai: {\n        label: \"OpenAI\",\n        defaultModel: (_process_env_OPENAI_MODEL = process.env.OPENAI_MODEL) !== null && _process_env_OPENAI_MODEL !== void 0 ? _process_env_OPENAI_MODEL : \"gpt-4o-mini\",\n        envKey: \"OPENAI_API_KEY\"\n    },\n    claude: {\n        label: \"Claude\",\n        defaultModel: (_process_env_ANTHROPIC_MODEL = process.env.ANTHROPIC_MODEL) !== null && _process_env_ANTHROPIC_MODEL !== void 0 ? _process_env_ANTHROPIC_MODEL : \"claude-3-5-sonnet-20240620\",\n        envKey: \"ANTHROPIC_API_KEY\"\n    },\n    gemini: {\n        label: \"Gemini\",\n        defaultModel: (_process_env_GEMINI_MODEL = process.env.GEMINI_MODEL) !== null && _process_env_GEMINI_MODEL !== void 0 ? _process_env_GEMINI_MODEL : \"gemini-2.5-flash-lite\",\n        envKey: \"GEMINI_API_KEY\"\n    }\n};\nasync function callOpenAI(param) {\n    let { prompt, system, model, signal } = param;\n    var _choice_message;\n    const apiKey = process.env.OPENAI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"OPENAI_API_KEY is not set\");\n    }\n    var _process_env_OPENAI_BASE_URL;\n    const baseUrl = (_process_env_OPENAI_BASE_URL = process.env.OPENAI_BASE_URL) !== null && _process_env_OPENAI_BASE_URL !== void 0 ? _process_env_OPENAI_BASE_URL : \"https://api.openai.com\";\n    const url = \"\".concat(baseUrl.replace(/\\/$/, \"\"), \"/v1/chat/completions\");\n    const body = {\n        model: model !== null && model !== void 0 ? model : providerMetadata.openai.defaultModel,\n        messages: [\n            {\n                role: \"system\",\n                content: system !== null && system !== void 0 ? system : \"You help test whether an OpenAI API key works by echoing the user prompt clearly.\"\n            },\n            {\n                role: \"user\",\n                content: prompt\n            }\n        ],\n        temperature: 0\n    };\n    const response = await fetch(url, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: \"Bearer \".concat(apiKey)\n        },\n        body: JSON.stringify(body),\n        signal\n    });\n    const raw = await response.json().catch(()=>undefined);\n    let text = null;\n    const choice = Array.isArray(raw === null || raw === void 0 ? void 0 : raw.choices) ? raw.choices[0] : undefined;\n    if (choice === null || choice === void 0 ? void 0 : (_choice_message = choice.message) === null || _choice_message === void 0 ? void 0 : _choice_message.content) {\n        text = choice.message.content;\n    }\n    return {\n        rawResponse: raw,\n        textOutput: text,\n        requestPayload: body,\n        status: response.status\n    };\n}\nasync function callClaude(param) {\n    let { prompt, system, model, signal } = param;\n    const apiKey = process.env.ANTHROPIC_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"ANTHROPIC_API_KEY is not set\");\n    }\n    var _process_env_ANTHROPIC_BASE_URL;\n    const baseUrl = (_process_env_ANTHROPIC_BASE_URL = process.env.ANTHROPIC_BASE_URL) !== null && _process_env_ANTHROPIC_BASE_URL !== void 0 ? _process_env_ANTHROPIC_BASE_URL : \"https://api.anthropic.com\";\n    const url = \"\".concat(baseUrl.replace(/\\/$/, \"\"), \"/v1/messages\");\n    var _process_env_ANTHROPIC_MAX_TOKENS;\n    const body = {\n        model: model !== null && model !== void 0 ? model : providerMetadata.claude.defaultModel,\n        system: system !== null && system !== void 0 ? system : \"You help verify the Anthropic Claude API key.\",\n        max_tokens: Number((_process_env_ANTHROPIC_MAX_TOKENS = process.env.ANTHROPIC_MAX_TOKENS) !== null && _process_env_ANTHROPIC_MAX_TOKENS !== void 0 ? _process_env_ANTHROPIC_MAX_TOKENS : 1024),\n        messages: [\n            {\n                role: \"user\",\n                content: prompt\n            }\n        ]\n    };\n    var _process_env_ANTHROPIC_VERSION;\n    const response = await fetch(url, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            \"x-api-key\": apiKey,\n            \"anthropic-version\": (_process_env_ANTHROPIC_VERSION = process.env.ANTHROPIC_VERSION) !== null && _process_env_ANTHROPIC_VERSION !== void 0 ? _process_env_ANTHROPIC_VERSION : \"2023-06-01\"\n        },\n        body: JSON.stringify(body),\n        signal\n    });\n    const raw = await response.json().catch(()=>undefined);\n    let text = null;\n    if (Array.isArray(raw === null || raw === void 0 ? void 0 : raw.content)) {\n        text = raw.content.map((part)=>{\n            if (typeof (part === null || part === void 0 ? void 0 : part.text) === \"string\") return part.text;\n            return typeof part === \"string\" ? part : undefined;\n        }).filter(Boolean).join(\"\\n\");\n    }\n    return {\n        rawResponse: raw,\n        textOutput: text,\n        requestPayload: body,\n        status: response.status\n    };\n}\nasync function callGemini(param) {\n    let { prompt, system, model, signal } = param;\n    var _candidates__content, _candidates_;\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not set\");\n    }\n    const chosenModel = model !== null && model !== void 0 ? model : providerMetadata.gemini.defaultModel;\n    var _process_env_GEMINI_API_BASE;\n    const baseUrl = (_process_env_GEMINI_API_BASE = process.env.GEMINI_API_BASE) !== null && _process_env_GEMINI_API_BASE !== void 0 ? _process_env_GEMINI_API_BASE : \"https://generativelanguage.googleapis.com\";\n    const url = \"\".concat(baseUrl.replace(/\\/$/, \"\"), \"/v1beta/models/\").concat(chosenModel, \":generateContent?key=\").concat(apiKey);\n    const body = {\n        contents: [\n            {\n                role: \"user\",\n                parts: [\n                    {\n                        text: prompt\n                    }\n                ]\n            }\n        ],\n        systemInstruction: system ? {\n            parts: [\n                {\n                    text: system\n                }\n            ]\n        } : undefined\n    };\n    const response = await fetch(url, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(body),\n        signal\n    });\n    const raw = await response.json().catch(()=>undefined);\n    let text = null;\n    const candidates = Array.isArray(raw === null || raw === void 0 ? void 0 : raw.candidates) ? raw.candidates : [];\n    if (candidates.length > 0 && Array.isArray((_candidates_ = candidates[0]) === null || _candidates_ === void 0 ? void 0 : (_candidates__content = _candidates_.content) === null || _candidates__content === void 0 ? void 0 : _candidates__content.parts)) {\n        text = candidates[0].content.parts.map((part)=>typeof (part === null || part === void 0 ? void 0 : part.text) === \"string\" ? part.text : null).filter(Boolean).join(\"\\n\");\n    }\n    return {\n        rawResponse: raw,\n        textOutput: text,\n        requestPayload: body,\n        status: response.status\n    };\n}\nfunction getProviderCall(provider) {\n    switch(provider){\n        case \"openai\":\n            return callOpenAI;\n        case \"claude\":\n            return callClaude;\n        case \"gemini\":\n            return callGemini;\n        default:\n            throw new Error(\"Unsupported provider: \".concat(provider));\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcHJvdmlkZXJzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXdCO0FBdUJ4QixNQUFNQyx3QkFBd0JELHVDQUFRLENBQUM7SUFDckNHLFVBQVVILHdDQUFNLENBQUM7UUFBQztRQUFVO1FBQVU7S0FBUztJQUMvQ0ssUUFBUUwsdUNBQVEsR0FBR08sR0FBRyxDQUFDLEdBQUc7QUFDNUI7QUFFTyxTQUFTQyxxQkFBcUJDLElBQWE7SUFDaEQsT0FBT1Isc0JBQXNCUyxLQUFLLENBQUNEO0FBQ3JDO0lBS2tCRSwyQkFLQUEsOEJBS0FBO0FBYlgsTUFBTUMsbUJBQWdHO0lBQzNHQyxRQUFRO1FBQ05DLE9BQU87UUFDUEMsY0FBY0osQ0FBQUEsNEJBQUFBLE9BQU9BLENBQUNLLEdBQUcsQ0FBQ0MsWUFBWSxjQUF4Qk4sdUNBQUFBLDRCQUE0QjtRQUMxQ08sUUFBUTtJQUNWO0lBQ0FDLFFBQVE7UUFDTkwsT0FBTztRQUNQQyxjQUFjSixDQUFBQSwrQkFBQUEsT0FBT0EsQ0FBQ0ssR0FBRyxDQUFDSSxlQUFlLGNBQTNCVCwwQ0FBQUEsK0JBQStCO1FBQzdDTyxRQUFRO0lBQ1Y7SUFDQUcsUUFBUTtRQUNOUCxPQUFPO1FBQ1BDLGNBQWNKLENBQUFBLDRCQUFBQSxPQUFPQSxDQUFDSyxHQUFHLENBQUNNLFlBQVksY0FBeEJYLHVDQUFBQSw0QkFBNEI7UUFDMUNPLFFBQVE7SUFDVjtBQUNGLEVBQUU7QUFFSyxlQUFlSyxXQUFXLEtBQXNEO1FBQXRELEVBQUVsQixNQUFNLEVBQUVtQixNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUF1QixHQUF0RDtRQWtDM0JDO0lBakNKLE1BQU1DLFNBQVNqQixPQUFPQSxDQUFDSyxHQUFHLENBQUNhLGNBQWM7SUFDekMsSUFBSSxDQUFDRCxRQUFRO1FBQ1gsTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO1FBRWdCbkI7SUFBaEIsTUFBTW9CLFVBQVVwQixDQUFBQSwrQkFBQUEsT0FBT0EsQ0FBQ0ssR0FBRyxDQUFDZ0IsZUFBZSxjQUEzQnJCLDBDQUFBQSwrQkFBK0I7SUFDL0MsTUFBTXNCLE1BQU0sR0FBOEIsT0FBM0JGLFFBQVFHLE9BQU8sQ0FBQyxPQUFPLEtBQUk7SUFDMUMsTUFBTUMsT0FBTztRQUNYVixPQUFPQSxrQkFBQUEsbUJBQUFBLFFBQVNiLGlCQUFpQkMsTUFBTSxDQUFDRSxZQUFZO1FBQ3BEcUIsVUFBVTtZQUNSO2dCQUNFQyxNQUFNO2dCQUNOQyxTQUNFZCxtQkFBQUEsb0JBQUFBLFNBQVU7WUFDZDtZQUNBO2dCQUFFYSxNQUFNO2dCQUFRQyxTQUFTakM7WUFBTztTQUNqQztRQUNEa0MsYUFBYTtJQUNmO0lBRUEsTUFBTUMsV0FBVyxNQUFNQyxNQUFNUixLQUFLO1FBQ2hDUyxRQUFRO1FBQ1JDLFNBQVM7WUFDUCxnQkFBZ0I7WUFDaEJDLGVBQWUsVUFBaUIsT0FBUGhCO1FBQzNCO1FBQ0FPLE1BQU1VLEtBQUtDLFNBQVMsQ0FBQ1g7UUFDckJUO0lBQ0Y7SUFFQSxNQUFNcUIsTUFBTSxNQUFNUCxTQUFTL0IsSUFBSSxHQUFHdUMsS0FBSyxDQUFDLElBQU1DO0lBQzlDLElBQUlDLE9BQXNCO0lBQzFCLE1BQU12QixTQUFTd0IsTUFBTUMsT0FBTyxDQUFDTCxnQkFBQUEsMEJBQUFBLElBQUtNLE9BQU8sSUFBSU4sSUFBSU0sT0FBTyxDQUFDLEVBQUUsR0FBR0o7SUFDOUQsSUFBSXRCLG1CQUFBQSw4QkFBQUEsa0JBQUFBLE9BQVEyQixPQUFPLGNBQWYzQixzQ0FBQUEsZ0JBQWlCVyxPQUFPLEVBQUU7UUFDNUJZLE9BQU92QixPQUFPMkIsT0FBTyxDQUFDaEIsT0FBTztJQUMvQjtJQUVBLE9BQU87UUFDTGlCLGFBQWFSO1FBQ2JTLFlBQVlOO1FBQ1pPLGdCQUFnQnRCO1FBQ2hCdUIsUUFBUWxCLFNBQVNrQixNQUFNO0lBQ3pCO0FBQ0Y7QUFFTyxlQUFlQyxXQUFXLEtBQXNEO1FBQXRELEVBQUV0RCxNQUFNLEVBQUVtQixNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUF1QixHQUF0RDtJQUMvQixNQUFNRSxTQUFTakIsT0FBT0EsQ0FBQ0ssR0FBRyxDQUFDNEMsaUJBQWlCO0lBQzVDLElBQUksQ0FBQ2hDLFFBQVE7UUFDWCxNQUFNLElBQUlFLE1BQU07SUFDbEI7UUFFZ0JuQjtJQUFoQixNQUFNb0IsVUFBVXBCLENBQUFBLGtDQUFBQSxPQUFPQSxDQUFDSyxHQUFHLENBQUM2QyxrQkFBa0IsY0FBOUJsRCw2Q0FBQUEsa0NBQWtDO0lBQ2xELE1BQU1zQixNQUFNLEdBQThCLE9BQTNCRixRQUFRRyxPQUFPLENBQUMsT0FBTyxLQUFJO1FBSXJCdkI7SUFIckIsTUFBTXdCLE9BQU87UUFDWFYsT0FBT0Esa0JBQUFBLG1CQUFBQSxRQUFTYixpQkFBaUJPLE1BQU0sQ0FBQ0osWUFBWTtRQUNwRFMsUUFBUUEsbUJBQUFBLG9CQUFBQSxTQUFVO1FBQ2xCc0MsWUFBWUMsT0FBT3BELENBQUFBLG9DQUFBQSxPQUFPQSxDQUFDSyxHQUFHLENBQUNnRCxvQkFBb0IsY0FBaENyRCwrQ0FBQUEsb0NBQW9DO1FBQ3ZEeUIsVUFBVTtZQUNSO2dCQUNFQyxNQUFNO2dCQUNOQyxTQUFTakM7WUFDWDtTQUNEO0lBQ0g7UUFPeUJNO0lBTHpCLE1BQU02QixXQUFXLE1BQU1DLE1BQU1SLEtBQUs7UUFDaENTLFFBQVE7UUFDUkMsU0FBUztZQUNQLGdCQUFnQjtZQUNoQixhQUFhZjtZQUNiLHFCQUFxQmpCLENBQUFBLGlDQUFBQSxPQUFPQSxDQUFDSyxHQUFHLENBQUNpRCxpQkFBaUIsY0FBN0J0RCw0Q0FBQUEsaUNBQWlDO1FBQ3hEO1FBQ0F3QixNQUFNVSxLQUFLQyxTQUFTLENBQUNYO1FBQ3JCVDtJQUNGO0lBRUEsTUFBTXFCLE1BQU0sTUFBTVAsU0FBUy9CLElBQUksR0FBR3VDLEtBQUssQ0FBQyxJQUFNQztJQUM5QyxJQUFJQyxPQUFzQjtJQUMxQixJQUFJQyxNQUFNQyxPQUFPLENBQUNMLGdCQUFBQSwwQkFBQUEsSUFBS1QsT0FBTyxHQUFHO1FBQy9CWSxPQUFPSCxJQUFJVCxPQUFPLENBQ2Y0QixHQUFHLENBQUMsQ0FBQ0M7WUFDSixJQUFJLFFBQU9BLGlCQUFBQSwyQkFBQUEsS0FBTWpCLElBQUksTUFBSyxVQUFVLE9BQU9pQixLQUFLakIsSUFBSTtZQUNwRCxPQUFPLE9BQU9pQixTQUFTLFdBQVdBLE9BQU9sQjtRQUMzQyxHQUNDbUIsTUFBTSxDQUFDQyxTQUNQQyxJQUFJLENBQUM7SUFDVjtJQUVBLE9BQU87UUFDTGYsYUFBYVI7UUFDYlMsWUFBWU47UUFDWk8sZ0JBQWdCdEI7UUFDaEJ1QixRQUFRbEIsU0FBU2tCLE1BQU07SUFDekI7QUFDRjtBQUVPLGVBQWVhLFdBQVcsS0FBc0Q7UUFBdEQsRUFBRWxFLE1BQU0sRUFBRW1CLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQXVCLEdBQXREO1FBZ0NZOEMsc0JBQUFBO0lBL0IzQyxNQUFNNUMsU0FBU2pCLE9BQU9BLENBQUNLLEdBQUcsQ0FBQ3lELGNBQWM7SUFDekMsSUFBSSxDQUFDN0MsUUFBUTtRQUNYLE1BQU0sSUFBSUUsTUFBTTtJQUNsQjtJQUVBLE1BQU00QyxjQUFjakQsa0JBQUFBLG1CQUFBQSxRQUFTYixpQkFBaUJTLE1BQU0sQ0FBQ04sWUFBWTtRQUNqREo7SUFBaEIsTUFBTW9CLFVBQVVwQixDQUFBQSwrQkFBQUEsT0FBT0EsQ0FBQ0ssR0FBRyxDQUFDMkQsZUFBZSxjQUEzQmhFLDBDQUFBQSwrQkFBK0I7SUFDL0MsTUFBTXNCLE1BQU0sR0FBK0N5QyxPQUE1QzNDLFFBQVFHLE9BQU8sQ0FBQyxPQUFPLEtBQUksbUJBQW9ETixPQUFuQzhDLGFBQVkseUJBQThCLE9BQVA5QztJQUU5RixNQUFNTyxPQUFPO1FBQ1h5QyxVQUFVO1lBQ1I7Z0JBQ0V2QyxNQUFNO2dCQUNOd0MsT0FBTztvQkFBQzt3QkFBRTNCLE1BQU03QztvQkFBTztpQkFBRTtZQUMzQjtTQUNEO1FBQ0R5RSxtQkFBbUJ0RCxTQUFTO1lBQUVxRCxPQUFPO2dCQUFDO29CQUFFM0IsTUFBTTFCO2dCQUFPO2FBQUU7UUFBQyxJQUFJeUI7SUFDOUQ7SUFFQSxNQUFNVCxXQUFXLE1BQU1DLE1BQU1SLEtBQUs7UUFDaENTLFFBQVE7UUFDUkMsU0FBUztZQUNQLGdCQUFnQjtRQUNsQjtRQUNBUixNQUFNVSxLQUFLQyxTQUFTLENBQUNYO1FBQ3JCVDtJQUNGO0lBRUEsTUFBTXFCLE1BQU0sTUFBTVAsU0FBUy9CLElBQUksR0FBR3VDLEtBQUssQ0FBQyxJQUFNQztJQUM5QyxJQUFJQyxPQUFzQjtJQUMxQixNQUFNc0IsYUFBYXJCLE1BQU1DLE9BQU8sQ0FBQ0wsZ0JBQUFBLDBCQUFBQSxJQUFLeUIsVUFBVSxJQUFJekIsSUFBSXlCLFVBQVUsR0FBRyxFQUFFO0lBQ3ZFLElBQUlBLFdBQVdPLE1BQU0sR0FBRyxLQUFLNUIsTUFBTUMsT0FBTyxFQUFDb0IsZUFBQUEsVUFBVSxDQUFDLEVBQUUsY0FBYkEsb0NBQUFBLHVCQUFBQSxhQUFlbEMsT0FBTyxjQUF0QmtDLDJDQUFBQSxxQkFBd0JLLEtBQUssR0FBRztRQUN6RTNCLE9BQU9zQixVQUFVLENBQUMsRUFBRSxDQUFDbEMsT0FBTyxDQUFDdUMsS0FBSyxDQUMvQlgsR0FBRyxDQUFDLENBQUNDLE9BQWUsUUFBT0EsaUJBQUFBLDJCQUFBQSxLQUFNakIsSUFBSSxNQUFLLFdBQVdpQixLQUFLakIsSUFBSSxHQUFHLE1BQ2pFa0IsTUFBTSxDQUFDQyxTQUNQQyxJQUFJLENBQUM7SUFDVjtJQUVBLE9BQU87UUFDTGYsYUFBYVI7UUFDYlMsWUFBWU47UUFDWk8sZ0JBQWdCdEI7UUFDaEJ1QixRQUFRbEIsU0FBU2tCLE1BQU07SUFDekI7QUFDRjtBQUVPLFNBQVNzQixnQkFBZ0I3RSxRQUFvQjtJQUNsRCxPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPb0I7UUFDVCxLQUFLO1lBQ0gsT0FBT29DO1FBQ1QsS0FBSztZQUNILE9BQU9ZO1FBQ1Q7WUFDRSxNQUFNLElBQUl6QyxNQUFNLHlCQUFrRCxPQUF6QjNCO0lBQzdDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9wcm92aWRlcnMudHM/MTA3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcblxuZXhwb3J0IHR5cGUgUHJvdmlkZXJJZCA9ICdvcGVuYWknIHwgJ2NsYXVkZScgfCAnZ2VtaW5pJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm92aWRlclJlcXVlc3Qge1xuICBwcm92aWRlcjogUHJvdmlkZXJJZDtcbiAgcHJvbXB0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvdmlkZXJDYWxsT3B0aW9ucyB7XG4gIHByb21wdDogc3RyaW5nO1xuICBzeXN0ZW0/OiBzdHJpbmc7XG4gIG1vZGVsPzogc3RyaW5nO1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm92aWRlckNhbGxSZXN1bHQge1xuICByYXdSZXNwb25zZTogdW5rbm93bjtcbiAgdGV4dE91dHB1dDogc3RyaW5nIHwgbnVsbDtcbiAgcmVxdWVzdFBheWxvYWQ6IHVua25vd247XG4gIHN0YXR1czogbnVtYmVyO1xufVxuXG5jb25zdCBwcm92aWRlclJlcXVlc3RTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHByb3ZpZGVyOiB6LmVudW0oWydvcGVuYWknLCAnY2xhdWRlJywgJ2dlbWluaSddKSxcbiAgcHJvbXB0OiB6LnN0cmluZygpLm1pbigxLCAnUHJvbXB0IGlzIHJlcXVpcmVkJyksXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHJvdmlkZXJSZXF1ZXN0KGpzb246IHVua25vd24pOiBQcm92aWRlclJlcXVlc3Qge1xuICByZXR1cm4gcHJvdmlkZXJSZXF1ZXN0U2NoZW1hLnBhcnNlKGpzb24pO1xufVxuXG5leHBvcnQgY29uc3QgcHJvdmlkZXJNZXRhZGF0YTogUmVjb3JkPFByb3ZpZGVySWQsIHsgbGFiZWw6IHN0cmluZzsgZGVmYXVsdE1vZGVsOiBzdHJpbmc7IGVudktleTogc3RyaW5nIH0+ID0ge1xuICBvcGVuYWk6IHtcbiAgICBsYWJlbDogJ09wZW5BSScsXG4gICAgZGVmYXVsdE1vZGVsOiBwcm9jZXNzLmVudi5PUEVOQUlfTU9ERUwgPz8gJ2dwdC00by1taW5pJyxcbiAgICBlbnZLZXk6ICdPUEVOQUlfQVBJX0tFWScsXG4gIH0sXG4gIGNsYXVkZToge1xuICAgIGxhYmVsOiAnQ2xhdWRlJyxcbiAgICBkZWZhdWx0TW9kZWw6IHByb2Nlc3MuZW52LkFOVEhST1BJQ19NT0RFTCA/PyAnY2xhdWRlLTMtNS1zb25uZXQtMjAyNDA2MjAnLFxuICAgIGVudktleTogJ0FOVEhST1BJQ19BUElfS0VZJyxcbiAgfSxcbiAgZ2VtaW5pOiB7XG4gICAgbGFiZWw6ICdHZW1pbmknLFxuICAgIGRlZmF1bHRNb2RlbDogcHJvY2Vzcy5lbnYuR0VNSU5JX01PREVMID8/ICdnZW1pbmktMi41LWZsYXNoLWxpdGUnLFxuICAgIGVudktleTogJ0dFTUlOSV9BUElfS0VZJyxcbiAgfSxcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsT3BlbkFJKHsgcHJvbXB0LCBzeXN0ZW0sIG1vZGVsLCBzaWduYWwgfTogUHJvdmlkZXJDYWxsT3B0aW9ucyk6IFByb21pc2U8UHJvdmlkZXJDYWxsUmVzdWx0PiB7XG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52Lk9QRU5BSV9BUElfS0VZO1xuICBpZiAoIWFwaUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT1BFTkFJX0FQSV9LRVkgaXMgbm90IHNldCcpO1xuICB9XG5cbiAgY29uc3QgYmFzZVVybCA9IHByb2Nlc3MuZW52Lk9QRU5BSV9CQVNFX1VSTCA/PyAnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbSc7XG4gIGNvbnN0IHVybCA9IGAke2Jhc2VVcmwucmVwbGFjZSgvXFwvJC8sICcnKX0vdjEvY2hhdC9jb21wbGV0aW9uc2A7XG4gIGNvbnN0IGJvZHkgPSB7XG4gICAgbW9kZWw6IG1vZGVsID8/IHByb3ZpZGVyTWV0YWRhdGEub3BlbmFpLmRlZmF1bHRNb2RlbCxcbiAgICBtZXNzYWdlczogW1xuICAgICAge1xuICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgY29udGVudDpcbiAgICAgICAgICBzeXN0ZW0gPz8gJ1lvdSBoZWxwIHRlc3Qgd2hldGhlciBhbiBPcGVuQUkgQVBJIGtleSB3b3JrcyBieSBlY2hvaW5nIHRoZSB1c2VyIHByb21wdCBjbGVhcmx5LicsXG4gICAgICB9LFxuICAgICAgeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IHByb21wdCB9LFxuICAgIF0sXG4gICAgdGVtcGVyYXR1cmU6IDAsXG4gIH07XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FwaUtleX1gLFxuICAgIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgc2lnbmFsLFxuICB9KTtcblxuICBjb25zdCByYXcgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKTtcbiAgbGV0IHRleHQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBjb25zdCBjaG9pY2UgPSBBcnJheS5pc0FycmF5KHJhdz8uY2hvaWNlcykgPyByYXcuY2hvaWNlc1swXSA6IHVuZGVmaW5lZDtcbiAgaWYgKGNob2ljZT8ubWVzc2FnZT8uY29udGVudCkge1xuICAgIHRleHQgPSBjaG9pY2UubWVzc2FnZS5jb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByYXdSZXNwb25zZTogcmF3LFxuICAgIHRleHRPdXRwdXQ6IHRleHQsXG4gICAgcmVxdWVzdFBheWxvYWQ6IGJvZHksXG4gICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsQ2xhdWRlKHsgcHJvbXB0LCBzeXN0ZW0sIG1vZGVsLCBzaWduYWwgfTogUHJvdmlkZXJDYWxsT3B0aW9ucyk6IFByb21pc2U8UHJvdmlkZXJDYWxsUmVzdWx0PiB7XG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkFOVEhST1BJQ19BUElfS0VZO1xuICBpZiAoIWFwaUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQU5USFJPUElDX0FQSV9LRVkgaXMgbm90IHNldCcpO1xuICB9XG5cbiAgY29uc3QgYmFzZVVybCA9IHByb2Nlc3MuZW52LkFOVEhST1BJQ19CQVNFX1VSTCA/PyAnaHR0cHM6Ly9hcGkuYW50aHJvcGljLmNvbSc7XG4gIGNvbnN0IHVybCA9IGAke2Jhc2VVcmwucmVwbGFjZSgvXFwvJC8sICcnKX0vdjEvbWVzc2FnZXNgO1xuICBjb25zdCBib2R5ID0ge1xuICAgIG1vZGVsOiBtb2RlbCA/PyBwcm92aWRlck1ldGFkYXRhLmNsYXVkZS5kZWZhdWx0TW9kZWwsXG4gICAgc3lzdGVtOiBzeXN0ZW0gPz8gJ1lvdSBoZWxwIHZlcmlmeSB0aGUgQW50aHJvcGljIENsYXVkZSBBUEkga2V5LicsXG4gICAgbWF4X3Rva2VuczogTnVtYmVyKHByb2Nlc3MuZW52LkFOVEhST1BJQ19NQVhfVE9LRU5TID8/IDEwMjQpLFxuICAgIG1lc3NhZ2VzOiBbXG4gICAgICB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyBhcyBjb25zdCxcbiAgICAgICAgY29udGVudDogcHJvbXB0LFxuICAgICAgfSxcbiAgICBdLFxuICB9O1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICd4LWFwaS1rZXknOiBhcGlLZXksXG4gICAgICAnYW50aHJvcGljLXZlcnNpb24nOiBwcm9jZXNzLmVudi5BTlRIUk9QSUNfVkVSU0lPTiA/PyAnMjAyMy0wNi0wMScsXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICBzaWduYWwsXG4gIH0pO1xuXG4gIGNvbnN0IHJhdyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiB1bmRlZmluZWQpO1xuICBsZXQgdGV4dDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIGlmIChBcnJheS5pc0FycmF5KHJhdz8uY29udGVudCkpIHtcbiAgICB0ZXh0ID0gcmF3LmNvbnRlbnRcbiAgICAgIC5tYXAoKHBhcnQ6IGFueSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBhcnQ/LnRleHQgPT09ICdzdHJpbmcnKSByZXR1cm4gcGFydC50ZXh0O1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnID8gcGFydCA6IHVuZGVmaW5lZDtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJhd1Jlc3BvbnNlOiByYXcsXG4gICAgdGV4dE91dHB1dDogdGV4dCxcbiAgICByZXF1ZXN0UGF5bG9hZDogYm9keSxcbiAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGxHZW1pbmkoeyBwcm9tcHQsIHN5c3RlbSwgbW9kZWwsIHNpZ25hbCB9OiBQcm92aWRlckNhbGxPcHRpb25zKTogUHJvbWlzZTxQcm92aWRlckNhbGxSZXN1bHQ+IHtcbiAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuR0VNSU5JX0FQSV9LRVk7XG4gIGlmICghYXBpS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHRU1JTklfQVBJX0tFWSBpcyBub3Qgc2V0Jyk7XG4gIH1cblxuICBjb25zdCBjaG9zZW5Nb2RlbCA9IG1vZGVsID8/IHByb3ZpZGVyTWV0YWRhdGEuZ2VtaW5pLmRlZmF1bHRNb2RlbDtcbiAgY29uc3QgYmFzZVVybCA9IHByb2Nlc3MuZW52LkdFTUlOSV9BUElfQkFTRSA/PyAnaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20nO1xuICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCAnJyl9L3YxYmV0YS9tb2RlbHMvJHtjaG9zZW5Nb2RlbH06Z2VuZXJhdGVDb250ZW50P2tleT0ke2FwaUtleX1gO1xuXG4gIGNvbnN0IGJvZHkgPSB7XG4gICAgY29udGVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBwYXJ0czogW3sgdGV4dDogcHJvbXB0IH1dLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHN5c3RlbUluc3RydWN0aW9uOiBzeXN0ZW0gPyB7IHBhcnRzOiBbeyB0ZXh0OiBzeXN0ZW0gfV0gfSA6IHVuZGVmaW5lZCxcbiAgfTtcblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICBzaWduYWwsXG4gIH0pO1xuXG4gIGNvbnN0IHJhdyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiB1bmRlZmluZWQpO1xuICBsZXQgdGV4dDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBBcnJheS5pc0FycmF5KHJhdz8uY2FuZGlkYXRlcykgPyByYXcuY2FuZGlkYXRlcyA6IFtdO1xuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPiAwICYmIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlc1swXT8uY29udGVudD8ucGFydHMpKSB7XG4gICAgdGV4dCA9IGNhbmRpZGF0ZXNbMF0uY29udGVudC5wYXJ0c1xuICAgICAgLm1hcCgocGFydDogYW55KSA9PiAodHlwZW9mIHBhcnQ/LnRleHQgPT09ICdzdHJpbmcnID8gcGFydC50ZXh0IDogbnVsbCkpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJhd1Jlc3BvbnNlOiByYXcsXG4gICAgdGV4dE91dHB1dDogdGV4dCxcbiAgICByZXF1ZXN0UGF5bG9hZDogYm9keSxcbiAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3ZpZGVyQ2FsbChwcm92aWRlcjogUHJvdmlkZXJJZCkge1xuICBzd2l0Y2ggKHByb3ZpZGVyKSB7XG4gICAgY2FzZSAnb3BlbmFpJzpcbiAgICAgIHJldHVybiBjYWxsT3BlbkFJO1xuICAgIGNhc2UgJ2NsYXVkZSc6XG4gICAgICByZXR1cm4gY2FsbENsYXVkZTtcbiAgICBjYXNlICdnZW1pbmknOlxuICAgICAgcmV0dXJuIGNhbGxHZW1pbmk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcHJvdmlkZXI6ICR7cHJvdmlkZXIgc2F0aXNmaWVzIG5ldmVyfWApO1xuICB9XG59XG4iXSwibmFtZXMiOlsieiIsInByb3ZpZGVyUmVxdWVzdFNjaGVtYSIsIm9iamVjdCIsInByb3ZpZGVyIiwiZW51bSIsInByb21wdCIsInN0cmluZyIsIm1pbiIsInBhcnNlUHJvdmlkZXJSZXF1ZXN0IiwianNvbiIsInBhcnNlIiwicHJvY2VzcyIsInByb3ZpZGVyTWV0YWRhdGEiLCJvcGVuYWkiLCJsYWJlbCIsImRlZmF1bHRNb2RlbCIsImVudiIsIk9QRU5BSV9NT0RFTCIsImVudktleSIsImNsYXVkZSIsIkFOVEhST1BJQ19NT0RFTCIsImdlbWluaSIsIkdFTUlOSV9NT0RFTCIsImNhbGxPcGVuQUkiLCJzeXN0ZW0iLCJtb2RlbCIsInNpZ25hbCIsImNob2ljZSIsImFwaUtleSIsIk9QRU5BSV9BUElfS0VZIiwiRXJyb3IiLCJiYXNlVXJsIiwiT1BFTkFJX0JBU0VfVVJMIiwidXJsIiwicmVwbGFjZSIsImJvZHkiLCJtZXNzYWdlcyIsInJvbGUiLCJjb250ZW50IiwidGVtcGVyYXR1cmUiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJKU09OIiwic3RyaW5naWZ5IiwicmF3IiwiY2F0Y2giLCJ1bmRlZmluZWQiLCJ0ZXh0IiwiQXJyYXkiLCJpc0FycmF5IiwiY2hvaWNlcyIsIm1lc3NhZ2UiLCJyYXdSZXNwb25zZSIsInRleHRPdXRwdXQiLCJyZXF1ZXN0UGF5bG9hZCIsInN0YXR1cyIsImNhbGxDbGF1ZGUiLCJBTlRIUk9QSUNfQVBJX0tFWSIsIkFOVEhST1BJQ19CQVNFX1VSTCIsIm1heF90b2tlbnMiLCJOdW1iZXIiLCJBTlRIUk9QSUNfTUFYX1RPS0VOUyIsIkFOVEhST1BJQ19WRVJTSU9OIiwibWFwIiwicGFydCIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiY2FsbEdlbWluaSIsImNhbmRpZGF0ZXMiLCJHRU1JTklfQVBJX0tFWSIsImNob3Nlbk1vZGVsIiwiR0VNSU5JX0FQSV9CQVNFIiwiY29udGVudHMiLCJwYXJ0cyIsInN5c3RlbUluc3RydWN0aW9uIiwibGVuZ3RoIiwiZ2V0UHJvdmlkZXJDYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/providers.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \********************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMzJfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsa0xBQTBCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjMyX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzFmOTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpOyAvLyBUT0RPOiBEZWxldGUgd2l0aCBlbmFibGVSZW5kZXJhYmxlQ29udGV4dFxuXG52YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnN1bWVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbnZhciBlbmFibGVSZW5kZXJhYmxlQ29udGV4dCA9IGZhbHNlO1xuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMiA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTsgLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyKSB7XG4gICAgICAvLyBUT0RPOiBDcmVhdGUgYSBjb252ZW50aW9uIGZvciBuYW1pbmcgY2xpZW50IHJlZmVyZW5jZXMgd2l0aCBkZWJ1ZyBpbmZvLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJ0NhY2hlJztcbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCBlbmFibGVSZW5kZXJhYmxlQ29udGV4dCAgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuLyoqXG4gKiBMZXZlcmFnZXMgbmF0aXZlIGJyb3dzZXIvVk0gc3RhY2sgZnJhbWVzIHRvIGdldCBwcm9wZXIgZGV0YWlscyAoZS5nLlxuICogZmlsZW5hbWUsIGxpbmUgKyBjb2wgbnVtYmVyKSBmb3IgYSBzaW5nbGUgY29tcG9uZW50IGluIGEgY29tcG9uZW50IHN0YWNrLiBXZVxuICogZG8gdGhpcyBieTpcbiAqICAgKDEpIHRocm93aW5nIGFuZCBjYXRjaGluZyBhbiBlcnJvciBpbiB0aGUgZnVuY3Rpb24gLSB0aGlzIHdpbGwgYmUgb3VyXG4gKiAgICAgICBjb250cm9sIGVycm9yLlxuICogICAoMikgY2FsbGluZyB0aGUgY29tcG9uZW50IHdoaWNoIHdpbGwgZXZlbnR1YWxseSB0aHJvdyBhbiBlcnJvciB0aGF0IHdlJ2xsXG4gKiAgICAgICBjYXRjaCAtIHRoaXMgd2lsbCBiZSBvdXIgc2FtcGxlIGVycm9yLlxuICogICAoMykgZGlmZmluZyB0aGUgY29udHJvbCBhbmQgc2FtcGxlIGVycm9yIHN0YWNrcyB0byBmaW5kIHRoZSBzdGFjayBmcmFtZVxuICogICAgICAgd2hpY2ggcmVwcmVzZW50cyBvdXIgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuICAvKipcbiAgICogRmluZGluZyBhIGNvbW1vbiBzdGFjayBmcmFtZSBiZXR3ZWVuIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgY2FuIGJlXG4gICAqIHRyaWNreSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzIGFuZCBsZXZlbHMgb2Ygc3RhY2sgdHJhY2UgdHJ1bmNhdGlvbiBmcm9tXG4gICAqIGRpZmZlcmVudCBKUyBWTXMuIFNvIGluc3RlYWQgd2UnbGwgYXR0ZW1wdCB0byBjb250cm9sIHdoYXQgdGhhdCBjb21tb25cbiAgICogZnJhbWUgc2hvdWxkIGJlIHRocm91Z2ggdGhpcyBvYmplY3QgbWV0aG9kOlxuICAgKiBIYXZpbmcgYm90aCB0aGUgc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBiZSBpbiB0aGUgZnVuY3Rpb24gdW5kZXIgdGhlXG4gICAqIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgcHJvcGVydHksICsgc2V0dGluZyB0aGUgYG5hbWVgIGFuZFxuICAgKiBgZGlzcGxheU5hbWVgIHByb3BlcnRpZXMgb2YgdGhlIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBhIHN0YWNrXG4gICAqIGZyYW1lIGV4aXN0cyB0aGF0IGhhcyB0aGUgbWV0aG9kIG5hbWUgYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBpblxuICAgKiBpdCBmb3IgYm90aCBjb250cm9sIGFuZCBzYW1wbGUgc3RhY2tzLlxuICAgKi9cblxuXG4gIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250cm9sO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSBmbigpOyAvLyBJZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHJldHVybnMgYSBwcm9taXNlLCBpdCdzIGxpa2VseSBhbiBhc3luY1xuICAgICAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBjb21wb25lbnQgc3RhY2tzIGZvciBhc3luYyBjbGllbnQgY29tcG9uZW50cz9cblxuICAgICAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICB9XG4gIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnO1xuICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsICduYW1lJyk7IC8vIEJlZm9yZSBFUzYsIHRoZSBgbmFtZWAgcHJvcGVydHkgd2FzIG5vdCBjb25maWd1cmFibGUuXG5cbiAgaWYgKG5hbWVQcm9wRGVzY3JpcHRvciAmJiBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgLy8gVjggdXRpbGl6ZXMgYSBmdW5jdGlvbidzIGBuYW1lYCBwcm9wZXJ0eSB3aGVuIGdlbmVyYXRpbmcgYSBzdGFjayB0cmFjZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAvLyBDb25maWd1cmFibGUgcHJvcGVydGllcyBjYW4gYmUgdXBkYXRlZCBldmVuIGlmIGl0cyB3cml0YWJsZSBkZXNjcmlwdG9yXG4gICAgLy8gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG4gICAgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCdcbiAgICB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuXG4gICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IDA7XG4gICAgICB2YXIgYyA9IDA7XG5cbiAgICAgIHdoaWxlIChzIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmICFzYW1wbGVMaW5lc1tzXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgcysrO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoYyA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiYgIWNvbnRyb2xMaW5lc1tjXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgYysrO1xuICAgICAgfSAvLyBXZSBjb3VsZG4ndCBmaW5kIG91ciBpbnRlbnRpb25hbGx5IGluamVjdGVkIGNvbW1vbiByb290IGZyYW1lLCBhdHRlbXB0XG4gICAgICAvLyB0byBmaW5kIGFub3RoZXIgY29tbW9uIHJvb3QgZnJhbWUgYnkgc2VhcmNoIGZyb20gdGhlIGJvdHRvbSBvZiB0aGVcbiAgICAgIC8vIGNvbnRyb2wgc3RhY2suLi5cblxuXG4gICAgICBpZiAocyA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8IGMgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICAgIGMtLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHtcbiAgICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG5mdW5jdGlvbiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCBfcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgcmVmO1xuXG4gIHtcbiAgICByZWYgPSBfcmVmO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQ7XG5cbiAge1xuICAgIC8vIEluIHByb2QsIGByZWZgIGlzIGEgcmVndWxhciBwcm9wZXJ0eS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIGFcbiAgICAvLyBmdXR1cmUgcmVsZWFzZS5cbiAgICBlbGVtZW50ID0ge1xuICAgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGtleToga2V5LFxuICAgICAgcmVmOiByZWYsXG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgX293bmVyOiBvd25lclxuICAgIH07XG4gIH1cblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIGRlYnVnSW5mbyBjb250YWlucyBTZXJ2ZXIgQ29tcG9uZW50IGRlYnVnIGluZm9ybWF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfZGVidWdJbmZvJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFViQxKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gaW52YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvL1xuICAgICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIHZhbGlkIGVsZW1lbnQgdHlwZS5cbiAgICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzLiBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kXG4gICAgICAvLyBwcm9kLiAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGVcbiAgICAgIC8vIHR5cGUgaXMgZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBXYXJuIGFib3V0IGtleSBzcHJlYWQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSB0eXBlIGlzIHZhbGlkLlxuXG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB9XG5cbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgLy8gU2tpcCBvdmVyIHJlc2VydmVkIHByb3AgbmFtZXNcbiAgICAgIHByb3BOYW1lICE9PSAna2V5JyAmJiAocHJvcE5hbWUgIT09ICdyZWYnKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkgOyBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byByZW5kZXIgcGhhc2UgaW5zdGVhZCBvZiBhdCBlbGVtZW50IGNyZWF0aW9uLlxuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBqc3hERVYgPSBqc3hERVYkMSA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVY7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \**********************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMzJfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsMFFBQXNFO0FBQ3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMzJfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz81MWJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@hashbrownai+react@0.3.0_@hashbrownai+core@0.3.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@hashbrownai/react/index.esm.js":
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@hashbrownai+react@0.3.0_@hashbrownai+core@0.3.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@hashbrownai/react/index.esm.js ***!
  \**********************************************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HashbrownProvider: function() { return /* binding */ HashbrownProvider; },\n/* harmony export */   exposeComponent: function() { return /* binding */ exposeComponent; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; },\n/* harmony export */   useCompletion: function() { return /* binding */ useCompletion; },\n/* harmony export */   useRuntime: function() { return /* binding */ useRuntime; },\n/* harmony export */   useRuntimeFunction: function() { return /* binding */ useRuntimeFunction; },\n/* harmony export */   useStructuredChat: function() { return /* binding */ useStructuredChat; },\n/* harmony export */   useStructuredCompletion: function() { return /* binding */ useStructuredCompletion; },\n/* harmony export */   useTool: function() { return /* binding */ useTool; },\n/* harmony export */   useToolJavaScript: function() { return /* binding */ useToolJavaScript; },\n/* harmony export */   useUiChat: function() { return /* binding */ useUiChat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @hashbrownai/core */ \"(app-pages-browser)/./node_modules/.pnpm/@hashbrownai+core@0.3.0/node_modules/@hashbrownai/core/index.esm.js\");\n\n\n\n\n/**\n * Creates an object used to expose a component for use by the LLM.\n *\n * @example\n * ```ts\n * exposeComponent(\n *   CardComponent, // The React component to be exposed.\n *   { // The exposed component configuration.\n *     name: 'CardComponent',\n *     description: 'Show a card with children components to the user',\n *     children: 'any',\n *     props: {\n *       title: s.string('The title of the card'),\n *       description: s.streaming.string('The description of the card'),\n *     },\n *   },\n * });\n * ```\n *\n * @returns An object representing the component in order to expose it to the LLM.\n * @public\n */\nfunction exposeComponent(\n/**\n * The component to be exposed.\n */\ncomponent,\n/**\n * The configuration object for the component, excluding the component itself.\n */\nconfig) {\n  return Object.assign({\n    component\n  }, config);\n}\n\nconst HashbrownContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n/**\n * The context for the Hashbrown provider.  This is used to store the URL and middleware for contacting the Hashbrown endpoint.\n *\n * @public\n * @example\n * ```ts\n * <HashbrownProvider url=\"https://your.api.local/chat\">\n *   <App />\n * </HashbrownProvider>\n * ```\n */\nconst HashbrownProvider = (\n/**\n * The options for the Hashbrown provider.\n */\nprops) => {\n  const {\n    url,\n    middleware,\n    children\n  } = props;\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HashbrownContext.Provider, {\n    value: {\n      url,\n      middleware\n    },\n    children: children\n  });\n};\n\n/**\n * Connects a Hashbrown Signal to React's reactivity system\n *\n * @param signal - The signal to connect to React\n * @returns The value contained in the signal\n */\nfunction useHashbrownSignal(signal) {\n  const lastValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(signal());\n  const hasSkippedFirstCall = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n  const equality = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((a, b) => (0,_hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵdeepEqual\"])(a, b), []);\n  const read = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    const value = signal();\n    if (!equality(value, lastValue.current)) {\n      lastValue.current = value;\n    }\n    return lastValue.current;\n  }, [signal, equality]);\n  const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(onStoreChange => {\n    let lastRead;\n    const cleanup = signal.subscribe(value => {\n      if (!hasSkippedFirstCall.current) {\n        hasSkippedFirstCall.current = true;\n        return;\n      }\n      const currentValue = read();\n      if (currentValue !== lastRead) {\n        lastRead = currentValue;\n        onStoreChange();\n      }\n    });\n    return () => {\n      cleanup();\n      hasSkippedFirstCall.current = false;\n    };\n  }, [signal, read]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(subscribe, read);\n}\n\n/**\n * This React hook creates a chat instance used to interact with the LLM.\n * The result object contains functions and state enabling you to send and recieve messages and monitor the state of the chat.\n *\n * The `useChat` hook provides the most basic functionality for un-structured chats.  Unstructured chats include things like general chats and natural language controls.\n *\n * @public\n * @returns An object containing chat state and functions to interact with the chat.\n * @typeParam Tools - The set of tool definitions available to the chat.\n * @example\n * This example demonstrates how to use the `useChat` hook to create a simple chat component.\n *\n * ```tsx\n * const MyChatComponent = () => {\n *   const { messages, sendMessage, status } = useChat({\n *     model: 'gpt-4o',\n *     system: 'You are a helpful assistant.',\n *     tools: [],\n *   });\n *\n *   const handleSendMessage = () => {\n *     sendMessage({ role: 'user', content: 'Hello, how are you?' });\n *   };\n *\n *   return (\n *     <div>\n *       <button onClick={handleSendMessage}>Send Message</button>\n *       <div>Status: {status}</div>\n *       <ul>\n *         {messages.map((msg, index) => (\n *           <li key={index}>{msg.content}</li>\n *         ))}\n *       </ul>\n *     </div>\n *   );\n * };\n * ```\n */\nfunction useChat(\n/**\n * The options for the chat.\n */\noptions) {\n  var _a;\n  const tools = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    var _a;\n    return (_a = options.tools) !== null && _a !== void 0 ? _a : [];\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  (_a = options.tools) !== null && _a !== void 0 ? _a : []);\n  const config = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(HashbrownContext);\n  if (!config) {\n    throw new Error('HashbrownContext not found');\n  }\n  const hashbrownRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  if (!hashbrownRef.current) {\n    hashbrownRef.current = (0,_hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__.fryHashbrown)({\n      apiUrl: config.url,\n      middleware: config.middleware,\n      debugName: options.debugName,\n      model: options.model,\n      system: options.system,\n      tools,\n      debounce: options.debounceTime,\n      retries: options.retries\n    });\n  }\n  function getHashbrown() {\n    const instance = hashbrownRef.current;\n    if (!instance) {\n      throw new Error('Hashbrown not found');\n    }\n    return instance;\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    return getHashbrown().sizzle();\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    getHashbrown().updateOptions({\n      apiUrl: config.url,\n      middleware: config.middleware,\n      debugName: options.debugName,\n      model: options.model,\n      system: options.system,\n      tools,\n      debounce: options.debounceTime,\n      retries: options.retries\n    });\n  }, [config.url, config.middleware, options.debounceTime, options.debugName, options.model, options.retries, options.system, tools]);\n  const internalMessages = useHashbrownSignal(getHashbrown().messages);\n  const isReceiving = useHashbrownSignal(getHashbrown().isReceiving);\n  const isSending = useHashbrownSignal(getHashbrown().isSending);\n  const isRunningToolCalls = useHashbrownSignal(getHashbrown().isRunningToolCalls);\n  const exhaustedRetries = useHashbrownSignal(getHashbrown().exhaustedRetries);\n  const error = useHashbrownSignal(getHashbrown().error);\n  const lastAssistantMessage = useHashbrownSignal(getHashbrown().lastAssistantMessage);\n  const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(message => {\n    getHashbrown().sendMessage(message);\n  }, []);\n  const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(messages => {\n    getHashbrown().setMessages(messages);\n  }, []);\n  const reload = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    const lastMessage = internalMessages[internalMessages.length - 1];\n    if (lastMessage.role === 'assistant') {\n      getHashbrown().setMessages(internalMessages.slice(0, -1));\n      return true;\n    }\n    return false;\n  }, [internalMessages]);\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((clearStreamingMessage = false) => {\n    getHashbrown().stop(clearStreamingMessage);\n  }, []);\n  return {\n    messages: internalMessages,\n    sendMessage,\n    setMessages,\n    stop,\n    reload,\n    error,\n    isReceiving,\n    isSending,\n    isRunningToolCalls,\n    exhaustedRetries,\n    lastAssistantMessage\n  };\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * This React hook creates a change instance used to interact with the LLM.\n * The result object contains functions and state enabling you to send and recieve messages and monitor the state of the chat.\n *\n * @public\n * @remarks\n * The `useCompletion` hook provides functionality for completing unstructured inputs with predicted unstructured outputs.  This is useful for things like natural language autocompletions.\n *\n * @example\n * ```ts\n * const { output } = useCompletion({\n *   model: 'gpt-4o-mini',\n *   input: firstName,\n *   system: `Help the user generate a last name for the given first name.`,\n * });\n * ```\n */\nfunction useCompletion(\n/**\n * The options to configure the completion chat.\n */\noptions) {\n  const _a = useChat(Object.assign({}, options)),\n    {\n      setMessages\n    } = _a,\n    chat = __rest(_a, [\"setMessages\"]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!options.input) return;\n    setMessages([{\n      role: 'user',\n      content: options.input\n    }]);\n  }, [setMessages, options.input]);\n  const output = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    const message = chat.messages.find(message => message.role === 'assistant' && !(message.toolCalls && message.toolCalls.length) && message.content);\n    if (!message) return null;\n    if (typeof message.content !== 'string') return null;\n    return message.content;\n  }, [chat.messages]);\n  return {\n    output,\n    reload: chat.reload,\n    error: chat.error,\n    isReceiving: chat.isReceiving,\n    isSending: chat.isSending,\n    isRunningToolCalls: chat.isRunningToolCalls,\n    exhaustedRetries: chat.exhaustedRetries\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Creates a new runtime.\n *\n * @param options - The options for creating the runtime.\n * @returns A reference to the runtime.\n *\n * @public\n */\nfunction useRuntime(options) {\n  var _a;\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const functions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => options.functions, (_a = options.functions) !== null && _a !== void 0 ? _a : []);\n  const runtime = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => (0,_hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵcreateRuntimeImpl\"])({\n    functions,\n    timeout: options.timeout\n  }), [functions, options.timeout]);\n  return runtime;\n}\n\n/* eslint-disable no-redeclare */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * @public\n */\nfunction useRuntimeFunction(cfg) {\n  const argsSchemaRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)('args' in cfg ? cfg.args : undefined);\n  const resultSchemaRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)('result' in cfg ? cfg.result : undefined);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const handler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(cfg.handler, cfg.deps);\n  const fn = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return (0,_hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵcreateRuntimeFunctionImpl\"])({\n      args: argsSchemaRef.current,\n      result: resultSchemaRef.current,\n      handler,\n      name: cfg.name,\n      description: cfg.description\n    });\n  }, [handler, cfg.name, cfg.description]);\n  return fn;\n}\n\n/**\n * This React hook creates a chat instance used to interact with the LLM.\n * The result object contains functions and state enabling you to send and receive messages and monitor the state of the chat.\n *\n * @public\n * @remarks\n * The `useStructuredChat` hook provides functionality for structured chats. Structured chats are used when you want to use the LLM to generate structured data according to a defined schema. This is particularly useful for:\n * - Generating typed data structures\n * - Creating form responses\n * - Building UI components\n * - Extracting information into a specific format\n *\n * @returns An object containing chat state and functions to interact with the chat.\n *\n * @example\n * In this example, the LLM will respond with a JSON object containing the translations of the input message into English, Spanish, and French.\n * ```tsx\n * const { messages, sendMessage } = useStructuredChat({\n *   model: 'gpt-4o',\n *   system: 'You are a helpful translator that provides accurate translations.',\n *   schema: s.object('Translations', {\n *     english: s.string('English translation'),\n *     spanish: s.string('Spanish translation'),\n *     french: s.string('French translation')\n *   }),\n * });\n * ```\n */\nfunction useStructuredChat(options) {\n  var _a;\n  const config = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(HashbrownContext);\n  if (!config) {\n    throw new Error('HashbrownContext not found');\n  }\n  const tools = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    var _a;\n    return (_a = options.tools) !== null && _a !== void 0 ? _a : [];\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  (_a = options.tools) !== null && _a !== void 0 ? _a : []);\n  const [schema] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(options.schema);\n  const hashbrown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  if (!hashbrown.current) {\n    hashbrown.current = (0,_hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__.fryHashbrown)({\n      apiUrl: config.url,\n      middleware: config.middleware,\n      model: options.model,\n      system: options.system,\n      responseSchema: schema,\n      tools,\n      debugName: options.debugName,\n      debounce: options.debounceTime,\n      retries: options.retries\n    });\n  }\n  function getHashbrown() {\n    const instance = hashbrown.current;\n    if (!instance) {\n      throw new Error('Hashbrown not found');\n    }\n    return instance;\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    return getHashbrown().sizzle();\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    getHashbrown().updateOptions({\n      apiUrl: config.url,\n      middleware: config.middleware,\n      model: options.model,\n      system: options.system,\n      responseSchema: schema,\n      tools,\n      debugName: options.debugName,\n      debounce: options.debounceTime,\n      retries: options.retries\n    });\n  }, [config.url, config.middleware, options.model, options.system, options.debugName, schema, tools, options.debounceTime, options.retries]);\n  const internalMessages = useHashbrownSignal(hashbrown.current.messages);\n  const isReceiving = useHashbrownSignal(hashbrown.current.isReceiving);\n  const isSending = useHashbrownSignal(hashbrown.current.isSending);\n  const isRunningToolCalls = useHashbrownSignal(hashbrown.current.isRunningToolCalls);\n  const exhaustedRetries = useHashbrownSignal(hashbrown.current.exhaustedRetries);\n  const error = useHashbrownSignal(hashbrown.current.error);\n  const lastAssistantMessage = useHashbrownSignal(hashbrown.current.lastAssistantMessage);\n  const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(message => {\n    getHashbrown().sendMessage(message);\n  }, []);\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((clearStreamingMessage = false) => {\n    getHashbrown().stop(clearStreamingMessage);\n  }, []);\n  const resendMessages = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    getHashbrown().resendMessages();\n  }, []);\n  const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(messages => {\n    getHashbrown().setMessages(messages);\n  }, []);\n  const reload = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    const lastMessage = internalMessages[internalMessages.length - 1];\n    if (lastMessage.role === 'assistant') {\n      getHashbrown().setMessages(internalMessages.slice(0, -1));\n      return true;\n    }\n    return false;\n  }, [internalMessages]);\n  return {\n    messages: internalMessages,\n    stop,\n    sendMessage,\n    resendMessages,\n    setMessages,\n    reload,\n    error,\n    isReceiving,\n    isSending,\n    isRunningToolCalls,\n    exhaustedRetries,\n    lastAssistantMessage\n  };\n}\n\n/**\n * This React hook creates a completion instance that predicts structured data based on input context.\n * The result object contains the predicted structured output and state for monitoring the completion.\n *\n * @public\n * @typeParam Input - The type of the input to predict from.\n * @typeParam Schema - The schema to use for the chat.\n * @remarks\n * The `useStructuredCompletion` hook provides functionality for predicting structured data based on input context. This is particularly useful for:\n * - Smart form field suggestions\n * - Context-aware recommendations\n * - Predictive UI generation\n * - Intelligent defaults\n *\n * @returns An object containing the predicted structured output and completion state.\n *\n * @example\n * In this example, the LLM will predict a color palette based on a given theme or mood.\n * ```tsx\n * const { output } = useStructuredCompletion({\n *   model: 'gpt-4o',\n *   system: `Predict a color palette based on the given mood or theme. For example,\n *   if the theme is \"Calm Ocean\", suggest appropriate colors.`,\n *   input: theme,\n *   schema: s.object('Color Palette', {\n *     colors: s.array(\n *       'The colors in the palette',\n *       s.string('Hex color code')\n *     )\n *   })\n * });\n * ```\n */\nfunction useStructuredCompletion(options) {\n  const _a = useStructuredChat(Object.assign({}, options)),\n    {\n      setMessages\n    } = _a,\n    chat = __rest(_a, [\"setMessages\"]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!options.input) return;\n    setMessages([{\n      role: 'user',\n      content: options.input\n    }]);\n  }, [setMessages, options.input]);\n  const output = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    const message = chat.messages.find(message => message.role === 'assistant' && message.content);\n    if (!message) return null;\n    return message.content;\n  }, [chat.messages]);\n  return {\n    output,\n    reload: chat.reload,\n    error: chat.error,\n    isReceiving: chat.isReceiving,\n    isSending: chat.isSending,\n    isRunningToolCalls: chat.isRunningToolCalls,\n    exhaustedRetries: chat.exhaustedRetries\n  };\n}\n\n/* eslint no-redeclare: off */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * @public\n */\nfunction useTool(input) {\n  const {\n    name,\n    description,\n    handler,\n    deps\n  } = input;\n  // assumes the schema will never change\n  const [schema] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('schema' in input ? input.schema : _hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__.s.object('Empty schema', {}));\n  // assumes the handler should only change if its deps change,\n  //   which enables the use of anonymous functions in the handler.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const stableHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(handler, deps);\n  const tool = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return {\n      name,\n      description,\n      schema,\n      handler: stableHandler\n    };\n  }, [name, description, schema, stableHandler]);\n  return tool;\n}\n\n/**\n * Creates a tool that allows the LLM to run JavaScript code. It is run\n * in a stateful JavaScript environment, with no access to the internet, the DOM,\n * or any function that you have not explicitly defined.\n *\n * @public\n * @param options - The options for creating the tool.\n * @returns The tool.\n */\nfunction useToolJavaScript({\n  runtime\n}) {\n  return useTool({\n    name: 'javascript',\n    description: ['Whenever you send a message containing JavaScript code to javascript, it will be', 'executed in a stateful JavaScript environment. javascript will respond with the output', `of the execution or time out after ${runtime.timeout / 1000} seconds. Internet access`, 'for this session is disabled. Do not make external web requests or API calls as they', 'will fail.', '', 'Important: Prefer calling javascript once with a large amount of code, rather than calling it', 'multiple times with smaller amounts of code.', '', 'The following functions are available to you:', runtime.describe()].join('\\n'),\n    schema: _hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__.s.streaming.object('The result', {\n      code: _hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__.s.streaming.string('The JavaScript code to run')\n    }),\n    deps: [runtime],\n    handler: (_a, abortSignal_1) => __awaiter(this, [_a, abortSignal_1], void 0, function* ({\n      code\n    }, abortSignal) {\n      return runtime.run(code, abortSignal);\n    })\n  });\n}\n\n/**\n * This React hook creates a chat instance that can generate and render UI components.\n * The result object contains functions and state enabling you to send and receive messages and monitor the state of the chat.\n *\n * @public\n * @typeParam Tools - The set of tool definitions available to the chat.\n * @remarks\n * The `useUiChat` hook provides functionality for generating UI components through chat. This is particularly useful for:\n * - Dynamic UI generation\n * - Interactive chat interfaces\n * - Component-based responses\n * - Building chat-based UIs\n *\n * @returns An object containing chat state, functions to interact with the chat, and rendered UI components.\n *\n * @example\n * In this example, the LLM will respond with a UI component that can be rendered directly in your React application.\n * ```tsx\n * const { messages, sendMessage } = useUiChat({\n *   model: 'gpt-4o',\n *   system: 'You are a helpful assistant that can generate UI components.',\n *   components: [\n *     exposeComponent(Button, {\n *       name: 'Button',\n *       description: 'A clickable button component',\n *       props: {\n *         label: s.string('The text to display on the button'),\n *         onClick: s.function('Function to call when clicked')\n *       }\n *     })\n *   ]\n * });\n * ```\n */\nconst useUiChat = options => {\n  const {\n      components: initialComponents\n    } = options,\n    chatOptions = __rest(options, [\"components\"]);\n  const [components, setComponents] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialComponents);\n  const [flattenedComponents] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵui\"].flattenComponents(initialComponents));\n  const ui = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__.s.object('UI', {\n      ui: _hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__.s.streaming.array('List of elements', _hashbrownai_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵui\"].createComponentSchema(components))\n    });\n  }, [components]);\n  const systemAsString = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    if (typeof chatOptions.system === 'string') {\n      return chatOptions.system;\n    }\n    const output = chatOptions.system.compile(components, ui);\n    if (chatOptions.system.diagnostics.length > 0) {\n      throw new Error(`System prompt has ${chatOptions.system.diagnostics.length} errors: \\n\\n${chatOptions.system.diagnostics.map(d => d.message).join('\\n\\n')}`);\n    }\n    return output;\n  }, [chatOptions.system, components, ui]);\n  const chat = useStructuredChat(Object.assign(Object.assign({}, chatOptions), {\n    schema: ui,\n    system: systemAsString\n  }));\n  const buildContent = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((nodes, parentKey = '') => {\n    if (typeof nodes === 'string') {\n      return nodes;\n    }\n    const elements = nodes.map((element, index) => {\n      var _a;\n      const key = `${parentKey}_${index}`;\n      const {\n        $tag,\n        $children,\n        $props\n      } = element;\n      const componentType = (_a = flattenedComponents.get($tag)) === null || _a === void 0 ? void 0 : _a.component;\n      if ($tag && componentType) {\n        const children = element.$children ? buildContent($children, key) : null;\n        return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(componentType, Object.assign(Object.assign({}, $props), {\n          children,\n          key\n        }));\n      }\n      throw new Error(`Unknown element type. ${$tag}`);\n    });\n    return elements;\n  }, [flattenedComponents]);\n  const uiChatMessages = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return chat.messages.map(message => {\n      var _a;\n      if (message.role === 'assistant') {\n        return Object.assign(Object.assign({}, message), {\n          ui: ((_a = message.content) === null || _a === void 0 ? void 0 : _a.ui) ? buildContent(message.content.ui) : null\n        });\n      }\n      return message;\n    });\n  }, [buildContent, chat.messages]);\n  const lastAssistantMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return uiChatMessages.findLast(message => message.role === 'assistant');\n  }, [uiChatMessages]);\n  return Object.assign(Object.assign({}, chat), {\n    messages: uiChatMessages,\n    setComponents,\n    lastAssistantMessage\n  });\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaGFzaGJyb3duYWkrcmVhY3RAMC4zLjBfQGhhc2hicm93bmFpK2NvcmVAMC4zLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvQGhhc2hicm93bmFpL3JlYWN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQUNrRztBQUNvRDs7QUFFOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsc0NBQXNDLG9EQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osU0FBUyxzREFBRztBQUNaO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBTTtBQUMxQiw4QkFBOEIsNkNBQU07QUFDcEMsbUJBQW1CLGtEQUFXLFdBQVcsZ0VBQVU7QUFDbkQsZUFBZSxrREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9CQUFvQixrREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0NBQXNDLCtDQUFRO0FBQzlDLGdDQUFnQywrQ0FBUSxDQUFDLHFEQUFHO0FBQzVDLGFBQWEsOENBQU87QUFDcEIsV0FBVyxnREFBQztBQUNaLFVBQVUsZ0RBQUMscUNBQXFDLHFEQUFHO0FBQ25ELEtBQUs7QUFDTCxHQUFHO0FBQ0gseUJBQXlCLDhDQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUNBQXVDLGNBQWMsZ0VBQWdFO0FBQ2hLO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLGtEQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVSxHQUFHLE1BQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFhLDhDQUE4QztBQUN2RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILHlCQUF5Qiw4Q0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsK0JBQStCLDhDQUFPO0FBQ3RDO0FBQ0EsR0FBRztBQUNILHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRXlMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaGFzaGJyb3duYWkrcmVhY3RAMC4zLjBfQGhhc2hicm93bmFpK2NvcmVAMC4zLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvQGhhc2hicm93bmFpL3JlYWN0L2luZGV4LmVzbS5qcz85ZDRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZVN5bmNFeHRlcm5hbFN0b3JlLCB1c2VNZW1vLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgybVkZWVwRXF1YWwgYXMgX2RlZXBFcXVhbCwgZnJ5SGFzaGJyb3duLCDJtWNyZWF0ZVJ1bnRpbWVJbXBsIGFzIF9jcmVhdGVSdW50aW1lSW1wbCwgybVjcmVhdGVSdW50aW1lRnVuY3Rpb25JbXBsIGFzIF9jcmVhdGVSdW50aW1lRnVuY3Rpb25JbXBsLCBzLCDJtXVpIGFzIF91aSB9IGZyb20gJ0BoYXNoYnJvd25haS9jb3JlJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB1c2VkIHRvIGV4cG9zZSBhIGNvbXBvbmVudCBmb3IgdXNlIGJ5IHRoZSBMTE0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBleHBvc2VDb21wb25lbnQoXG4gKiAgIENhcmRDb21wb25lbnQsIC8vIFRoZSBSZWFjdCBjb21wb25lbnQgdG8gYmUgZXhwb3NlZC5cbiAqICAgeyAvLyBUaGUgZXhwb3NlZCBjb21wb25lbnQgY29uZmlndXJhdGlvbi5cbiAqICAgICBuYW1lOiAnQ2FyZENvbXBvbmVudCcsXG4gKiAgICAgZGVzY3JpcHRpb246ICdTaG93IGEgY2FyZCB3aXRoIGNoaWxkcmVuIGNvbXBvbmVudHMgdG8gdGhlIHVzZXInLFxuICogICAgIGNoaWxkcmVuOiAnYW55JyxcbiAqICAgICBwcm9wczoge1xuICogICAgICAgdGl0bGU6IHMuc3RyaW5nKCdUaGUgdGl0bGUgb2YgdGhlIGNhcmQnKSxcbiAqICAgICAgIGRlc2NyaXB0aW9uOiBzLnN0cmVhbWluZy5zdHJpbmcoJ1RoZSBkZXNjcmlwdGlvbiBvZiB0aGUgY2FyZCcpLFxuICogICAgIH0sXG4gKiAgIH0sXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudCBpbiBvcmRlciB0byBleHBvc2UgaXQgdG8gdGhlIExMTS5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZXhwb3NlQ29tcG9uZW50KFxuLyoqXG4gKiBUaGUgY29tcG9uZW50IHRvIGJlIGV4cG9zZWQuXG4gKi9cbmNvbXBvbmVudCxcbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgY29tcG9uZW50LCBleGNsdWRpbmcgdGhlIGNvbXBvbmVudCBpdHNlbGYuXG4gKi9cbmNvbmZpZykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgY29tcG9uZW50XG4gIH0sIGNvbmZpZyk7XG59XG5cbmNvbnN0IEhhc2hicm93bkNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuLyoqXG4gKiBUaGUgY29udGV4dCBmb3IgdGhlIEhhc2hicm93biBwcm92aWRlci4gIFRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgVVJMIGFuZCBtaWRkbGV3YXJlIGZvciBjb250YWN0aW5nIHRoZSBIYXNoYnJvd24gZW5kcG9pbnQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiA8SGFzaGJyb3duUHJvdmlkZXIgdXJsPVwiaHR0cHM6Ly95b3VyLmFwaS5sb2NhbC9jaGF0XCI+XG4gKiAgIDxBcHAgLz5cbiAqIDwvSGFzaGJyb3duUHJvdmlkZXI+XG4gKiBgYGBcbiAqL1xuY29uc3QgSGFzaGJyb3duUHJvdmlkZXIgPSAoXG4vKipcbiAqIFRoZSBvcHRpb25zIGZvciB0aGUgSGFzaGJyb3duIHByb3ZpZGVyLlxuICovXG5wcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgdXJsLFxuICAgIG1pZGRsZXdhcmUsXG4gICAgY2hpbGRyZW5cbiAgfSA9IHByb3BzO1xuICByZXR1cm4ganN4KEhhc2hicm93bkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgdXJsLFxuICAgICAgbWlkZGxld2FyZVxuICAgIH0sXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb25uZWN0cyBhIEhhc2hicm93biBTaWduYWwgdG8gUmVhY3QncyByZWFjdGl2aXR5IHN5c3RlbVxuICpcbiAqIEBwYXJhbSBzaWduYWwgLSBUaGUgc2lnbmFsIHRvIGNvbm5lY3QgdG8gUmVhY3RcbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIHNpZ25hbFxuICovXG5mdW5jdGlvbiB1c2VIYXNoYnJvd25TaWduYWwoc2lnbmFsKSB7XG4gIGNvbnN0IGxhc3RWYWx1ZSA9IHVzZVJlZihzaWduYWwoKSk7XG4gIGNvbnN0IGhhc1NraXBwZWRGaXJzdENhbGwgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBlcXVhbGl0eSA9IHVzZUNhbGxiYWNrKChhLCBiKSA9PiBfZGVlcEVxdWFsKGEsIGIpLCBbXSk7XG4gIGNvbnN0IHJlYWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzaWduYWwoKTtcbiAgICBpZiAoIWVxdWFsaXR5KHZhbHVlLCBsYXN0VmFsdWUuY3VycmVudCkpIHtcbiAgICAgIGxhc3RWYWx1ZS5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBsYXN0VmFsdWUuY3VycmVudDtcbiAgfSwgW3NpZ25hbCwgZXF1YWxpdHldKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2sob25TdG9yZUNoYW5nZSA9PiB7XG4gICAgbGV0IGxhc3RSZWFkO1xuICAgIGNvbnN0IGNsZWFudXAgPSBzaWduYWwuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgIGlmICghaGFzU2tpcHBlZEZpcnN0Q2FsbC5jdXJyZW50KSB7XG4gICAgICAgIGhhc1NraXBwZWRGaXJzdENhbGwuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHJlYWQoKTtcbiAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IGxhc3RSZWFkKSB7XG4gICAgICAgIGxhc3RSZWFkID0gY3VycmVudFZhbHVlO1xuICAgICAgICBvblN0b3JlQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIGhhc1NraXBwZWRGaXJzdENhbGwuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtzaWduYWwsIHJlYWRdKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgcmVhZCk7XG59XG5cbi8qKlxuICogVGhpcyBSZWFjdCBob29rIGNyZWF0ZXMgYSBjaGF0IGluc3RhbmNlIHVzZWQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgTExNLlxuICogVGhlIHJlc3VsdCBvYmplY3QgY29udGFpbnMgZnVuY3Rpb25zIGFuZCBzdGF0ZSBlbmFibGluZyB5b3UgdG8gc2VuZCBhbmQgcmVjaWV2ZSBtZXNzYWdlcyBhbmQgbW9uaXRvciB0aGUgc3RhdGUgb2YgdGhlIGNoYXQuXG4gKlxuICogVGhlIGB1c2VDaGF0YCBob29rIHByb3ZpZGVzIHRoZSBtb3N0IGJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIHVuLXN0cnVjdHVyZWQgY2hhdHMuICBVbnN0cnVjdHVyZWQgY2hhdHMgaW5jbHVkZSB0aGluZ3MgbGlrZSBnZW5lcmFsIGNoYXRzIGFuZCBuYXR1cmFsIGxhbmd1YWdlIGNvbnRyb2xzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIGNoYXQgc3RhdGUgYW5kIGZ1bmN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBjaGF0LlxuICogQHR5cGVQYXJhbSBUb29scyAtIFRoZSBzZXQgb2YgdG9vbCBkZWZpbml0aW9ucyBhdmFpbGFibGUgdG8gdGhlIGNoYXQuXG4gKiBAZXhhbXBsZVxuICogVGhpcyBleGFtcGxlIGRlbW9uc3RyYXRlcyBob3cgdG8gdXNlIHRoZSBgdXNlQ2hhdGAgaG9vayB0byBjcmVhdGUgYSBzaW1wbGUgY2hhdCBjb21wb25lbnQuXG4gKlxuICogYGBgdHN4XG4gKiBjb25zdCBNeUNoYXRDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IHsgbWVzc2FnZXMsIHNlbmRNZXNzYWdlLCBzdGF0dXMgfSA9IHVzZUNoYXQoe1xuICogICAgIG1vZGVsOiAnZ3B0LTRvJyxcbiAqICAgICBzeXN0ZW06ICdZb3UgYXJlIGEgaGVscGZ1bCBhc3Npc3RhbnQuJyxcbiAqICAgICB0b29sczogW10sXG4gKiAgIH0pO1xuICpcbiAqICAgY29uc3QgaGFuZGxlU2VuZE1lc3NhZ2UgPSAoKSA9PiB7XG4gKiAgICAgc2VuZE1lc3NhZ2UoeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6ICdIZWxsbywgaG93IGFyZSB5b3U/JyB9KTtcbiAqICAgfTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU2VuZE1lc3NhZ2V9PlNlbmQgTWVzc2FnZTwvYnV0dG9uPlxuICogICAgICAgPGRpdj5TdGF0dXM6IHtzdGF0dXN9PC9kaXY+XG4gKiAgICAgICA8dWw+XG4gKiAgICAgICAgIHttZXNzYWdlcy5tYXAoKG1zZywgaW5kZXgpID0+IChcbiAqICAgICAgICAgICA8bGkga2V5PXtpbmRleH0+e21zZy5jb250ZW50fTwvbGk+XG4gKiAgICAgICAgICkpfVxuICogICAgICAgPC91bD5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH07XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlQ2hhdChcbi8qKlxuICogVGhlIG9wdGlvbnMgZm9yIHRoZSBjaGF0LlxuICovXG5vcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgdG9vbHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IG9wdGlvbnMudG9vbHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIChfYSA9IG9wdGlvbnMudG9vbHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKTtcbiAgY29uc3QgY29uZmlnID0gdXNlQ29udGV4dChIYXNoYnJvd25Db250ZXh0KTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2hicm93bkNvbnRleHQgbm90IGZvdW5kJyk7XG4gIH1cbiAgY29uc3QgaGFzaGJyb3duUmVmID0gdXNlUmVmKG51bGwpO1xuICBpZiAoIWhhc2hicm93blJlZi5jdXJyZW50KSB7XG4gICAgaGFzaGJyb3duUmVmLmN1cnJlbnQgPSBmcnlIYXNoYnJvd24oe1xuICAgICAgYXBpVXJsOiBjb25maWcudXJsLFxuICAgICAgbWlkZGxld2FyZTogY29uZmlnLm1pZGRsZXdhcmUsXG4gICAgICBkZWJ1Z05hbWU6IG9wdGlvbnMuZGVidWdOYW1lLFxuICAgICAgbW9kZWw6IG9wdGlvbnMubW9kZWwsXG4gICAgICBzeXN0ZW06IG9wdGlvbnMuc3lzdGVtLFxuICAgICAgdG9vbHMsXG4gICAgICBkZWJvdW5jZTogb3B0aW9ucy5kZWJvdW5jZVRpbWUsXG4gICAgICByZXRyaWVzOiBvcHRpb25zLnJldHJpZXNcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRIYXNoYnJvd24oKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBoYXNoYnJvd25SZWYuY3VycmVudDtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2hicm93biBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGdldEhhc2hicm93bigpLnNpenpsZSgpO1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZ2V0SGFzaGJyb3duKCkudXBkYXRlT3B0aW9ucyh7XG4gICAgICBhcGlVcmw6IGNvbmZpZy51cmwsXG4gICAgICBtaWRkbGV3YXJlOiBjb25maWcubWlkZGxld2FyZSxcbiAgICAgIGRlYnVnTmFtZTogb3B0aW9ucy5kZWJ1Z05hbWUsXG4gICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgIHN5c3RlbTogb3B0aW9ucy5zeXN0ZW0sXG4gICAgICB0b29scyxcbiAgICAgIGRlYm91bmNlOiBvcHRpb25zLmRlYm91bmNlVGltZSxcbiAgICAgIHJldHJpZXM6IG9wdGlvbnMucmV0cmllc1xuICAgIH0pO1xuICB9LCBbY29uZmlnLnVybCwgY29uZmlnLm1pZGRsZXdhcmUsIG9wdGlvbnMuZGVib3VuY2VUaW1lLCBvcHRpb25zLmRlYnVnTmFtZSwgb3B0aW9ucy5tb2RlbCwgb3B0aW9ucy5yZXRyaWVzLCBvcHRpb25zLnN5c3RlbSwgdG9vbHNdKTtcbiAgY29uc3QgaW50ZXJuYWxNZXNzYWdlcyA9IHVzZUhhc2hicm93blNpZ25hbChnZXRIYXNoYnJvd24oKS5tZXNzYWdlcyk7XG4gIGNvbnN0IGlzUmVjZWl2aW5nID0gdXNlSGFzaGJyb3duU2lnbmFsKGdldEhhc2hicm93bigpLmlzUmVjZWl2aW5nKTtcbiAgY29uc3QgaXNTZW5kaW5nID0gdXNlSGFzaGJyb3duU2lnbmFsKGdldEhhc2hicm93bigpLmlzU2VuZGluZyk7XG4gIGNvbnN0IGlzUnVubmluZ1Rvb2xDYWxscyA9IHVzZUhhc2hicm93blNpZ25hbChnZXRIYXNoYnJvd24oKS5pc1J1bm5pbmdUb29sQ2FsbHMpO1xuICBjb25zdCBleGhhdXN0ZWRSZXRyaWVzID0gdXNlSGFzaGJyb3duU2lnbmFsKGdldEhhc2hicm93bigpLmV4aGF1c3RlZFJldHJpZXMpO1xuICBjb25zdCBlcnJvciA9IHVzZUhhc2hicm93blNpZ25hbChnZXRIYXNoYnJvd24oKS5lcnJvcik7XG4gIGNvbnN0IGxhc3RBc3Npc3RhbnRNZXNzYWdlID0gdXNlSGFzaGJyb3duU2lnbmFsKGdldEhhc2hicm93bigpLmxhc3RBc3Npc3RhbnRNZXNzYWdlKTtcbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSB1c2VDYWxsYmFjayhtZXNzYWdlID0+IHtcbiAgICBnZXRIYXNoYnJvd24oKS5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgfSwgW10pO1xuICBjb25zdCBzZXRNZXNzYWdlcyA9IHVzZUNhbGxiYWNrKG1lc3NhZ2VzID0+IHtcbiAgICBnZXRIYXNoYnJvd24oKS5zZXRNZXNzYWdlcyhtZXNzYWdlcyk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVsb2FkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gaW50ZXJuYWxNZXNzYWdlc1tpbnRlcm5hbE1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0TWVzc2FnZS5yb2xlID09PSAnYXNzaXN0YW50Jykge1xuICAgICAgZ2V0SGFzaGJyb3duKCkuc2V0TWVzc2FnZXMoaW50ZXJuYWxNZXNzYWdlcy5zbGljZSgwLCAtMSkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgW2ludGVybmFsTWVzc2FnZXNdKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKChjbGVhclN0cmVhbWluZ01lc3NhZ2UgPSBmYWxzZSkgPT4ge1xuICAgIGdldEhhc2hicm93bigpLnN0b3AoY2xlYXJTdHJlYW1pbmdNZXNzYWdlKTtcbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBpbnRlcm5hbE1lc3NhZ2VzLFxuICAgIHNlbmRNZXNzYWdlLFxuICAgIHNldE1lc3NhZ2VzLFxuICAgIHN0b3AsXG4gICAgcmVsb2FkLFxuICAgIGVycm9yLFxuICAgIGlzUmVjZWl2aW5nLFxuICAgIGlzU2VuZGluZyxcbiAgICBpc1J1bm5pbmdUb29sQ2FsbHMsXG4gICAgZXhoYXVzdGVkUmV0cmllcyxcbiAgICBsYXN0QXNzaXN0YW50TWVzc2FnZVxuICB9O1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbi8qKlxuICogVGhpcyBSZWFjdCBob29rIGNyZWF0ZXMgYSBjaGFuZ2UgaW5zdGFuY2UgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBMTE0uXG4gKiBUaGUgcmVzdWx0IG9iamVjdCBjb250YWlucyBmdW5jdGlvbnMgYW5kIHN0YXRlIGVuYWJsaW5nIHlvdSB0byBzZW5kIGFuZCByZWNpZXZlIG1lc3NhZ2VzIGFuZCBtb25pdG9yIHRoZSBzdGF0ZSBvZiB0aGUgY2hhdC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrc1xuICogVGhlIGB1c2VDb21wbGV0aW9uYCBob29rIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBsZXRpbmcgdW5zdHJ1Y3R1cmVkIGlucHV0cyB3aXRoIHByZWRpY3RlZCB1bnN0cnVjdHVyZWQgb3V0cHV0cy4gIFRoaXMgaXMgdXNlZnVsIGZvciB0aGluZ3MgbGlrZSBuYXR1cmFsIGxhbmd1YWdlIGF1dG9jb21wbGV0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IHsgb3V0cHV0IH0gPSB1c2VDb21wbGV0aW9uKHtcbiAqICAgbW9kZWw6ICdncHQtNG8tbWluaScsXG4gKiAgIGlucHV0OiBmaXJzdE5hbWUsXG4gKiAgIHN5c3RlbTogYEhlbHAgdGhlIHVzZXIgZ2VuZXJhdGUgYSBsYXN0IG5hbWUgZm9yIHRoZSBnaXZlbiBmaXJzdCBuYW1lLmAsXG4gKiB9KTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VDb21wbGV0aW9uKFxuLyoqXG4gKiBUaGUgb3B0aW9ucyB0byBjb25maWd1cmUgdGhlIGNvbXBsZXRpb24gY2hhdC5cbiAqL1xub3B0aW9ucykge1xuICBjb25zdCBfYSA9IHVzZUNoYXQoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpLFxuICAgIHtcbiAgICAgIHNldE1lc3NhZ2VzXG4gICAgfSA9IF9hLFxuICAgIGNoYXQgPSBfX3Jlc3QoX2EsIFtcInNldE1lc3NhZ2VzXCJdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuaW5wdXQpIHJldHVybjtcbiAgICBzZXRNZXNzYWdlcyhbe1xuICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgY29udGVudDogb3B0aW9ucy5pbnB1dFxuICAgIH1dKTtcbiAgfSwgW3NldE1lc3NhZ2VzLCBvcHRpb25zLmlucHV0XSk7XG4gIGNvbnN0IG91dHB1dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjaGF0Lm1lc3NhZ2VzLmZpbmQobWVzc2FnZSA9PiBtZXNzYWdlLnJvbGUgPT09ICdhc3Npc3RhbnQnICYmICEobWVzc2FnZS50b29sQ2FsbHMgJiYgbWVzc2FnZS50b29sQ2FsbHMubGVuZ3RoKSAmJiBtZXNzYWdlLmNvbnRlbnQpO1xuICAgIGlmICghbWVzc2FnZSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgIT09ICdzdHJpbmcnKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gbWVzc2FnZS5jb250ZW50O1xuICB9LCBbY2hhdC5tZXNzYWdlc10pO1xuICByZXR1cm4ge1xuICAgIG91dHB1dCxcbiAgICByZWxvYWQ6IGNoYXQucmVsb2FkLFxuICAgIGVycm9yOiBjaGF0LmVycm9yLFxuICAgIGlzUmVjZWl2aW5nOiBjaGF0LmlzUmVjZWl2aW5nLFxuICAgIGlzU2VuZGluZzogY2hhdC5pc1NlbmRpbmcsXG4gICAgaXNSdW5uaW5nVG9vbENhbGxzOiBjaGF0LmlzUnVubmluZ1Rvb2xDYWxscyxcbiAgICBleGhhdXN0ZWRSZXRyaWVzOiBjaGF0LmV4aGF1c3RlZFJldHJpZXNcbiAgfTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJ1bnRpbWUuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIHJ1bnRpbWUuXG4gKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgcnVudGltZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZVJ1bnRpbWUob3B0aW9ucykge1xuICB2YXIgX2E7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgY29uc3QgZnVuY3Rpb25zID0gdXNlTWVtbygoKSA9PiBvcHRpb25zLmZ1bmN0aW9ucywgKF9hID0gb3B0aW9ucy5mdW5jdGlvbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKTtcbiAgY29uc3QgcnVudGltZSA9IHVzZU1lbW8oKCkgPT4gX2NyZWF0ZVJ1bnRpbWVJbXBsKHtcbiAgICBmdW5jdGlvbnMsXG4gICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0XG4gIH0pLCBbZnVuY3Rpb25zLCBvcHRpb25zLnRpbWVvdXRdKTtcbiAgcmV0dXJuIHJ1bnRpbWU7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZVJ1bnRpbWVGdW5jdGlvbihjZmcpIHtcbiAgY29uc3QgYXJnc1NjaGVtYVJlZiA9IHVzZVJlZignYXJncycgaW4gY2ZnID8gY2ZnLmFyZ3MgOiB1bmRlZmluZWQpO1xuICBjb25zdCByZXN1bHRTY2hlbWFSZWYgPSB1c2VSZWYoJ3Jlc3VsdCcgaW4gY2ZnID8gY2ZnLnJlc3VsdCA6IHVuZGVmaW5lZCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgY29uc3QgaGFuZGxlciA9IHVzZUNhbGxiYWNrKGNmZy5oYW5kbGVyLCBjZmcuZGVwcyk7XG4gIGNvbnN0IGZuID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIF9jcmVhdGVSdW50aW1lRnVuY3Rpb25JbXBsKHtcbiAgICAgIGFyZ3M6IGFyZ3NTY2hlbWFSZWYuY3VycmVudCxcbiAgICAgIHJlc3VsdDogcmVzdWx0U2NoZW1hUmVmLmN1cnJlbnQsXG4gICAgICBoYW5kbGVyLFxuICAgICAgbmFtZTogY2ZnLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogY2ZnLmRlc2NyaXB0aW9uXG4gICAgfSk7XG4gIH0sIFtoYW5kbGVyLCBjZmcubmFtZSwgY2ZnLmRlc2NyaXB0aW9uXSk7XG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBUaGlzIFJlYWN0IGhvb2sgY3JlYXRlcyBhIGNoYXQgaW5zdGFuY2UgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBMTE0uXG4gKiBUaGUgcmVzdWx0IG9iamVjdCBjb250YWlucyBmdW5jdGlvbnMgYW5kIHN0YXRlIGVuYWJsaW5nIHlvdSB0byBzZW5kIGFuZCByZWNlaXZlIG1lc3NhZ2VzIGFuZCBtb25pdG9yIHRoZSBzdGF0ZSBvZiB0aGUgY2hhdC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrc1xuICogVGhlIGB1c2VTdHJ1Y3R1cmVkQ2hhdGAgaG9vayBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzdHJ1Y3R1cmVkIGNoYXRzLiBTdHJ1Y3R1cmVkIGNoYXRzIGFyZSB1c2VkIHdoZW4geW91IHdhbnQgdG8gdXNlIHRoZSBMTE0gdG8gZ2VuZXJhdGUgc3RydWN0dXJlZCBkYXRhIGFjY29yZGluZyB0byBhIGRlZmluZWQgc2NoZW1hLiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yOlxuICogLSBHZW5lcmF0aW5nIHR5cGVkIGRhdGEgc3RydWN0dXJlc1xuICogLSBDcmVhdGluZyBmb3JtIHJlc3BvbnNlc1xuICogLSBCdWlsZGluZyBVSSBjb21wb25lbnRzXG4gKiAtIEV4dHJhY3RpbmcgaW5mb3JtYXRpb24gaW50byBhIHNwZWNpZmljIGZvcm1hdFxuICpcbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIGNoYXQgc3RhdGUgYW5kIGZ1bmN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBjaGF0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBJbiB0aGlzIGV4YW1wbGUsIHRoZSBMTE0gd2lsbCByZXNwb25kIHdpdGggYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSB0cmFuc2xhdGlvbnMgb2YgdGhlIGlucHV0IG1lc3NhZ2UgaW50byBFbmdsaXNoLCBTcGFuaXNoLCBhbmQgRnJlbmNoLlxuICogYGBgdHN4XG4gKiBjb25zdCB7IG1lc3NhZ2VzLCBzZW5kTWVzc2FnZSB9ID0gdXNlU3RydWN0dXJlZENoYXQoe1xuICogICBtb2RlbDogJ2dwdC00bycsXG4gKiAgIHN5c3RlbTogJ1lvdSBhcmUgYSBoZWxwZnVsIHRyYW5zbGF0b3IgdGhhdCBwcm92aWRlcyBhY2N1cmF0ZSB0cmFuc2xhdGlvbnMuJyxcbiAqICAgc2NoZW1hOiBzLm9iamVjdCgnVHJhbnNsYXRpb25zJywge1xuICogICAgIGVuZ2xpc2g6IHMuc3RyaW5nKCdFbmdsaXNoIHRyYW5zbGF0aW9uJyksXG4gKiAgICAgc3BhbmlzaDogcy5zdHJpbmcoJ1NwYW5pc2ggdHJhbnNsYXRpb24nKSxcbiAqICAgICBmcmVuY2g6IHMuc3RyaW5nKCdGcmVuY2ggdHJhbnNsYXRpb24nKVxuICogICB9KSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZVN0cnVjdHVyZWRDaGF0KG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBjb25maWcgPSB1c2VDb250ZXh0KEhhc2hicm93bkNvbnRleHQpO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcignSGFzaGJyb3duQ29udGV4dCBub3QgZm91bmQnKTtcbiAgfVxuICBjb25zdCB0b29scyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gb3B0aW9ucy50b29scykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgKF9hID0gb3B0aW9ucy50b29scykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pO1xuICBjb25zdCBbc2NoZW1hXSA9IHVzZVN0YXRlKG9wdGlvbnMuc2NoZW1hKTtcbiAgY29uc3QgaGFzaGJyb3duID0gdXNlUmVmKG51bGwpO1xuICBpZiAoIWhhc2hicm93bi5jdXJyZW50KSB7XG4gICAgaGFzaGJyb3duLmN1cnJlbnQgPSBmcnlIYXNoYnJvd24oe1xuICAgICAgYXBpVXJsOiBjb25maWcudXJsLFxuICAgICAgbWlkZGxld2FyZTogY29uZmlnLm1pZGRsZXdhcmUsXG4gICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgIHN5c3RlbTogb3B0aW9ucy5zeXN0ZW0sXG4gICAgICByZXNwb25zZVNjaGVtYTogc2NoZW1hLFxuICAgICAgdG9vbHMsXG4gICAgICBkZWJ1Z05hbWU6IG9wdGlvbnMuZGVidWdOYW1lLFxuICAgICAgZGVib3VuY2U6IG9wdGlvbnMuZGVib3VuY2VUaW1lLFxuICAgICAgcmV0cmllczogb3B0aW9ucy5yZXRyaWVzXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SGFzaGJyb3duKCkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gaGFzaGJyb3duLmN1cnJlbnQ7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoYnJvd24gbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBnZXRIYXNoYnJvd24oKS5zaXp6bGUoKTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGdldEhhc2hicm93bigpLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgYXBpVXJsOiBjb25maWcudXJsLFxuICAgICAgbWlkZGxld2FyZTogY29uZmlnLm1pZGRsZXdhcmUsXG4gICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgIHN5c3RlbTogb3B0aW9ucy5zeXN0ZW0sXG4gICAgICByZXNwb25zZVNjaGVtYTogc2NoZW1hLFxuICAgICAgdG9vbHMsXG4gICAgICBkZWJ1Z05hbWU6IG9wdGlvbnMuZGVidWdOYW1lLFxuICAgICAgZGVib3VuY2U6IG9wdGlvbnMuZGVib3VuY2VUaW1lLFxuICAgICAgcmV0cmllczogb3B0aW9ucy5yZXRyaWVzXG4gICAgfSk7XG4gIH0sIFtjb25maWcudXJsLCBjb25maWcubWlkZGxld2FyZSwgb3B0aW9ucy5tb2RlbCwgb3B0aW9ucy5zeXN0ZW0sIG9wdGlvbnMuZGVidWdOYW1lLCBzY2hlbWEsIHRvb2xzLCBvcHRpb25zLmRlYm91bmNlVGltZSwgb3B0aW9ucy5yZXRyaWVzXSk7XG4gIGNvbnN0IGludGVybmFsTWVzc2FnZXMgPSB1c2VIYXNoYnJvd25TaWduYWwoaGFzaGJyb3duLmN1cnJlbnQubWVzc2FnZXMpO1xuICBjb25zdCBpc1JlY2VpdmluZyA9IHVzZUhhc2hicm93blNpZ25hbChoYXNoYnJvd24uY3VycmVudC5pc1JlY2VpdmluZyk7XG4gIGNvbnN0IGlzU2VuZGluZyA9IHVzZUhhc2hicm93blNpZ25hbChoYXNoYnJvd24uY3VycmVudC5pc1NlbmRpbmcpO1xuICBjb25zdCBpc1J1bm5pbmdUb29sQ2FsbHMgPSB1c2VIYXNoYnJvd25TaWduYWwoaGFzaGJyb3duLmN1cnJlbnQuaXNSdW5uaW5nVG9vbENhbGxzKTtcbiAgY29uc3QgZXhoYXVzdGVkUmV0cmllcyA9IHVzZUhhc2hicm93blNpZ25hbChoYXNoYnJvd24uY3VycmVudC5leGhhdXN0ZWRSZXRyaWVzKTtcbiAgY29uc3QgZXJyb3IgPSB1c2VIYXNoYnJvd25TaWduYWwoaGFzaGJyb3duLmN1cnJlbnQuZXJyb3IpO1xuICBjb25zdCBsYXN0QXNzaXN0YW50TWVzc2FnZSA9IHVzZUhhc2hicm93blNpZ25hbChoYXNoYnJvd24uY3VycmVudC5sYXN0QXNzaXN0YW50TWVzc2FnZSk7XG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gdXNlQ2FsbGJhY2sobWVzc2FnZSA9PiB7XG4gICAgZ2V0SGFzaGJyb3duKCkuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKChjbGVhclN0cmVhbWluZ01lc3NhZ2UgPSBmYWxzZSkgPT4ge1xuICAgIGdldEhhc2hicm93bigpLnN0b3AoY2xlYXJTdHJlYW1pbmdNZXNzYWdlKTtcbiAgfSwgW10pO1xuICBjb25zdCByZXNlbmRNZXNzYWdlcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBnZXRIYXNoYnJvd24oKS5yZXNlbmRNZXNzYWdlcygpO1xuICB9LCBbXSk7XG4gIGNvbnN0IHNldE1lc3NhZ2VzID0gdXNlQ2FsbGJhY2sobWVzc2FnZXMgPT4ge1xuICAgIGdldEhhc2hicm93bigpLnNldE1lc3NhZ2VzKG1lc3NhZ2VzKTtcbiAgfSwgW10pO1xuICBjb25zdCByZWxvYWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBpbnRlcm5hbE1lc3NhZ2VzW2ludGVybmFsTWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RNZXNzYWdlLnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICBnZXRIYXNoYnJvd24oKS5zZXRNZXNzYWdlcyhpbnRlcm5hbE1lc3NhZ2VzLnNsaWNlKDAsIC0xKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBbaW50ZXJuYWxNZXNzYWdlc10pO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBpbnRlcm5hbE1lc3NhZ2VzLFxuICAgIHN0b3AsXG4gICAgc2VuZE1lc3NhZ2UsXG4gICAgcmVzZW5kTWVzc2FnZXMsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgcmVsb2FkLFxuICAgIGVycm9yLFxuICAgIGlzUmVjZWl2aW5nLFxuICAgIGlzU2VuZGluZyxcbiAgICBpc1J1bm5pbmdUb29sQ2FsbHMsXG4gICAgZXhoYXVzdGVkUmV0cmllcyxcbiAgICBsYXN0QXNzaXN0YW50TWVzc2FnZVxuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgUmVhY3QgaG9vayBjcmVhdGVzIGEgY29tcGxldGlvbiBpbnN0YW5jZSB0aGF0IHByZWRpY3RzIHN0cnVjdHVyZWQgZGF0YSBiYXNlZCBvbiBpbnB1dCBjb250ZXh0LlxuICogVGhlIHJlc3VsdCBvYmplY3QgY29udGFpbnMgdGhlIHByZWRpY3RlZCBzdHJ1Y3R1cmVkIG91dHB1dCBhbmQgc3RhdGUgZm9yIG1vbml0b3JpbmcgdGhlIGNvbXBsZXRpb24uXG4gKlxuICogQHB1YmxpY1xuICogQHR5cGVQYXJhbSBJbnB1dCAtIFRoZSB0eXBlIG9mIHRoZSBpbnB1dCB0byBwcmVkaWN0IGZyb20uXG4gKiBAdHlwZVBhcmFtIFNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gdXNlIGZvciB0aGUgY2hhdC5cbiAqIEByZW1hcmtzXG4gKiBUaGUgYHVzZVN0cnVjdHVyZWRDb21wbGV0aW9uYCBob29rIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHByZWRpY3Rpbmcgc3RydWN0dXJlZCBkYXRhIGJhc2VkIG9uIGlucHV0IGNvbnRleHQuIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3I6XG4gKiAtIFNtYXJ0IGZvcm0gZmllbGQgc3VnZ2VzdGlvbnNcbiAqIC0gQ29udGV4dC1hd2FyZSByZWNvbW1lbmRhdGlvbnNcbiAqIC0gUHJlZGljdGl2ZSBVSSBnZW5lcmF0aW9uXG4gKiAtIEludGVsbGlnZW50IGRlZmF1bHRzXG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByZWRpY3RlZCBzdHJ1Y3R1cmVkIG91dHB1dCBhbmQgY29tcGxldGlvbiBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogSW4gdGhpcyBleGFtcGxlLCB0aGUgTExNIHdpbGwgcHJlZGljdCBhIGNvbG9yIHBhbGV0dGUgYmFzZWQgb24gYSBnaXZlbiB0aGVtZSBvciBtb29kLlxuICogYGBgdHN4XG4gKiBjb25zdCB7IG91dHB1dCB9ID0gdXNlU3RydWN0dXJlZENvbXBsZXRpb24oe1xuICogICBtb2RlbDogJ2dwdC00bycsXG4gKiAgIHN5c3RlbTogYFByZWRpY3QgYSBjb2xvciBwYWxldHRlIGJhc2VkIG9uIHRoZSBnaXZlbiBtb29kIG9yIHRoZW1lLiBGb3IgZXhhbXBsZSxcbiAqICAgaWYgdGhlIHRoZW1lIGlzIFwiQ2FsbSBPY2VhblwiLCBzdWdnZXN0IGFwcHJvcHJpYXRlIGNvbG9ycy5gLFxuICogICBpbnB1dDogdGhlbWUsXG4gKiAgIHNjaGVtYTogcy5vYmplY3QoJ0NvbG9yIFBhbGV0dGUnLCB7XG4gKiAgICAgY29sb3JzOiBzLmFycmF5KFxuICogICAgICAgJ1RoZSBjb2xvcnMgaW4gdGhlIHBhbGV0dGUnLFxuICogICAgICAgcy5zdHJpbmcoJ0hleCBjb2xvciBjb2RlJylcbiAqICAgICApXG4gKiAgIH0pXG4gKiB9KTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VTdHJ1Y3R1cmVkQ29tcGxldGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IF9hID0gdXNlU3RydWN0dXJlZENoYXQoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpLFxuICAgIHtcbiAgICAgIHNldE1lc3NhZ2VzXG4gICAgfSA9IF9hLFxuICAgIGNoYXQgPSBfX3Jlc3QoX2EsIFtcInNldE1lc3NhZ2VzXCJdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuaW5wdXQpIHJldHVybjtcbiAgICBzZXRNZXNzYWdlcyhbe1xuICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgY29udGVudDogb3B0aW9ucy5pbnB1dFxuICAgIH1dKTtcbiAgfSwgW3NldE1lc3NhZ2VzLCBvcHRpb25zLmlucHV0XSk7XG4gIGNvbnN0IG91dHB1dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjaGF0Lm1lc3NhZ2VzLmZpbmQobWVzc2FnZSA9PiBtZXNzYWdlLnJvbGUgPT09ICdhc3Npc3RhbnQnICYmIG1lc3NhZ2UuY29udGVudCk7XG4gICAgaWYgKCFtZXNzYWdlKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gbWVzc2FnZS5jb250ZW50O1xuICB9LCBbY2hhdC5tZXNzYWdlc10pO1xuICByZXR1cm4ge1xuICAgIG91dHB1dCxcbiAgICByZWxvYWQ6IGNoYXQucmVsb2FkLFxuICAgIGVycm9yOiBjaGF0LmVycm9yLFxuICAgIGlzUmVjZWl2aW5nOiBjaGF0LmlzUmVjZWl2aW5nLFxuICAgIGlzU2VuZGluZzogY2hhdC5pc1NlbmRpbmcsXG4gICAgaXNSdW5uaW5nVG9vbENhbGxzOiBjaGF0LmlzUnVubmluZ1Rvb2xDYWxscyxcbiAgICBleGhhdXN0ZWRSZXRyaWVzOiBjaGF0LmV4aGF1c3RlZFJldHJpZXNcbiAgfTtcbn1cblxuLyogZXNsaW50IG5vLXJlZGVjbGFyZTogb2ZmICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlVG9vbChpbnB1dCkge1xuICBjb25zdCB7XG4gICAgbmFtZSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBoYW5kbGVyLFxuICAgIGRlcHNcbiAgfSA9IGlucHV0O1xuICAvLyBhc3N1bWVzIHRoZSBzY2hlbWEgd2lsbCBuZXZlciBjaGFuZ2VcbiAgY29uc3QgW3NjaGVtYV0gPSB1c2VTdGF0ZSgnc2NoZW1hJyBpbiBpbnB1dCA/IGlucHV0LnNjaGVtYSA6IHMub2JqZWN0KCdFbXB0eSBzY2hlbWEnLCB7fSkpO1xuICAvLyBhc3N1bWVzIHRoZSBoYW5kbGVyIHNob3VsZCBvbmx5IGNoYW5nZSBpZiBpdHMgZGVwcyBjaGFuZ2UsXG4gIC8vICAgd2hpY2ggZW5hYmxlcyB0aGUgdXNlIG9mIGFub255bW91cyBmdW5jdGlvbnMgaW4gdGhlIGhhbmRsZXIuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgY29uc3Qgc3RhYmxlSGFuZGxlciA9IHVzZUNhbGxiYWNrKGhhbmRsZXIsIGRlcHMpO1xuICBjb25zdCB0b29sID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICBkZXNjcmlwdGlvbixcbiAgICAgIHNjaGVtYSxcbiAgICAgIGhhbmRsZXI6IHN0YWJsZUhhbmRsZXJcbiAgICB9O1xuICB9LCBbbmFtZSwgZGVzY3JpcHRpb24sIHNjaGVtYSwgc3RhYmxlSGFuZGxlcl0pO1xuICByZXR1cm4gdG9vbDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdG9vbCB0aGF0IGFsbG93cyB0aGUgTExNIHRvIHJ1biBKYXZhU2NyaXB0IGNvZGUuIEl0IGlzIHJ1blxuICogaW4gYSBzdGF0ZWZ1bCBKYXZhU2NyaXB0IGVudmlyb25tZW50LCB3aXRoIG5vIGFjY2VzcyB0byB0aGUgaW50ZXJuZXQsIHRoZSBET00sXG4gKiBvciBhbnkgZnVuY3Rpb24gdGhhdCB5b3UgaGF2ZSBub3QgZXhwbGljaXRseSBkZWZpbmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSB0b29sLlxuICogQHJldHVybnMgVGhlIHRvb2wuXG4gKi9cbmZ1bmN0aW9uIHVzZVRvb2xKYXZhU2NyaXB0KHtcbiAgcnVudGltZVxufSkge1xuICByZXR1cm4gdXNlVG9vbCh7XG4gICAgbmFtZTogJ2phdmFzY3JpcHQnLFxuICAgIGRlc2NyaXB0aW9uOiBbJ1doZW5ldmVyIHlvdSBzZW5kIGEgbWVzc2FnZSBjb250YWluaW5nIEphdmFTY3JpcHQgY29kZSB0byBqYXZhc2NyaXB0LCBpdCB3aWxsIGJlJywgJ2V4ZWN1dGVkIGluIGEgc3RhdGVmdWwgSmF2YVNjcmlwdCBlbnZpcm9ubWVudC4gamF2YXNjcmlwdCB3aWxsIHJlc3BvbmQgd2l0aCB0aGUgb3V0cHV0JywgYG9mIHRoZSBleGVjdXRpb24gb3IgdGltZSBvdXQgYWZ0ZXIgJHtydW50aW1lLnRpbWVvdXQgLyAxMDAwfSBzZWNvbmRzLiBJbnRlcm5ldCBhY2Nlc3NgLCAnZm9yIHRoaXMgc2Vzc2lvbiBpcyBkaXNhYmxlZC4gRG8gbm90IG1ha2UgZXh0ZXJuYWwgd2ViIHJlcXVlc3RzIG9yIEFQSSBjYWxscyBhcyB0aGV5JywgJ3dpbGwgZmFpbC4nLCAnJywgJ0ltcG9ydGFudDogUHJlZmVyIGNhbGxpbmcgamF2YXNjcmlwdCBvbmNlIHdpdGggYSBsYXJnZSBhbW91bnQgb2YgY29kZSwgcmF0aGVyIHRoYW4gY2FsbGluZyBpdCcsICdtdWx0aXBsZSB0aW1lcyB3aXRoIHNtYWxsZXIgYW1vdW50cyBvZiBjb2RlLicsICcnLCAnVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB0byB5b3U6JywgcnVudGltZS5kZXNjcmliZSgpXS5qb2luKCdcXG4nKSxcbiAgICBzY2hlbWE6IHMuc3RyZWFtaW5nLm9iamVjdCgnVGhlIHJlc3VsdCcsIHtcbiAgICAgIGNvZGU6IHMuc3RyZWFtaW5nLnN0cmluZygnVGhlIEphdmFTY3JpcHQgY29kZSB0byBydW4nKVxuICAgIH0pLFxuICAgIGRlcHM6IFtydW50aW1lXSxcbiAgICBoYW5kbGVyOiAoX2EsIGFib3J0U2lnbmFsXzEpID0+IF9fYXdhaXRlcih0aGlzLCBbX2EsIGFib3J0U2lnbmFsXzFdLCB2b2lkIDAsIGZ1bmN0aW9uKiAoe1xuICAgICAgY29kZVxuICAgIH0sIGFib3J0U2lnbmFsKSB7XG4gICAgICByZXR1cm4gcnVudGltZS5ydW4oY29kZSwgYWJvcnRTaWduYWwpO1xuICAgIH0pXG4gIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgUmVhY3QgaG9vayBjcmVhdGVzIGEgY2hhdCBpbnN0YW5jZSB0aGF0IGNhbiBnZW5lcmF0ZSBhbmQgcmVuZGVyIFVJIGNvbXBvbmVudHMuXG4gKiBUaGUgcmVzdWx0IG9iamVjdCBjb250YWlucyBmdW5jdGlvbnMgYW5kIHN0YXRlIGVuYWJsaW5nIHlvdSB0byBzZW5kIGFuZCByZWNlaXZlIG1lc3NhZ2VzIGFuZCBtb25pdG9yIHRoZSBzdGF0ZSBvZiB0aGUgY2hhdC5cbiAqXG4gKiBAcHVibGljXG4gKiBAdHlwZVBhcmFtIFRvb2xzIC0gVGhlIHNldCBvZiB0b29sIGRlZmluaXRpb25zIGF2YWlsYWJsZSB0byB0aGUgY2hhdC5cbiAqIEByZW1hcmtzXG4gKiBUaGUgYHVzZVVpQ2hhdGAgaG9vayBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBnZW5lcmF0aW5nIFVJIGNvbXBvbmVudHMgdGhyb3VnaCBjaGF0LiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yOlxuICogLSBEeW5hbWljIFVJIGdlbmVyYXRpb25cbiAqIC0gSW50ZXJhY3RpdmUgY2hhdCBpbnRlcmZhY2VzXG4gKiAtIENvbXBvbmVudC1iYXNlZCByZXNwb25zZXNcbiAqIC0gQnVpbGRpbmcgY2hhdC1iYXNlZCBVSXNcbiAqXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyBjaGF0IHN0YXRlLCBmdW5jdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgY2hhdCwgYW5kIHJlbmRlcmVkIFVJIGNvbXBvbmVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIEluIHRoaXMgZXhhbXBsZSwgdGhlIExMTSB3aWxsIHJlc3BvbmQgd2l0aCBhIFVJIGNvbXBvbmVudCB0aGF0IGNhbiBiZSByZW5kZXJlZCBkaXJlY3RseSBpbiB5b3VyIFJlYWN0IGFwcGxpY2F0aW9uLlxuICogYGBgdHN4XG4gKiBjb25zdCB7IG1lc3NhZ2VzLCBzZW5kTWVzc2FnZSB9ID0gdXNlVWlDaGF0KHtcbiAqICAgbW9kZWw6ICdncHQtNG8nLFxuICogICBzeXN0ZW06ICdZb3UgYXJlIGEgaGVscGZ1bCBhc3Npc3RhbnQgdGhhdCBjYW4gZ2VuZXJhdGUgVUkgY29tcG9uZW50cy4nLFxuICogICBjb21wb25lbnRzOiBbXG4gKiAgICAgZXhwb3NlQ29tcG9uZW50KEJ1dHRvbiwge1xuICogICAgICAgbmFtZTogJ0J1dHRvbicsXG4gKiAgICAgICBkZXNjcmlwdGlvbjogJ0EgY2xpY2thYmxlIGJ1dHRvbiBjb21wb25lbnQnLFxuICogICAgICAgcHJvcHM6IHtcbiAqICAgICAgICAgbGFiZWw6IHMuc3RyaW5nKCdUaGUgdGV4dCB0byBkaXNwbGF5IG9uIHRoZSBidXR0b24nKSxcbiAqICAgICAgICAgb25DbGljazogcy5mdW5jdGlvbignRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGNsaWNrZWQnKVxuICogICAgICAgfVxuICogICAgIH0pXG4gKiAgIF1cbiAqIH0pO1xuICogYGBgXG4gKi9cbmNvbnN0IHVzZVVpQ2hhdCA9IG9wdGlvbnMgPT4ge1xuICBjb25zdCB7XG4gICAgICBjb21wb25lbnRzOiBpbml0aWFsQ29tcG9uZW50c1xuICAgIH0gPSBvcHRpb25zLFxuICAgIGNoYXRPcHRpb25zID0gX19yZXN0KG9wdGlvbnMsIFtcImNvbXBvbmVudHNcIl0pO1xuICBjb25zdCBbY29tcG9uZW50cywgc2V0Q29tcG9uZW50c10gPSB1c2VTdGF0ZShpbml0aWFsQ29tcG9uZW50cyk7XG4gIGNvbnN0IFtmbGF0dGVuZWRDb21wb25lbnRzXSA9IHVzZVN0YXRlKF91aS5mbGF0dGVuQ29tcG9uZW50cyhpbml0aWFsQ29tcG9uZW50cykpO1xuICBjb25zdCB1aSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBzLm9iamVjdCgnVUknLCB7XG4gICAgICB1aTogcy5zdHJlYW1pbmcuYXJyYXkoJ0xpc3Qgb2YgZWxlbWVudHMnLCBfdWkuY3JlYXRlQ29tcG9uZW50U2NoZW1hKGNvbXBvbmVudHMpKVxuICAgIH0pO1xuICB9LCBbY29tcG9uZW50c10pO1xuICBjb25zdCBzeXN0ZW1Bc1N0cmluZyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgY2hhdE9wdGlvbnMuc3lzdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNoYXRPcHRpb25zLnN5c3RlbTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gY2hhdE9wdGlvbnMuc3lzdGVtLmNvbXBpbGUoY29tcG9uZW50cywgdWkpO1xuICAgIGlmIChjaGF0T3B0aW9ucy5zeXN0ZW0uZGlhZ25vc3RpY3MubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTeXN0ZW0gcHJvbXB0IGhhcyAke2NoYXRPcHRpb25zLnN5c3RlbS5kaWFnbm9zdGljcy5sZW5ndGh9IGVycm9yczogXFxuXFxuJHtjaGF0T3B0aW9ucy5zeXN0ZW0uZGlhZ25vc3RpY3MubWFwKGQgPT4gZC5tZXNzYWdlKS5qb2luKCdcXG5cXG4nKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSwgW2NoYXRPcHRpb25zLnN5c3RlbSwgY29tcG9uZW50cywgdWldKTtcbiAgY29uc3QgY2hhdCA9IHVzZVN0cnVjdHVyZWRDaGF0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hhdE9wdGlvbnMpLCB7XG4gICAgc2NoZW1hOiB1aSxcbiAgICBzeXN0ZW06IHN5c3RlbUFzU3RyaW5nXG4gIH0pKTtcbiAgY29uc3QgYnVpbGRDb250ZW50ID0gdXNlQ2FsbGJhY2soKG5vZGVzLCBwYXJlbnRLZXkgPSAnJykgPT4ge1xuICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gbm9kZXMubWFwKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qga2V5ID0gYCR7cGFyZW50S2V5fV8ke2luZGV4fWA7XG4gICAgICBjb25zdCB7XG4gICAgICAgICR0YWcsXG4gICAgICAgICRjaGlsZHJlbixcbiAgICAgICAgJHByb3BzXG4gICAgICB9ID0gZWxlbWVudDtcbiAgICAgIGNvbnN0IGNvbXBvbmVudFR5cGUgPSAoX2EgPSBmbGF0dGVuZWRDb21wb25lbnRzLmdldCgkdGFnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbXBvbmVudDtcbiAgICAgIGlmICgkdGFnICYmIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBlbGVtZW50LiRjaGlsZHJlbiA/IGJ1aWxkQ29udGVudCgkY2hpbGRyZW4sIGtleSkgOiBudWxsO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoY29tcG9uZW50VHlwZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAkcHJvcHMpLCB7XG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAga2V5XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBlbGVtZW50IHR5cGUuICR7JHRhZ31gKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0sIFtmbGF0dGVuZWRDb21wb25lbnRzXSk7XG4gIGNvbnN0IHVpQ2hhdE1lc3NhZ2VzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGNoYXQubWVzc2FnZXMubWFwKG1lc3NhZ2UgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKG1lc3NhZ2Uucm9sZSA9PT0gJ2Fzc2lzdGFudCcpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWVzc2FnZSksIHtcbiAgICAgICAgICB1aTogKChfYSA9IG1lc3NhZ2UuY29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVpKSA/IGJ1aWxkQ29udGVudChtZXNzYWdlLmNvbnRlbnQudWkpIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0pO1xuICB9LCBbYnVpbGRDb250ZW50LCBjaGF0Lm1lc3NhZ2VzXSk7XG4gIGNvbnN0IGxhc3RBc3Npc3RhbnRNZXNzYWdlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHVpQ2hhdE1lc3NhZ2VzLmZpbmRMYXN0KG1lc3NhZ2UgPT4gbWVzc2FnZS5yb2xlID09PSAnYXNzaXN0YW50Jyk7XG4gIH0sIFt1aUNoYXRNZXNzYWdlc10pO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGF0KSwge1xuICAgIG1lc3NhZ2VzOiB1aUNoYXRNZXNzYWdlcyxcbiAgICBzZXRDb21wb25lbnRzLFxuICAgIGxhc3RBc3Npc3RhbnRNZXNzYWdlXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgSGFzaGJyb3duUHJvdmlkZXIsIGV4cG9zZUNvbXBvbmVudCwgdXNlQ2hhdCwgdXNlQ29tcGxldGlvbiwgdXNlUnVudGltZSwgdXNlUnVudGltZUZ1bmN0aW9uLCB1c2VTdHJ1Y3R1cmVkQ2hhdCwgdXNlU3RydWN0dXJlZENvbXBsZXRpb24sIHVzZVRvb2wsIHVzZVRvb2xKYXZhU2NyaXB0LCB1c2VVaUNoYXQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@hashbrownai+react@0.3.0_@hashbrownai+core@0.3.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@hashbrownai/react/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9jbHN4QDIuMS4xL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGNBQWMsYUFBYSwrQ0FBK0MsZ0RBQWdELGVBQWUsUUFBUSxJQUFJLDBDQUEwQyx5Q0FBeUMsU0FBZ0IsZ0JBQWdCLHdDQUF3QyxJQUFJLG1EQUFtRCxTQUFTLCtEQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nsc3hAMi4xLjEvbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcz9kMDY4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZodError: function() { return /* binding */ ZodError; },\n/* harmony export */   ZodIssueCode: function() { return /* binding */ ZodIssueCode; },\n/* harmony export */   quotelessJson: function() { return /* binding */ quotelessJson; }\n/* harmony export */ });\n/* harmony import */ var _helpers_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/util.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js\");\n\nconst ZodIssueCode = _helpers_util_js__WEBPACK_IMPORTED_MODULE_0__.util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, _helpers_util_js__WEBPACK_IMPORTED_MODULE_0__.util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                const firstEl = sub.path[0];\n                fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n                fieldErrors[firstEl].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL1pvZEVycm9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDbEMscUJBQXFCLGtEQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsMERBQTBEO0FBQzFELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsa0RBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy96b2QvdjMvWm9kRXJyb3IuanM/NmZmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1dGlsIH0gZnJvbSBcIi4vaGVscGVycy91dGlsLmpzXCI7XG5leHBvcnQgY29uc3QgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcbiAgICBcImludmFsaWRfbGl0ZXJhbFwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3JcIixcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBcImludmFsaWRfYXJndW1lbnRzXCIsXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcbiAgICBcImludmFsaWRfc3RyaW5nXCIsXG4gICAgXCJ0b29fc21hbGxcIixcbiAgICBcInRvb19iaWdcIixcbiAgICBcImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXCIsXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICBcIm5vdF9maW5pdGVcIixcbl0pO1xuZXhwb3J0IGNvbnN0IHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgcmV0dXJuIGpzb24ucmVwbGFjZSgvXCIoW15cIl0rKVwiOi9nLCBcIiQxOlwiKTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihpc3N1ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZSA9IChzdWIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZElzc3VlcyA9IChzdWJzID0gW10pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5zdWJzXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBhY3R1YWxQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gICAgfVxuICAgIGZvcm1hdChfbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpc3N1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlzc3VlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlcnJvckFycmF5Ll9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgZXJyb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICAgIH1cbiAgICBzdGF0aWMgYXNzZXJ0KHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgWm9kRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICAgICAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RWwgPSBzdWIucGF0aFswXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tmaXJzdEVsXSA9IGZpZWxkRXJyb3JzW2ZpcnN0RWxdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW2ZpcnN0RWxdLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xuICAgIH1cbiAgICBnZXQgZm9ybUVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICAgIH1cbn1cblpvZEVycm9yLmNyZWF0ZSA9IChpc3N1ZXMpID0+IHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultErrorMap: function() { return /* reexport safe */ _locales_en_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   getErrorMap: function() { return /* binding */ getErrorMap; },\n/* harmony export */   setErrorMap: function() { return /* binding */ setErrorMap; }\n/* harmony export */ });\n/* harmony import */ var _locales_en_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locales/en.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js\");\n\nlet overrideErrorMap = _locales_en_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQThDO0FBQzlDLHVCQUF1QixzREFBZTtBQUNYO0FBQ3BCO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9lcnJvcnMuanM/OGJhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVmYXVsdEVycm9yTWFwIGZyb20gXCIuL2xvY2FsZXMvZW4uanNcIjtcbmxldCBvdmVycmlkZUVycm9yTWFwID0gZGVmYXVsdEVycm9yTWFwO1xuZXhwb3J0IHsgZGVmYXVsdEVycm9yTWFwIH07XG5leHBvcnQgZnVuY3Rpb24gc2V0RXJyb3JNYXAobWFwKSB7XG4gICAgb3ZlcnJpZGVFcnJvck1hcCA9IG1hcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVFcnJvck1hcDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   errorUtil: function() { return /* binding */ errorUtil; }\n/* harmony export */ });\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvZXJyb3JVdGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEY7QUFDQTtBQUNBLENBQUMsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvZXJyb3JVdGlsLmpzPzEzZmMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fTtcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludDpcbiAgICBlcnJvclV0aWwudG9TdHJpbmcgPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZT8ubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DIRTY: function() { return /* binding */ DIRTY; },\n/* harmony export */   EMPTY_PATH: function() { return /* binding */ EMPTY_PATH; },\n/* harmony export */   INVALID: function() { return /* binding */ INVALID; },\n/* harmony export */   OK: function() { return /* binding */ OK; },\n/* harmony export */   ParseStatus: function() { return /* binding */ ParseStatus; },\n/* harmony export */   addIssueToContext: function() { return /* binding */ addIssueToContext; },\n/* harmony export */   isAborted: function() { return /* binding */ isAborted; },\n/* harmony export */   isAsync: function() { return /* binding */ isAsync; },\n/* harmony export */   isDirty: function() { return /* binding */ isDirty; },\n/* harmony export */   isValid: function() { return /* binding */ isValid; },\n/* harmony export */   makeIssue: function() { return /* binding */ makeIssue; }\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.js\");\n/* harmony import */ var _locales_en_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../locales/en.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js\");\n\n\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const overrideMap = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.getErrorMap)();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === _locales_en_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ? undefined : _locales_en_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nconst OK = (value) => ({ status: \"valid\", value });\nconst isAborted = (x) => x.status === \"aborted\";\nconst isDirty = (x) => x.status === \"dirty\";\nconst isValid = (x) => x.status === \"valid\";\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvcGFyc2VVdGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDSTtBQUN4QztBQUNQLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQ0FBa0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1Asd0JBQXdCLHVEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQWUsZUFBZSxzREFBZTtBQUN6RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNPO0FBQ1A7QUFDQSxDQUFDO0FBQ00sNEJBQTRCLHdCQUF3QjtBQUNwRCx5QkFBeUIsd0JBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvcGFyc2VVdGlsLmpzPzgxODkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RXJyb3JNYXAgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgZGVmYXVsdEVycm9yTWFwIGZyb20gXCIuLi9sb2NhbGVzL2VuLmpzXCI7XG5leHBvcnQgY29uc3QgbWFrZUlzc3VlID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcbiAgICBjb25zdCBmdWxsSXNzdWUgPSB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgfTtcbiAgICBpZiAoaXNzdWVEYXRhLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XG4gICAgY29uc3QgbWFwcyA9IGVycm9yTWFwc1xuICAgICAgICAuZmlsdGVyKChtKSA9PiAhIW0pXG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCBtYXAgb2YgbWFwcykge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBtYXAoZnVsbElzc3VlLCB7IGRhdGEsIGRlZmF1bHRFcnJvcjogZXJyb3JNZXNzYWdlIH0pLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBFTVBUWV9QQVRIID0gW107XG5leHBvcnQgZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcbiAgICBjb25zdCBvdmVycmlkZU1hcCA9IGdldEVycm9yTWFwKCk7XG4gICAgY29uc3QgaXNzdWUgPSBtYWtlSXNzdWUoe1xuICAgICAgICBpc3N1ZURhdGE6IGlzc3VlRGF0YSxcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCAvLyBjb250ZXh0dWFsIGVycm9yIG1hcCBpcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLCAvLyB0aGVuIHNjaGVtYS1ib3VuZCBtYXAgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBvdmVycmlkZU1hcCwgLy8gdGhlbiBnbG9iYWwgb3ZlcnJpZGUgbWFwXG4gICAgICAgICAgICBvdmVycmlkZU1hcCA9PT0gZGVmYXVsdEVycm9yTWFwID8gdW5kZWZpbmVkIDogZGVmYXVsdEVycm9yTWFwLCAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxuICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICB9KTtcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcbn1cbmV4cG9ydCBjbGFzcyBQYXJzZVN0YXR1cyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcInZhbGlkXCI7XG4gICAgfVxuICAgIGRpcnR5KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJ2YWxpZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiZGlydHlcIjtcbiAgICB9XG4gICAgYWJvcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImFib3J0ZWRcIjtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKSB7XG4gICAgICAgIGNvbnN0IGFycmF5VmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGFycmF5VmFsdWUucHVzaChzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGFycmF5VmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIG1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKGtleS52YWx1ZSAhPT0gXCJfX3Byb3RvX19cIiAmJiAodHlwZW9mIHZhbHVlLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHBhaXIuYWx3YXlzU2V0KSkge1xuICAgICAgICAgICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxufSk7XG5leHBvcnQgY29uc3QgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcbmV4cG9ydCBjb25zdCBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xuZXhwb3J0IGNvbnN0IGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCI7XG5leHBvcnQgY29uc3QgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xuZXhwb3J0IGNvbnN0IGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbmV4cG9ydCBjb25zdCBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZodParsedType: function() { return /* binding */ ZodParsedType; },\n/* harmony export */   getParsedType: function() { return /* binding */ getParsedType; },\n/* harmony export */   objectUtil: function() { return /* binding */ objectUtil; },\n/* harmony export */   util: function() { return /* binding */ util; }\n/* harmony export */ });\nvar util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsSUFBSTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDZDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDMUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvdXRpbC5qcz8xNTlmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgdXRpbDtcbihmdW5jdGlvbiAodXRpbCkge1xuICAgIHV0aWwuYXNzZXJ0RXF1YWwgPSAoXykgPT4geyB9O1xuICAgIGZ1bmN0aW9uIGFzc2VydElzKF9hcmcpIHsgfVxuICAgIHV0aWwuYXNzZXJ0SXMgPSBhc3NlcnRJcztcbiAgICBmdW5jdGlvbiBhc3NlcnROZXZlcihfeCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgdXRpbC5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyO1xuICAgIHV0aWwuYXJyYXlUb0VudW0gPSAoaXRlbXMpID0+IHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgb2JqW2l0ZW1dID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbGlkS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhvYmopLmZpbHRlcigoaykgPT4gdHlwZW9mIG9ialtvYmpba11dICE9PSBcIm51bWJlclwiKTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIHZhbGlkS2V5cykge1xuICAgICAgICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKGZpbHRlcmVkKTtcbiAgICB9O1xuICAgIHV0aWwub2JqZWN0VmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RLZXlzKG9iaikubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2VdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHV0aWwub2JqZWN0S2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA/IChvYmopID0+IE9iamVjdC5rZXlzKG9iaikgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKG9iamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgIH07XG4gICAgdXRpbC5maW5kID0gKGFyciwgY2hlY2tlcikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlcihpdGVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdXRpbC5pc0ludGVnZXIgPSB0eXBlb2YgTnVtYmVyLmlzSW50ZWdlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gKHZhbCkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWwpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG4gICAgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCIgfCBcIikge1xuICAgICAgICByZXR1cm4gYXJyYXkubWFwKCh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkpLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9XG4gICAgdXRpbC5qb2luVmFsdWVzID0gam9pblZhbHVlcztcbiAgICB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciA9IChfLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKHV0aWwgfHwgKHV0aWwgPSB7fSkpO1xuZXhwb3J0IHZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uIChvYmplY3RVdGlsKSB7XG4gICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5maXJzdCxcbiAgICAgICAgICAgIC4uLnNlY29uZCwgLy8gc2Vjb25kIG92ZXJ3cml0ZXMgZmlyc3RcbiAgICAgICAgfTtcbiAgICB9O1xufSkob2JqZWN0VXRpbCB8fCAob2JqZWN0VXRpbCA9IHt9KSk7XG5leHBvcnQgY29uc3QgWm9kUGFyc2VkVHlwZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwic3RyaW5nXCIsXG4gICAgXCJuYW5cIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwiZmxvYXRcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcImRhdGVcIixcbiAgICBcImJpZ2ludFwiLFxuICAgIFwic3ltYm9sXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwidW5kZWZpbmVkXCIsXG4gICAgXCJudWxsXCIsXG4gICAgXCJhcnJheVwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJ1bmtub3duXCIsXG4gICAgXCJwcm9taXNlXCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJuZXZlclwiLFxuICAgIFwibWFwXCIsXG4gICAgXCJzZXRcIixcbl0pO1xuZXhwb3J0IGNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oZGF0YSkgPyBab2RQYXJzZWRUeXBlLm5hbiA6IFpvZFBhcnNlZFR5cGUubnVtYmVyO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYmlnaW50O1xuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aGVuICYmIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJiBkYXRhLmNhdGNoICYmIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5kYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUub2JqZWN0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ZodError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ZodError.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js\");\n/* harmony import */ var _helpers_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/util.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js\");\n\n\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.invalid_type:\n            if (issue.received === _helpers_util_js__WEBPACK_IMPORTED_MODULE_1__.ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, _helpers_util_js__WEBPACK_IMPORTED_MODULE_1__.util.jsonStringifyReplacer)}`;\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${_helpers_util_js__WEBPACK_IMPORTED_MODULE_1__.util.joinValues(issue.keys, \", \")}`;\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${_helpers_util_js__WEBPACK_IMPORTED_MODULE_1__.util.joinValues(issue.options)}`;\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${_helpers_util_js__WEBPACK_IMPORTED_MODULE_1__.util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    _helpers_util_js__WEBPACK_IMPORTED_MODULE_1__.util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"bigint\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case _ZodError_js__WEBPACK_IMPORTED_MODULE_0__.ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            _helpers_util_js__WEBPACK_IMPORTED_MODULE_1__.util.assertNever(issue);\n    }\n    return { message };\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (errorMap);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2xvY2FsZXMvZW4uanMiLCJtYXBwaW5ncyI6Ijs7O0FBQThDO0FBQ1c7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBWTtBQUN6QixtQ0FBbUMsMkRBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWUsYUFBYSxlQUFlO0FBQ2pGO0FBQ0E7QUFDQSxhQUFhLHNEQUFZO0FBQ3pCLHlEQUF5RCwrQkFBK0Isa0RBQUksd0JBQXdCO0FBQ3BIO0FBQ0EsYUFBYSxzREFBWTtBQUN6Qix3REFBd0Qsa0RBQUksOEJBQThCO0FBQzFGO0FBQ0EsYUFBYSxzREFBWTtBQUN6QjtBQUNBO0FBQ0EsYUFBYSxzREFBWTtBQUN6QiwrREFBK0Qsa0RBQUksMkJBQTJCO0FBQzlGO0FBQ0EsYUFBYSxzREFBWTtBQUN6QixzREFBc0Qsa0RBQUksMkJBQTJCLGNBQWMsZUFBZTtBQUNsSDtBQUNBLGFBQWEsc0RBQVk7QUFDekI7QUFDQTtBQUNBLGFBQWEsc0RBQVk7QUFDekI7QUFDQTtBQUNBLGFBQWEsc0RBQVk7QUFDekI7QUFDQTtBQUNBLGFBQWEsc0RBQVk7QUFDekI7QUFDQTtBQUNBLDhEQUE4RCwwQkFBMEI7QUFDeEY7QUFDQSxxQ0FBcUMsU0FBUyxvREFBb0QsMEJBQTBCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSw0QkFBNEI7QUFDN0Y7QUFDQTtBQUNBLCtEQUErRCwwQkFBMEI7QUFDekY7QUFDQTtBQUNBLG9CQUFvQixrREFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNEQUFZO0FBQ3pCO0FBQ0EsZ0RBQWdELHNFQUFzRSxFQUFFLGVBQWU7QUFDdkk7QUFDQSxpREFBaUQsaUVBQWlFLEVBQUUsZUFBZTtBQUNuSTtBQUNBLDRDQUE0QyxvR0FBb0csRUFBRSxjQUFjO0FBQ2hLO0FBQ0EsNENBQTRDLG9HQUFvRyxFQUFFLGNBQWM7QUFDaEs7QUFDQSwwQ0FBMEMsb0dBQW9HLEVBQUUsZ0NBQWdDO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0RBQVk7QUFDekI7QUFDQSxnREFBZ0QscUVBQXFFLEVBQUUsZUFBZTtBQUN0STtBQUNBLGlEQUFpRCxpRUFBaUUsRUFBRSxlQUFlO0FBQ25JO0FBQ0EsNENBQTRDLG1GQUFtRixFQUFFLGNBQWM7QUFDL0k7QUFDQSw0Q0FBNEMsbUZBQW1GLEVBQUUsY0FBYztBQUMvSTtBQUNBLDBDQUEwQyx5RkFBeUYsRUFBRSxnQ0FBZ0M7QUFDcks7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBWTtBQUN6QjtBQUNBO0FBQ0EsYUFBYSxzREFBWTtBQUN6QjtBQUNBO0FBQ0EsYUFBYSxzREFBWTtBQUN6QixzREFBc0QsaUJBQWlCO0FBQ3ZFO0FBQ0EsYUFBYSxzREFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0RBQUk7QUFDaEI7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrREFBZSxRQUFRLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy96b2QvdjMvbG9jYWxlcy9lbi5qcz8wNWE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFpvZElzc3VlQ29kZSB9IGZyb20gXCIuLi9ab2RFcnJvci5qc1wiO1xuaW1wb3J0IHsgdXRpbCwgWm9kUGFyc2VkVHlwZSB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWwuanNcIjtcbmNvbnN0IGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgc3dpdGNoIChpc3N1ZS5jb2RlKSB7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZTpcbiAgICAgICAgICAgIGlmIChpc3N1ZS5yZWNlaXZlZCA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJSZXF1aXJlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBFeHBlY3RlZCAke2lzc3VlLmV4cGVjdGVkfSwgcmVjZWl2ZWQgJHtpc3N1ZS5yZWNlaXZlZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbDpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBsaXRlcmFsIHZhbHVlLCBleHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KGlzc3VlLmV4cGVjdGVkLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlcil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3I6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtpc3N1ZS5yZWNlaXZlZH0nYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiBhcmd1bWVudHNgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZzpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChcImluY2x1ZGVzXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgaW5jbHVkZSBcIiR7aXNzdWUudmFsaWRhdGlvbi5pbmNsdWRlc31cImA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9IGF0IG9uZSBvciBtb3JlIHBvc2l0aW9ucyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHtpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9ufWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJzdGFydHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3Qgc3RhcnQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5zdGFydHNXaXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJlbmRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGVuZCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmVuZHNXaXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUudmFsaWRhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudmFsaWRhdGlvbiAhPT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkICR7aXNzdWUudmFsaWRhdGlvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19zbWFsbDpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBtb3JlIHRoYW5gfSAke2lzc3VlLm1pbmltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBvdmVyYH0gJHtpc3N1ZS5taW5pbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWluaW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEJpZ0ludCBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvYCA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlczpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG5leHBvcnQgZGVmYXVsdCBlcnJvck1hcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAND: function() { return /* binding */ BRAND; },\n/* harmony export */   NEVER: function() { return /* binding */ NEVER; },\n/* harmony export */   Schema: function() { return /* binding */ ZodType; },\n/* harmony export */   ZodAny: function() { return /* binding */ ZodAny; },\n/* harmony export */   ZodArray: function() { return /* binding */ ZodArray; },\n/* harmony export */   ZodBigInt: function() { return /* binding */ ZodBigInt; },\n/* harmony export */   ZodBoolean: function() { return /* binding */ ZodBoolean; },\n/* harmony export */   ZodBranded: function() { return /* binding */ ZodBranded; },\n/* harmony export */   ZodCatch: function() { return /* binding */ ZodCatch; },\n/* harmony export */   ZodDate: function() { return /* binding */ ZodDate; },\n/* harmony export */   ZodDefault: function() { return /* binding */ ZodDefault; },\n/* harmony export */   ZodDiscriminatedUnion: function() { return /* binding */ ZodDiscriminatedUnion; },\n/* harmony export */   ZodEffects: function() { return /* binding */ ZodEffects; },\n/* harmony export */   ZodEnum: function() { return /* binding */ ZodEnum; },\n/* harmony export */   ZodFirstPartyTypeKind: function() { return /* binding */ ZodFirstPartyTypeKind; },\n/* harmony export */   ZodFunction: function() { return /* binding */ ZodFunction; },\n/* harmony export */   ZodIntersection: function() { return /* binding */ ZodIntersection; },\n/* harmony export */   ZodLazy: function() { return /* binding */ ZodLazy; },\n/* harmony export */   ZodLiteral: function() { return /* binding */ ZodLiteral; },\n/* harmony export */   ZodMap: function() { return /* binding */ ZodMap; },\n/* harmony export */   ZodNaN: function() { return /* binding */ ZodNaN; },\n/* harmony export */   ZodNativeEnum: function() { return /* binding */ ZodNativeEnum; },\n/* harmony export */   ZodNever: function() { return /* binding */ ZodNever; },\n/* harmony export */   ZodNull: function() { return /* binding */ ZodNull; },\n/* harmony export */   ZodNullable: function() { return /* binding */ ZodNullable; },\n/* harmony export */   ZodNumber: function() { return /* binding */ ZodNumber; },\n/* harmony export */   ZodObject: function() { return /* binding */ ZodObject; },\n/* harmony export */   ZodOptional: function() { return /* binding */ ZodOptional; },\n/* harmony export */   ZodPipeline: function() { return /* binding */ ZodPipeline; },\n/* harmony export */   ZodPromise: function() { return /* binding */ ZodPromise; },\n/* harmony export */   ZodReadonly: function() { return /* binding */ ZodReadonly; },\n/* harmony export */   ZodRecord: function() { return /* binding */ ZodRecord; },\n/* harmony export */   ZodSchema: function() { return /* binding */ ZodType; },\n/* harmony export */   ZodSet: function() { return /* binding */ ZodSet; },\n/* harmony export */   ZodString: function() { return /* binding */ ZodString; },\n/* harmony export */   ZodSymbol: function() { return /* binding */ ZodSymbol; },\n/* harmony export */   ZodTransformer: function() { return /* binding */ ZodEffects; },\n/* harmony export */   ZodTuple: function() { return /* binding */ ZodTuple; },\n/* harmony export */   ZodType: function() { return /* binding */ ZodType; },\n/* harmony export */   ZodUndefined: function() { return /* binding */ ZodUndefined; },\n/* harmony export */   ZodUnion: function() { return /* binding */ ZodUnion; },\n/* harmony export */   ZodUnknown: function() { return /* binding */ ZodUnknown; },\n/* harmony export */   ZodVoid: function() { return /* binding */ ZodVoid; },\n/* harmony export */   any: function() { return /* binding */ anyType; },\n/* harmony export */   array: function() { return /* binding */ arrayType; },\n/* harmony export */   bigint: function() { return /* binding */ bigIntType; },\n/* harmony export */   boolean: function() { return /* binding */ booleanType; },\n/* harmony export */   coerce: function() { return /* binding */ coerce; },\n/* harmony export */   custom: function() { return /* binding */ custom; },\n/* harmony export */   date: function() { return /* binding */ dateType; },\n/* harmony export */   datetimeRegex: function() { return /* binding */ datetimeRegex; },\n/* harmony export */   discriminatedUnion: function() { return /* binding */ discriminatedUnionType; },\n/* harmony export */   effect: function() { return /* binding */ effectsType; },\n/* harmony export */   \"enum\": function() { return /* binding */ enumType; },\n/* harmony export */   \"function\": function() { return /* binding */ functionType; },\n/* harmony export */   \"instanceof\": function() { return /* binding */ instanceOfType; },\n/* harmony export */   intersection: function() { return /* binding */ intersectionType; },\n/* harmony export */   late: function() { return /* binding */ late; },\n/* harmony export */   lazy: function() { return /* binding */ lazyType; },\n/* harmony export */   literal: function() { return /* binding */ literalType; },\n/* harmony export */   map: function() { return /* binding */ mapType; },\n/* harmony export */   nan: function() { return /* binding */ nanType; },\n/* harmony export */   nativeEnum: function() { return /* binding */ nativeEnumType; },\n/* harmony export */   never: function() { return /* binding */ neverType; },\n/* harmony export */   \"null\": function() { return /* binding */ nullType; },\n/* harmony export */   nullable: function() { return /* binding */ nullableType; },\n/* harmony export */   number: function() { return /* binding */ numberType; },\n/* harmony export */   object: function() { return /* binding */ objectType; },\n/* harmony export */   oboolean: function() { return /* binding */ oboolean; },\n/* harmony export */   onumber: function() { return /* binding */ onumber; },\n/* harmony export */   optional: function() { return /* binding */ optionalType; },\n/* harmony export */   ostring: function() { return /* binding */ ostring; },\n/* harmony export */   pipeline: function() { return /* binding */ pipelineType; },\n/* harmony export */   preprocess: function() { return /* binding */ preprocessType; },\n/* harmony export */   promise: function() { return /* binding */ promiseType; },\n/* harmony export */   record: function() { return /* binding */ recordType; },\n/* harmony export */   set: function() { return /* binding */ setType; },\n/* harmony export */   strictObject: function() { return /* binding */ strictObjectType; },\n/* harmony export */   string: function() { return /* binding */ stringType; },\n/* harmony export */   symbol: function() { return /* binding */ symbolType; },\n/* harmony export */   transformer: function() { return /* binding */ effectsType; },\n/* harmony export */   tuple: function() { return /* binding */ tupleType; },\n/* harmony export */   undefined: function() { return /* binding */ undefinedType; },\n/* harmony export */   union: function() { return /* binding */ unionType; },\n/* harmony export */   unknown: function() { return /* binding */ unknownType; },\n/* harmony export */   \"void\": function() { return /* binding */ voidType; }\n/* harmony export */ });\n/* harmony import */ var _ZodError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ZodError.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js\");\n/* harmony import */ var _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers/errorUtil.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.js\");\n/* harmony import */ var _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/parseUtil.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.js\");\n/* harmony import */ var _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers/util.js */ \"(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js\");\n\n\n\n\n\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if ((0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isValid)(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return (0,_helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.getParsedType)(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: (0,_helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.getParsedType)(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: (0,_helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.getParsedType)(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if ((0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isAsync)(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: (0,_helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.getParsedType)(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: (0,_helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.getParsedType)(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isValid)(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isValid)(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: (0,_helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.getParsedType)(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await ((0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nfunction datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        if (!header)\n            return false;\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        const status = new _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                            code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                            code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"email\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"emoji\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"uuid\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"nanoid\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"cuid\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"cuid2\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"ulid\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"url\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"regex\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"duration\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"ip\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"jwt\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"cidr\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"base64\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        validation: \"base64url\",\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_string,\n            ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ..._helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        let ctx = undefined;\n        const status = new _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!_helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n            code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n            expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_date,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        const status = new _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n            code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n            expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.array) {\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                    code: tooBig ? _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_big : _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                    code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                    code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                        code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(_helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodError(result.ctx.common.issues));\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodError(issues));\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.object) {\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = (0,_helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.getParsedType)(a);\n    const bType = (0,_helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.getParsedType)(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.object && bType === _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.object) {\n        const bKeys = _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.objectKeys(b);\n        const sharedKeys = _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.array && bType === _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.date && bType === _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if ((0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isAborted)(parsedLeft) || (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isAborted)(parsedRight)) {\n                return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                    code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_intersection_types,\n                });\n                return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n            }\n            if ((0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isDirty)(parsedLeft) || (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isDirty)(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.array) {\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.object) {\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.map) {\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.set) {\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                    code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                    code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: _helpers_errorUtil_js__WEBPACK_IMPORTED_MODULE_3__.errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.function) {\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.makeIssue)({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.getErrorMap)(), _errors_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]].filter((x) => !!x),\n                issueData: {\n                    code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.makeIssue)({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.getErrorMap)(), _errors_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]].filter((x) => !!x),\n                issueData: {\n                    code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(async function (...args) {\n                const error = new _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.string && ctx.parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.number) {\n            const expectedValues = _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.objectValues(nativeEnumValues);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(_helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.objectValues(nativeEnumValues);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.promise && ctx.common.async === false) {\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        const promisified = ctx.parsedType === _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                    if (result.status === \"dirty\")\n                        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.DIRTY)(result.value);\n                    if (status.value === \"dirty\")\n                        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.DIRTY)(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                if (result.status === \"dirty\")\n                    return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.DIRTY)(result.value);\n                if (status.value === \"dirty\")\n                    return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.DIRTY)(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!(0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isValid)(base))\n                    return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!(0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isValid)(base))\n                        return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\n\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.undefined) {\n            return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.null) {\n            return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.OK)(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if ((0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isAsync)(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.addIssueToContext)(ctx, {\n                code: _ZodError_js__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.invalid_type,\n                expected: _helpers_util_js__WEBPACK_IMPORTED_MODULE_2__.ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.DIRTY)(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if ((0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isValid)(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return (0,_helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nfunction custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\n\nconst late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nconst coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\n\nconst NEVER = _helpers_parseUtil_js__WEBPACK_IMPORTED_MODULE_0__.INVALID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ0c7QUFDUjtBQUMyRjtBQUN2RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFPO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtEQUFRO0FBQzFDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBNEQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrREFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhE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QUNBLFNBQVM7QUFDVDtBQUNBO0FBQ21EO0FBQzVDO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AseUNBQXlDLHNCQUFzQjtBQUMvRCx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5Q0FBeUMsc0JBQXNCO0FBQy9ELHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDdzNCO0FBQ2ozQixjQUFjLDBEQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL3R5cGVzLmpzPzc4NWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWm9kRXJyb3IsIFpvZElzc3VlQ29kZSwgfSBmcm9tIFwiLi9ab2RFcnJvci5qc1wiO1xuaW1wb3J0IHsgZGVmYXVsdEVycm9yTWFwLCBnZXRFcnJvck1hcCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZXJyb3JVdGlsIH0gZnJvbSBcIi4vaGVscGVycy9lcnJvclV0aWwuanNcIjtcbmltcG9ydCB7IERJUlRZLCBJTlZBTElELCBPSywgUGFyc2VTdGF0dXMsIGFkZElzc3VlVG9Db250ZXh0LCBpc0Fib3J0ZWQsIGlzQXN5bmMsIGlzRGlydHksIGlzVmFsaWQsIG1ha2VJc3N1ZSwgfSBmcm9tIFwiLi9oZWxwZXJzL3BhcnNlVXRpbC5qc1wiO1xuaW1wb3J0IHsgdXRpbCwgWm9kUGFyc2VkVHlwZSwgZ2V0UGFyc2VkVHlwZSB9IGZyb20gXCIuL2hlbHBlcnMvdXRpbC5qc1wiO1xuY2xhc3MgUGFyc2VJbnB1dExhenlQYXRoIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbHVlLCBwYXRoLCBrZXkpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9rZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGF0aDtcbiAgICB9XG59XG5jb25zdCBoYW5kbGVSZXN1bHQgPSAoY3R4LCByZXN1bHQpID0+IHtcbiAgICBpZiAoaXNWYWxpZChyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFjdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBlcnJvck1hcCwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgICBpZiAoZXJyb3JNYXAgJiYgKGludmFsaWRfdHlwZV9lcnJvciB8fCByZXF1aXJlZF9lcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICAgIH1cbiAgICBpZiAoZXJyb3JNYXApXG4gICAgICAgIHJldHVybiB7IGVycm9yTWFwOiBlcnJvck1hcCwgZGVzY3JpcHRpb24gfTtcbiAgICBjb25zdCBjdXN0b21NYXAgPSAoaXNzLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChpc3MuY29kZSA9PT0gXCJpbnZhbGlkX2VudW1fdmFsdWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyByZXF1aXJlZF9lcnJvciA/PyBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlID8/IGludmFsaWRfdHlwZV9lcnJvciA/PyBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxuZXhwb3J0IGNsYXNzIFpvZFR5cGUge1xuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgX2dldFR5cGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIF9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSB7XG4gICAgICAgIHJldHVybiAoY3R4IHx8IHtcbiAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzKCksXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9wYXJzZVN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfcGFyc2VBc3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gICAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2FmZVBhcnNlKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBzYWZlUGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6IHBhcmFtcz8uYXN5bmMgPz8gZmFsc2UsXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXM/LmVycm9yTWFwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IHBhcmFtcz8ucGF0aCB8fCBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgXCJ+dmFsaWRhdGVcIihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6ICEhdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycj8ubWVzc2FnZT8udG9Mb3dlckNhc2UoKT8uaW5jbHVkZXMoXCJlbmNvdW50ZXJlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VBc3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChyZXN1bHQpID0+IGlzVmFsaWQocmVzdWx0KVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgYXN5bmMgc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXM/LmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IHBhcmFtcz8ucGF0aCB8fCBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWF5YmVBc3luY1Jlc3VsdCA9IHRoaXMuX3BhcnNlKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoaXNBc3luYyhtYXliZUFzeW5jUmVzdWx0KSA/IG1heWJlQXN5bmNSZXN1bHQgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgIC4uLmdldElzc3VlUHJvcGVydGllcyh2YWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCIgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eCkgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1cGVyUmVmaW5lKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRlZikge1xuICAgICAgICAvKiogQWxpYXMgb2Ygc2FmZVBhcnNlQXN5bmMgKi9cbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2F0Y2ggPSB0aGlzLmNhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gdGhpcy5yZWFkb25seS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0gPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgdmVuZG9yOiBcInpvZFwiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IChkYXRhKSA9PiB0aGlzW1wifnZhbGlkYXRlXCJdKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsaXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udWxsYWJsZSgpLm9wdGlvbmFsKCk7XG4gICAgfVxuICAgIGFycmF5KCkge1xuICAgICAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgb3Iob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIG9wdGlvbl0sIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIGFuZChpbmNvbWluZykge1xuICAgICAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVmYXVsdChkZWYpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJyYW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgICAgICAgdHlwZTogdGhpcyxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoKGRlZikge1xuICAgICAgICBjb25zdCBjYXRjaFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBjYXRjaFZhbHVlOiBjYXRjaFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGlwZSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBpcGVsaW5lLmNyZWF0ZSh0aGlzLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgaXNPcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcbiAgICB9XG4gICAgaXNOdWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gICAgfVxufVxuY29uc3QgY3VpZFJlZ2V4ID0gL15jW15cXHMtXXs4LH0kL2k7XG5jb25zdCBjdWlkMlJlZ2V4ID0gL15bMC05YS16XSskLztcbmNvbnN0IHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvaTtcbi8vIGNvbnN0IHV1aWRSZWdleCA9XG4vLyAgIC9eKFthLWYwLTldezh9LVthLWYwLTldezR9LVsxLTVdW2EtZjAtOV17M30tW2EtZjAtOV17NH0tW2EtZjAtOV17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5jb25zdCB1dWlkUmVnZXggPSAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvaTtcbmNvbnN0IG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcbmNvbnN0IGp3dFJlZ2V4ID0gL15bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXSokLztcbmNvbnN0IGR1cmF0aW9uUmVnZXggPSAvXlstK10/UCg/ISQpKD86KD86Wy0rXT9cXGQrWSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtZJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzooPzpbLStdP1xcZCtXKXwoPzpbLStdP1xcZCtbLixdXFxkK1ckKSk/KD86KD86Wy0rXT9cXGQrRCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtEJCkpPyg/OlQoPz1bXFxkKy1dKSg/Oig/OlstK10/XFxkK0gpfCg/OlstK10/XFxkK1suLF1cXGQrSCQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86Wy0rXT9cXGQrKD86Wy4sXVxcZCspP1MpPyk/PyQvO1xuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYxODEvMTU1MDE1NVxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xuLy9vbGQgZW1haWwgcmVnZXhcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXS4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKD8hLSkoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezEsfSlbXi08PigpW1xcXS4sOzpcXHNAXCJdJC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbKCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFxdKXwoXFxbSVB2NjooKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpXFxdKXwoW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dKltBLVphLXowLTldKSooXFwuW0EtWmEtel17Mix9KSspKSQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtekEtWjAtOVxcLlxcIVxcI1xcJFxcJVxcJlxcJ1xcKlxcK1xcL1xcPVxcP1xcXlxcX1xcYFxce1xcfFxcfVxcflxcLV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oPzpbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqfFwiKD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT98XFxbKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT98W2EtejAtOS1dKlthLXowLTldOig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDVhXFx4NTMtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSspXFxdKSQvaTtcbmNvbnN0IGVtYWlsUmVnZXggPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8nK1xcLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtejAtOS4hIyQlJuKAmSorLz0/Xl9ge3x9fi1dK0BbYS16MC05LV0rKD86XFwuW2EtejAtOVxcLV0rKSokL2k7XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcbmxldCBlbW9qaVJlZ2V4O1xuLy8gZmFzdGVyLCBzaW1wbGVyLCBzYWZlclxuY29uc3QgaXB2NFJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLztcbmNvbnN0IGlwdjRDaWRyUmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLygzWzAtMl18WzEyXT9bMC05XSkkLztcbi8vIGNvbnN0IGlwdjZSZWdleCA9XG4vLyAvXigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSkkLztcbmNvbnN0IGlwdjZSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKSQvO1xuY29uc3QgaXB2NkNpZHJSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKVxcLygxMlswLThdfDFbMDFdWzAtOV18WzEtOV0/WzAtOV0pJC87XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODYwMzkyL2RldGVybWluZS1pZi1zdHJpbmctaXMtaW4tYmFzZTY0LXVzaW5nLWphdmFzY3JpcHRcbmNvbnN0IGJhc2U2NFJlZ2V4ID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xuLy8gaHR0cHM6Ly9iYXNlNjQuZ3VydS9zdGFuZGFyZHMvYmFzZTY0dXJsXG5jb25zdCBiYXNlNjR1cmxSZWdleCA9IC9eKFswLTlhLXpBLVotX117NH0pKigoWzAtOWEtekEtWi1fXXsyfSg9PSk/KXwoWzAtOWEtekEtWi1fXXszfSg9KT8pKT8kLztcbi8vIHNpbXBsZVxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9YDtcbi8vIG5vIGxlYXAgeWVhciB2YWxpZGF0aW9uXG4vLyBjb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgXFxcXGR7NH0tKCgwWzEzNTc4XXwxMHwxMiktMzF8KDBbMTMtOV18MVswLTJdKS0zMHwoMFsxLTldfDFbMC0yXSktKDBbMS05XXwxXFxcXGR8MlxcXFxkKSlgO1xuLy8gd2l0aCBsZWFwIHllYXIgdmFsaWRhdGlvblxuY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYCgoXFxcXGRcXFxcZFsyNDY4XVswNDhdfFxcXFxkXFxcXGRbMTM1NzldWzI2XXxcXFxcZFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXGR7NH0tKCgwWzEzNTc4XXwxWzAyXSktKDBbMS05XXxbMTJdXFxcXGR8M1swMV0pfCgwWzQ2OV18MTEpLSgwWzEtOV18WzEyXVxcXFxkfDMwKXwoMDIpLSgwWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XG5jb25zdCBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKGBeJHtkYXRlUmVnZXhTb3VyY2V9JGApO1xuZnVuY3Rpb24gdGltZVJlZ2V4U291cmNlKGFyZ3MpIHtcbiAgICBsZXQgc2Vjb25kc1JlZ2V4U291cmNlID0gYFswLTVdXFxcXGRgO1xuICAgIGlmIChhcmdzLnByZWNpc2lvbikge1xuICAgICAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdzLnByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHNlY29uZHNSZWdleFNvdXJjZSA9IGAke3NlY29uZHNSZWdleFNvdXJjZX0oXFxcXC5cXFxcZCspP2A7XG4gICAgfVxuICAgIGNvbnN0IHNlY29uZHNRdWFudGlmaWVyID0gYXJncy5wcmVjaXNpb24gPyBcIitcIiA6IFwiP1wiOyAvLyByZXF1aXJlIHNlY29uZHMgaWYgcHJlY2lzaW9uIGlzIG5vbnplcm9cbiAgICByZXR1cm4gYChbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkKDoke3NlY29uZHNSZWdleFNvdXJjZX0pJHtzZWNvbmRzUXVhbnRpZmllcn1gO1xufVxuZnVuY3Rpb24gdGltZVJlZ2V4KGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfSRgKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzE0MzIzMVxuZXhwb3J0IGZ1bmN0aW9uIGRhdGV0aW1lUmVnZXgoYXJncykge1xuICAgIGxldCByZWdleCA9IGAke2RhdGVSZWdleFNvdXJjZX1UJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9YDtcbiAgICBjb25zdCBvcHRzID0gW107XG4gICAgb3B0cy5wdXNoKGFyZ3MubG9jYWwgPyBgWj9gIDogYFpgKTtcbiAgICBpZiAoYXJncy5vZmZzZXQpXG4gICAgICAgIG9wdHMucHVzaChgKFsrLV1cXFxcZHsyfTo/XFxcXGR7Mn0pYCk7XG4gICAgcmVnZXggPSBgJHtyZWdleH0oJHtvcHRzLmpvaW4oXCJ8XCIpfSlgO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSVAoaXAsIHZlcnNpb24pIHtcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NlJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSldUKGp3dCwgYWxnKSB7XG4gICAgaWYgKCFqd3RSZWdleC50ZXN0KGp3dCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBbaGVhZGVyXSA9IGp3dC5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmICghaGVhZGVyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBDb252ZXJ0IGJhc2U2NHVybCB0byBiYXNlNjRcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gaGVhZGVyXG4gICAgICAgICAgICAucmVwbGFjZSgvLS9nLCBcIitcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9fL2csIFwiL1wiKVxuICAgICAgICAgICAgLnBhZEVuZChoZWFkZXIubGVuZ3RoICsgKCg0IC0gKGhlYWRlci5sZW5ndGggJSA0KSkgJSA0KSwgXCI9XCIpO1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gSlNPTi5wYXJzZShhdG9iKGJhc2U2NCkpO1xuICAgICAgICBpZiAodHlwZW9mIGRlY29kZWQgIT09IFwib2JqZWN0XCIgfHwgZGVjb2RlZCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKFwidHlwXCIgaW4gZGVjb2RlZCAmJiBkZWNvZGVkPy50eXAgIT09IFwiSldUXCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGVjb2RlZC5hbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChhbGcgJiYgZGVjb2RlZC5hbGcgIT09IGFsZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRDaWRyKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRDaWRyUmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXVpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibmFub2lkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJuYW5vaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkMlJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFJlc3VsdCA9IGNoZWNrLnJlZ2V4LnRlc3QoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwicmVnZXhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRyaW1cIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW5jbHVkZXNcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5pbmNsdWRlcyhjaGVjay52YWx1ZSwgY2hlY2sucG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgaW5jbHVkZXM6IGNoZWNrLnZhbHVlLCBwb3NpdGlvbjogY2hlY2sucG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvTG93ZXJDYXNlXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b1VwcGVyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwic3RhcnRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLnN0YXJ0c1dpdGgoY2hlY2sudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgc3RhcnRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVuZHNXaXRoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuZW5kc1dpdGgoY2hlY2sudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgZW5kc1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBkYXRldGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBkYXRlUmVnZXg7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSB0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImR1cmF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWR1cmF0aW9uUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpcFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSVAoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJpcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiand0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRKV1QoaW5wdXQuZGF0YSwgY2hlY2suYWxnKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImp3dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY2lkclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkQ2lkcihpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImNpZHJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImJhc2U2NFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlNjRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjR1cmxcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0dXJsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBfcmVnZXgocmVnZXgsIHZhbGlkYXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmaW5lbWVudCgoZGF0YSkgPT4gcmVnZXgudGVzdChkYXRhKSwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbixcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbWFpbChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1haWxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1cmwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVybFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGVtb2ppKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbW9qaVwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHV1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInV1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBuYW5vaWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcIm5hbm9pZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkMihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZDJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1bGlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1bGlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJiYXNlNjRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBiYXNlNjR1cmwobWVzc2FnZSkge1xuICAgICAgICAvLyBiYXNlNjR1cmwgZW5jb2RpbmcgaXMgYSBtb2RpZmljYXRpb24gb2YgYmFzZTY0IHRoYXQgY2FuIHNhZmVseSBiZSB1c2VkIGluIFVSTHMgYW5kIGZpbGVuYW1lc1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGp3dChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiand0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgaXAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgY2lkcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY2lkclwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGRhdGV0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsb2NhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiBvcHRpb25zPy5wcmVjaXNpb24gPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucz8ucHJlY2lzaW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiBvcHRpb25zPy5vZmZzZXQgPz8gZmFsc2UsXG4gICAgICAgICAgICBsb2NhbDogb3B0aW9ucz8ubG9jYWwgPz8gZmFsc2UsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucz8ubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkYXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIHRpbWUob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiBvcHRpb25zPy5wcmVjaXNpb24gPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucz8ucHJlY2lzaW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHVyYXRpb24obWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0aW9ucz8ucG9zaXRpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucz8ubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuZHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImVuZHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4TGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBsZW4sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIGAubWluKDEpYFxuICAgICAqL1xuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gICAgfVxuICAgIHRyaW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b0xvd2VyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1VwcGVyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRldGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRlXCIpO1xuICAgIH1cbiAgICBnZXQgaXNUaW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImR1cmF0aW9uXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbWFpbCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVJMKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1vamkoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1vamlcIik7XG4gICAgfVxuICAgIGdldCBpc1VVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzTkFOT0lEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcIm5hbm9pZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEMigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVUxJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1bGlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNJUCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpcFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ0lEUigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjaWRyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjR1cmwoKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpO1xuICAgIH1cbiAgICBnZXQgbWluTGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RTdHJpbmcuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgPz8gZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zOTY2NDg0L3doeS1kb2VzLW1vZHVsdXMtb3BlcmF0b3ItcmV0dXJuLWZyYWN0aW9uYWwtbnVtYmVyLWluLWphdmFzY3JpcHQvMzE3MTEwMzQjMzE3MTEwMzRcbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXBEZWNDb3VudCA9IChzdGVwLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gICAgY29uc3QgdmFsSW50ID0gTnVtYmVyLnBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgY29uc3Qgc3RlcEludCA9IE51bWJlci5wYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICByZXR1cm4gKHZhbEludCAlIHN0ZXBJbnQpIC8gMTAgKiogZGVjQ291bnQ7XG59XG5leHBvcnQgY2xhc3MgWm9kTnVtYmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgICAgIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gTnVtYmVyKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZmluaXRlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW50KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluaXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzYWZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXQgaXNJbnQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHwgKGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSkpO1xuICAgIH1cbiAgICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fCBjaC5raW5kID09PSBcImludFwiIHx8IGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtaW4pICYmIE51bWJlci5pc0Zpbml0ZShtYXgpO1xuICAgIH1cbn1cblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcixcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RCaWdJbnQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCaWdJbnQoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5iaWdpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX2dldEludmFsaWRJbnB1dChpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCaWdJbnQsXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgPz8gZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQm9vbGVhbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJvb2xlYW4oaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5ib29sZWFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQm9vbGVhbi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RCb29sZWFuKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZERhdGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBuZXcgRGF0ZShpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQuZGF0YS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLnZhbHVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBEYXRlKGlucHV0LmRhdGEuZ2V0VGltZSgpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaW4obWluRGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5EYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhEYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pbkRhdGUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBtYXhEYXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsO1xuICAgIH1cbn1cblpvZERhdGUuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgfHwgZmFsc2UsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RTeW1ib2wgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zeW1ib2wpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3ltYm9sLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFN5bWJvbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTeW1ib2woe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN5bWJvbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RVbmRlZmluZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVuZGVmaW5lZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2ROdWxsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RBbnkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gdG8gcHJldmVudCBpbnN0YW5jZXMgb2Ygb3RoZXIgY2xhc3NlcyBmcm9tIGV4dGVuZGluZyBab2RBbnkuIHRoaXMgY2F1c2VzIGlzc3VlcyB3aXRoIGNhdGNoYWxsIGluIFpvZE9iamVjdC5cbiAgICAgICAgdGhpcy5fYW55ID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RBbnkuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQW55KHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVW5rbm93biBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVua25vd24oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTmV2ZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbn1cblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5ldmVyKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RWb2lkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnZvaWQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVm9pZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RWb2lkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RWb2lkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEFycmF5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBzdGF0dXMgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjdHguZGF0YS5sZW5ndGggPCBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHRvb0JpZyA/IFpvZElzc3VlQ29kZS50b29fYmlnIDogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogKHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogKHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5MZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5MZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBkZWVwUGFydGlhbGlmeShzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZEFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIEluIG1vc3QgY2FzZXMsIHRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIHVua25vd24gcHJvcGVydGllcyBhcmUgbm93IHNpbGVudGx5IHN0cmlwcGVkLlxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgICAgICAvLyBleHRlbmQ8XG4gICAgICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGUsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgICAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+LFxuICAgICAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgICAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT5cbiAgICAgICAgLy8gPihcbiAgICAgICAgLy8gICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgICAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgQXVnbWVudGF0aW9uPixcbiAgICAgICAgLy8gICBVbmtub3duS2V5cyxcbiAgICAgICAgLy8gICBDYXRjaGFsbCxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQsXG4gICAgICAgIC8vICAgTmV3SW5wdXRcbiAgICAgICAgLy8gPiB7XG4gICAgICAgIC8vICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAvLyAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAvLyAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC8vICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAvLyAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgIC8vICAgICB9KSxcbiAgICAgICAgLy8gICB9KSBhcyBhbnk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgLmV4dGVuZGAgaW5zdGVhZFxuICAgICAgICAgKiAgKi9cbiAgICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gICAgfVxuICAgIF9nZXRDYWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0geyBzaGFwZSwga2V5cyB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XG4gICAgICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1biBjYXRjaGFsbCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYXRjaGFsbC5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDogcGFpci5hbHdheXNTZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3luY1BhaXJzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoc3luY1BhaXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgfVxuICAgIHN0cmljdChtZXNzYWdlKSB7XG4gICAgICAgIGVycm9yVXRpbC5lcnJUb09iajtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdEVycm9yID0gdGhpcy5fZGVmLmVycm9yTWFwPy4oaXNzdWUsIGN0eCkubWVzc2FnZSA/PyBjdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSA/PyBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdHJpcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhc3N0aHJvdWdoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxuICAgIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XG4gICAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAgIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgIC8vICAgKTogWm9kT2JqZWN0PFxuICAgIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXG4gICAgLy8gICA+ID0+IHtcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICAgIC4uLmRlZixcbiAgICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxuICAgIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgIC8vICAgICAgIH0pLFxuICAgIC8vICAgICB9KSBhcyBhbnk7XG4gICAgLy8gICB9O1xuICAgIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICAgKiB1cGdyYWRlIGlmIHlvdSBhcmUgZXhwZXJpZW5jaW5nIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBtZXJnZShtZXJnaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgICAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICAvLyBtZXJnZTxcbiAgICAvLyAgIEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0LFxuICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcbiAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH0sXG4gICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfVxuICAgIC8vID4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQsXG4gICAgLy8gICBOZXdJbnB1dFxuICAgIC8vID4ge1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIHNldEtleShrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcbiAgICB9XG4gICAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiAvL1pvZE9iamVjdDxUICYgSW5jb21pbmdbXCJfc2hhcGVcIl0sIFVua25vd25LZXlzLCBDYXRjaGFsbD4gPSAobWVyZ2luZykgPT4ge1xuICAgIC8vIFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyA+IHtcbiAgICAvLyAgIC8vIGNvbnN0IG1lcmdlZFNoYXBlID0gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyhcbiAgICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gICAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgLy8gICAvLyApO1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNhdGNoYWxsOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpY2sobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXMobWFzaykpIHtcbiAgICAgICAgICAgIGlmIChtYXNrW2tleV0gJiYgdGhpcy5zaGFwZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbWl0KG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKSB7XG4gICAgICAgICAgICBpZiAoIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBkZWVwUGFydGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBQYXJ0aWFsaWZ5KHRoaXMpO1xuICAgIH1cbiAgICBwYXJ0aWFsKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1aXJlZChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmllbGQgPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gbmV3RmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAga2V5b2YoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVab2RFbnVtKHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSk7XG4gICAgfVxufVxuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3QubGF6eWNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RlZi5vcHRpb25zO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBmaXJzdCBpc3N1ZS1mcmVlIHZhbGlkYXRpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpc3N1ZXMgZnJvbSBkaXJ0eSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5yZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gaW52YWxpZFxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChvcHRpb25zLm1hcChhc3luYyAob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSkudGhlbihoYW5kbGVSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzc3VlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmICFkaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eSA9IHsgcmVzdWx0LCBjdHg6IGNoaWxkQ3R4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXMucHVzaChjaGlsZEN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmRpcnR5LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlydHkucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSBpc3N1ZXMubWFwKChpc3N1ZXMpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbn1cblpvZFVuaW9uLmNyZWF0ZSA9ICh0eXBlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgICAgIG9wdGlvbnM6IHR5cGVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IGdldERpc2NyaW1pbmF0b3IgPSAodHlwZSkgPT4ge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuaW5uZXJUeXBlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gW3R5cGUudmFsdWVdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xuICAgICAgICByZXR1cm4gdHlwZS5vcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTmF0aXZlRW51bSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXModHlwZS5lbnVtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZERlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RVbmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbCkge1xuICAgICAgICByZXR1cm4gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEJyYW5kZWQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RSZWFkb25seSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZENhdGNoKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5leHBvcnQgY2xhc3MgWm9kRGlzY3JpbWluYXRlZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSB0aGlzLmRpc2NyaW1pbmF0b3I7XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGN0eC5kYXRhW2Rpc2NyaW1pbmF0b3JdO1xuICAgICAgICBjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvbnNNYXAuZ2V0KGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgICAgIGlmICghb3B0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IEFycmF5LmZyb20odGhpcy5vcHRpb25zTWFwLmtleXMoKSksXG4gICAgICAgICAgICAgICAgcGF0aDogW2Rpc2NyaW1pbmF0b3JdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZGlzY3JpbWluYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5kaXNjcmltaW5hdG9yO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbiAgICBnZXQgb3B0aW9uc01hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zTWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRpc2NyaW1pbmF0ZWQgdW5pb24gc2NoZW1hLiBJdHMgYmVoYXZpb3VyIGlzIHZlcnkgc2ltaWxhciB0byB0aGF0IG9mIHRoZSBub3JtYWwgei51bmlvbigpIGNvbnN0cnVjdG9yLlxuICAgICAqIEhvd2V2ZXIsIGl0IG9ubHkgYWxsb3dzIGEgdW5pb24gb2Ygb2JqZWN0cywgYWxsIG9mIHdoaWNoIG5lZWQgdG8gc2hhcmUgYSBkaXNjcmltaW5hdG9yIHByb3BlcnR5LiBUaGlzIHByb3BlcnR5IG11c3RcbiAgICAgKiBoYXZlIGEgZGlmZmVyZW50IHZhbHVlIGZvciBlYWNoIG9iamVjdCBpbiB0aGUgdW5pb24uXG4gICAgICogQHBhcmFtIGRpc2NyaW1pbmF0b3IgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0gdHlwZXMgYW4gYXJyYXkgb2Ygb2JqZWN0IHNjaGVtYXNcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkaXNjcmltaW5hdG9yLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgdmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZXNcbiAgICAgICAgY29uc3Qgb3B0aW9uc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gdHJ5IHtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZXMgPSBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2hhcGVbZGlzY3JpbWluYXRvcl0pO1xuICAgICAgICAgICAgaWYgKCFkaXNjcmltaW5hdG9yVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBkaXNjcmltaW5hdG9yIHZhbHVlIGZvciBrZXkgXFxgJHtkaXNjcmltaW5hdG9yfVxcYCBjb3VsZCBub3QgYmUgZXh0cmFjdGVkIGZyb20gYWxsIHNjaGVtYSBvcHRpb25zYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRpc2NyaW1pbmF0b3JWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc01hcC5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlzY3JpbWluYXRvciBwcm9wZXJ0eSAke1N0cmluZyhkaXNjcmltaW5hdG9yKX0gaGFzIGR1cGxpY2F0ZSB2YWx1ZSAke1N0cmluZyh2YWx1ZSl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnNNYXAuc2V0KHZhbHVlLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZERpc2NyaW1pbmF0ZWRVbmlvbih7XG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERpc2NyaW1pbmF0ZWRVbmlvbixcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9uc01hcCxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VWYWx1ZXMoYSwgYikge1xuICAgIGNvbnN0IGFUeXBlID0gZ2V0UGFyc2VkVHlwZShhKTtcbiAgICBjb25zdCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYik7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICBjb25zdCBiS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhiKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhhKS5maWx0ZXIoKGtleSkgPT4gYktleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IHsgLi4uYSwgLi4uYiB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3T2JqIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1CID0gYltpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGl0ZW1BLCBpdGVtQik7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdBcnJheSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiYgK2EgPT09ICtiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kSW50ZXJzZWN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZVBhcnNlZCA9IChwYXJzZWRMZWZ0LCBwYXJzZWRSaWdodCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQWJvcnRlZChwYXJzZWRMZWZ0KSB8fCBpc0Fib3J0ZWQocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEaXJ0eShwYXJzZWRMZWZ0KSB8fCBpc0RpcnR5KHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBtZXJnZWQuZGF0YSB9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYubGVmdC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pLnRoZW4oKFtsZWZ0LCByaWdodF0pID0+IGhhbmRsZVBhcnNlZChsZWZ0LCByaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pLCB0aGlzLl9kZWYucmlnaHQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RJbnRlcnNlY3Rpb24uY3JlYXRlID0gKGxlZnQsIHJpZ2h0LCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RJbnRlcnNlY3Rpb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLyB0eXBlIFpvZFR1cGxlSXRlbXMgPSBbWm9kVHlwZUFueSwgLi4uWm9kVHlwZUFueVtdXTtcbmV4cG9ydCBjbGFzcyBab2RUdXBsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN0ID0gdGhpcy5fZGVmLnJlc3Q7XG4gICAgICAgIGlmICghcmVzdCAmJiBjdHguZGF0YS5sZW5ndGggPiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtcyA9IFsuLi5jdHguZGF0YV1cbiAgICAgICAgICAgIC5tYXAoKGl0ZW0sIGl0ZW1JbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmLml0ZW1zW2l0ZW1JbmRleF0gfHwgdGhpcy5fZGVmLnJlc3Q7XG4gICAgICAgICAgICBpZiAoIXNjaGVtYSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKCh4KSA9PiAhIXgpOyAvLyBmaWx0ZXIgbnVsbHNcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChpdGVtcykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgaXRlbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pdGVtcztcbiAgICB9XG4gICAgcmVzdChyZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmVzdCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuWm9kVHVwbGUuY3JlYXRlID0gKHNjaGVtYXMsIHBhcmFtcykgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgIGl0ZW1zOiBzY2hlbWFzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFR1cGxlLFxuICAgICAgICByZXN0OiBudWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RNYXAgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm1hcCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwgW2luZGV4LCBcImtleVwiXSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTWFwKHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE1hcCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RTZXQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnNldCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zZXQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChkZWYubWluU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPCBkZWYubWluU2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluU2l6ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5TaXplLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhTaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA+IGRlZi5tYXhTaXplLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4U2l6ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhTaXplLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZnVuY3Rpb24gZmluYWxpemVTZXQoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRTZXQuYWRkKGVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBwYXJzZWRTZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5jdHguZGF0YS52YWx1ZXMoKV0ubWFwKChpdGVtLCBpKSA9PiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpKTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChlbGVtZW50cykudGhlbigoZWxlbWVudHMpID0+IGZpbmFsaXplU2V0KGVsZW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxpemVTZXQoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1pbihtaW5TaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pblNpemU6IHsgdmFsdWU6IG1pblNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heFNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4U2l6ZTogeyB2YWx1ZTogbWF4U2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaXplKHNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kU2V0LmNyZWF0ZSA9ICh2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBtaW5TaXplOiBudWxsLFxuICAgICAgICBtYXhTaXplOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFNldCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCwgY3R4LnNjaGVtYUVycm9yTWFwLCBnZXRFcnJvck1hcCgpLCBkZWZhdWx0RXJyb3JNYXBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VSZXR1cm5zSXNzdWUocmV0dXJucywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHJldHVybnMsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIGN0eC5zY2hlbWFFcnJvck1hcCwgZ2V0RXJyb3JNYXAoKSwgZGVmYXVsdEVycm9yTWFwXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xuICAgICAgICBjb25zdCBmbiA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IG1lLl9kZWYuYXJncy5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZUFyZ3NJc3N1ZShhcmdzLCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFJlZmxlY3QuYXBwbHkoZm4sIHRoaXMsIHBhcnNlZEFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBhd2FpdCBtZS5fZGVmLnJldHVybnMuX2RlZi50eXBlXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKHJlc3VsdCwgcGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPSyhmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBtZS5fZGVmLmFyZ3Muc2FmZVBhcnNlKGFyZ3MsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRBcmdzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlQXJnc0lzc3VlKGFyZ3MsIHBhcnNlZEFyZ3MuZXJyb3IpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuYXBwbHkoZm4sIHRoaXMsIHBhcnNlZEFyZ3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IG1lLl9kZWYucmV0dXJucy5zYWZlUGFyc2UocmVzdWx0LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkUmV0dXJucy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIHBhcnNlZFJldHVybnMuZXJyb3IpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zLmRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJhbWV0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmFyZ3M7XG4gICAgfVxuICAgIHJldHVyblR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYucmV0dXJucztcbiAgICB9XG4gICAgYXJncyguLi5pdGVtcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGFyZ3M6IFpvZFR1cGxlLmNyZWF0ZShpdGVtcykucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybnMocmV0dXJuVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJldHVybnM6IHJldHVyblR5cGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0cmljdEltcGxlbWVudChmdW5jKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShhcmdzLCByZXR1cm5zLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICBhcmdzOiAoYXJncyA/IGFyZ3MgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSkpLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCBab2RVbmtub3duLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RGdW5jdGlvbixcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZExhenkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGxhenlTY2hlbWEgPSB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgfVxufVxuWm9kTGF6eS5jcmVhdGUgPSAoZ2V0dGVyLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgICAgICBnZXR0ZXI6IGdldHRlcixcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMYXp5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZExpdGVyYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjbGFzcyBab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IFNldCh0aGlzLl9kZWYudmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgRW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGV4dHJhY3QodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHZhbHVlcywge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhjbHVkZSh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigob3B0KSA9PiAhdmFsdWVzLmluY2x1ZGVzKG9wdCkpLCB7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAuLi5uZXdEZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbmV4cG9ydCBjbGFzcyBab2ROYXRpdmVFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUVudW1WYWx1ZXMgPSB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nICYmIGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBTZXQodXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbn1cblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RQcm9taXNlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnByb21pc2UgJiYgY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2lmaWVkID0gY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZSA/IGN0eC5kYXRhIDogUHJvbWlzZS5yZXNvbHZlKGN0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cblpvZFByb21pc2UuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFByb21pc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRWZmZWN0cyBleHRlbmRzIFpvZFR5cGUge1xuICAgIGlubmVyVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIHNvdXJjZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzXG4gICAgICAgICAgICA/IHRoaXMuX2RlZi5zY2hlbWEuc291cmNlVHlwZSgpXG4gICAgICAgICAgICA6IHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XG4gICAgICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnBhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhLCBjaGVja0N0eCk7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvY2Vzc2VkKS50aGVuKGFzeW5jIChwcm9jZXNzZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVJlZmluZW1lbnQgPSAoYWNjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnJlZmluZW1lbnQoYWNjLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGlubmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3luY2hyb25vdXMgdHJhbnNmb3JtIGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHJlc3VsdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCB7IFpvZEVmZmVjdHMgYXMgWm9kVHJhbnNmb3JtZXIgfTtcbmV4cG9ydCBjbGFzcyBab2RPcHRpb25hbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RPcHRpb25hbC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPcHRpb25hbCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPcHRpb25hbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2ROdWxsYWJsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBPSyhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGxhYmxlKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGxhYmxlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZERlZmF1bHQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdHlwZW9mIHBhcmFtcy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuZGVmYXVsdCA6ICgpID0+IHBhcmFtcy5kZWZhdWx0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZENhdGNoIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICAvLyBuZXdDdHggaXMgdXNlZCB0byBub3QgY29sbGVjdCBpc3N1ZXMgZnJvbSBpbm5lciB0eXBlcyBpbiBjdHhcbiAgICAgICAgY29uc3QgbmV3Q3R4ID0ge1xuICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YTogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICBwYXRoOiBuZXdDdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDoge1xuICAgICAgICAgICAgICAgIC4uLm5ld0N0eCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kQ2F0Y2guY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIGNhdGNoVmFsdWU6IHR5cGVvZiBwYXJhbXMuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcy5jYXRjaCA6ICgpID0+IHBhcmFtcy5jYXRjaCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2ROYU4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5uYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxufVxuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hTih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xuZXhwb3J0IGNsYXNzIFpvZEJyYW5kZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjdHguZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RQaXBlbGluZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgICAgICAgIGluOiBhLFxuICAgICAgICAgICAgb3V0OiBiLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZFJlYWRvbmx5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgY29uc3QgZnJlZXplID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS52YWx1ZSA9IE9iamVjdC5mcmVlemUoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KSA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpIDogZnJlZXplKHJlc3VsdCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUmVhZG9ubHkoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVhZG9ubHksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgei5jdXN0b20gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBjbGVhblBhcmFtcyhwYXJhbXMsIGRhdGEpIHtcbiAgICBjb25zdCBwID0gdHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zKGRhdGEpIDogdHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcGFyYW1zIH0gOiBwYXJhbXM7XG4gICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgICByZXR1cm4gcDI7XG59XG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tKGNoZWNrLCBfcGFyYW1zID0ge30sIFxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqIFBhc3MgYGZhdGFsYCBpbnRvIHRoZSBwYXJhbXMgb2JqZWN0IGluc3RlYWQ6XG4gKlxuICogYGBgdHNcbiAqIHouc3RyaW5nKCkuY3VzdG9tKCh2YWwpID0+IHZhbC5sZW5ndGggPiA1LCB7IGZhdGFsOiBmYWxzZSB9KVxuICogYGBgXG4gKlxuICovXG5mYXRhbCkge1xuICAgIGlmIChjaGVjaylcbiAgICAgICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKS5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByID0gY2hlY2soZGF0YSk7XG4gICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50aGVuKChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSBwYXJhbXMuZmF0YWwgPz8gZmF0YWwgPz8gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gcGFyYW1zLmZhdGFsID8/IGZhdGFsID8/IHRydWU7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucGFyYW1zLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KTtcbiAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpO1xufVxuZXhwb3J0IHsgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZFR5cGUgYXMgWm9kU2NoZW1hIH07XG5leHBvcnQgY29uc3QgbGF0ZSA9IHtcbiAgICBvYmplY3Q6IFpvZE9iamVjdC5sYXp5Y3JlYXRlLFxufTtcbmV4cG9ydCB2YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3ltYm9sXCJdID0gXCJab2RTeW1ib2xcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxcIl0gPSBcIlpvZE51bGxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBbnlcIl0gPSBcIlpvZEFueVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROZXZlclwiXSA9IFwiWm9kTmV2ZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RWb2lkXCJdID0gXCJab2RWb2lkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT2JqZWN0XCJdID0gXCJab2RPYmplY3RcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmlvblwiXSA9IFwiWm9kVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEludGVyc2VjdGlvblwiXSA9IFwiWm9kSW50ZXJzZWN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVHVwbGVcIl0gPSBcIlpvZFR1cGxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RNYXBcIl0gPSBcIlpvZE1hcFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFNldFwiXSA9IFwiWm9kU2V0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGF6eVwiXSA9IFwiWm9kTGF6eVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExpdGVyYWxcIl0gPSBcIlpvZExpdGVyYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRWZmZWN0c1wiXSA9IFwiWm9kRWZmZWN0c1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hdGl2ZUVudW1cIl0gPSBcIlpvZE5hdGl2ZUVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsYWJsZVwiXSA9IFwiWm9kTnVsbGFibGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REZWZhdWx0XCJdID0gXCJab2REZWZhdWx0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUHJvbWlzZVwiXSA9IFwiWm9kUHJvbWlzZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJyYW5kZWRcIl0gPSBcIlpvZEJyYW5kZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWFkb25seVwiXSA9IFwiWm9kUmVhZG9ubHlcIjtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kID0ge30pKTtcbi8vIHJlcXVpcmVzIFRTIDQuNCtcbmNsYXNzIENsYXNzIHtcbiAgICBjb25zdHJ1Y3RvciguLi5fKSB7IH1cbn1cbmNvbnN0IGluc3RhbmNlT2ZUeXBlID0gKFxuLy8gY29uc3QgaW5zdGFuY2VPZlR5cGUgPSA8VCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG5jbHMsIHBhcmFtcyA9IHtcbiAgICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YCxcbn0pID0+IGN1c3RvbSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcbmNvbnN0IHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xuY29uc3QgbnVtYmVyVHlwZSA9IFpvZE51bWJlci5jcmVhdGU7XG5jb25zdCBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcbmNvbnN0IGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xuY29uc3QgYm9vbGVhblR5cGUgPSBab2RCb29sZWFuLmNyZWF0ZTtcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XG5jb25zdCBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcbmNvbnN0IGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xuY29uc3QgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcbmNvbnN0IHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xuY29uc3QgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XG5jb25zdCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xuY29uc3QgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmNvbnN0IGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcbmNvbnN0IG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcbmNvbnN0IG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbmNvbnN0IG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbmNvbnN0IHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xuZXhwb3J0IGNvbnN0IGNvZXJjZSA9IHtcbiAgICBzdHJpbmc6ICgoYXJnKSA9PiBab2RTdHJpbmcuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIG51bWJlcjogKChhcmcpID0+IFpvZE51bWJlci5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgYm9vbGVhbjogKChhcmcpID0+IFpvZEJvb2xlYW4uY3JlYXRlKHtcbiAgICAgICAgLi4uYXJnLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgfSkpLFxuICAgIGJpZ2ludDogKChhcmcpID0+IFpvZEJpZ0ludC5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgZGF0ZTogKChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxufTtcbmV4cG9ydCB7IGFueVR5cGUgYXMgYW55LCBhcnJheVR5cGUgYXMgYXJyYXksIGJpZ0ludFR5cGUgYXMgYmlnaW50LCBib29sZWFuVHlwZSBhcyBib29sZWFuLCBkYXRlVHlwZSBhcyBkYXRlLCBkaXNjcmltaW5hdGVkVW5pb25UeXBlIGFzIGRpc2NyaW1pbmF0ZWRVbmlvbiwgZWZmZWN0c1R5cGUgYXMgZWZmZWN0LCBlbnVtVHlwZSBhcyBlbnVtLCBmdW5jdGlvblR5cGUgYXMgZnVuY3Rpb24sIGluc3RhbmNlT2ZUeXBlIGFzIGluc3RhbmNlb2YsIGludGVyc2VjdGlvblR5cGUgYXMgaW50ZXJzZWN0aW9uLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYXBUeXBlIGFzIG1hcCwgbmFuVHlwZSBhcyBuYW4sIG5hdGl2ZUVudW1UeXBlIGFzIG5hdGl2ZUVudW0sIG5ldmVyVHlwZSBhcyBuZXZlciwgbnVsbFR5cGUgYXMgbnVsbCwgbnVsbGFibGVUeXBlIGFzIG51bGxhYmxlLCBudW1iZXJUeXBlIGFzIG51bWJlciwgb2JqZWN0VHlwZSBhcyBvYmplY3QsIG9ib29sZWFuLCBvbnVtYmVyLCBvcHRpb25hbFR5cGUgYXMgb3B0aW9uYWwsIG9zdHJpbmcsIHBpcGVsaW5lVHlwZSBhcyBwaXBlbGluZSwgcHJlcHJvY2Vzc1R5cGUgYXMgcHJlcHJvY2VzcywgcHJvbWlzZVR5cGUgYXMgcHJvbWlzZSwgcmVjb3JkVHlwZSBhcyByZWNvcmQsIHNldFR5cGUgYXMgc2V0LCBzdHJpY3RPYmplY3RUeXBlIGFzIHN0cmljdE9iamVjdCwgc3RyaW5nVHlwZSBhcyBzdHJpbmcsIHN5bWJvbFR5cGUgYXMgc3ltYm9sLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB2b2lkVHlwZSBhcyB2b2lkLCB9O1xuZXhwb3J0IGNvbnN0IE5FVkVSID0gSU5WQUxJRDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/.pnpm/next@14.2.32_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fohong%2FLibrary%2FMobile%20Documents%2Fcom~apple~CloudDocs%2Fdev%2Ftea-olive%2Fweb%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);